<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://vuepress.mirror.docker-practice.com/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Docker 从入门到实践</title>
    <link>https://vuepress.mirror.docker-practice.com/</link>
    <description></description>
    <language>zh-CN</language>
    <pubDate>Sat, 25 Jun 2022 13:34:49 GMT</pubDate>
    <lastBuildDate>Sat, 25 Jun 2022 13:34:49 GMT</lastBuildDate>
    <generator>@mr-hope/vuepress-plugin-feed</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <item>
      <title>修订记录</title>
      <link>https://vuepress.mirror.docker-practice.com/CHANGELOG/</link>
      <guid>https://vuepress.mirror.docker-practice.com/CHANGELOG/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">修订记录</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="修订记录"> 修订记录</h1>
<ul>
<li>
<p>1.4.0 2022-MM-DD</p>
<ul>
<li>以 Docker Compose v2 为例介绍 compose</li>
</ul>
</li>
<li>
<p>1.3.0 2021-12-02</p>
<ul>
<li>全面支持 Docker v20.10 新版本</li>
<li>新增 Docker Compose v2</li>
<li>Docker Hub 自动构建转为付费功能</li>
</ul>
</li>
<li>
<p>1.2.0 2020-12-20</p>
<ul>
<li>错误修复</li>
</ul>
</li>
<li>
<p>1.1.0 2019-12-31</p>
<ul>
<li>全面支持 Docker v19.03 新版本</li>
<li>增加 <code>BuildKit</code></li>
<li>增加 <code>docker buildx</code> 命令使用说明</li>
<li>增加 <code>docker manifest</code> 命令使用说明</li>
<li>移除 <code>Ubuntu 14.04</code> <code>Debian 8</code> <code>Debian 7</code></li>
</ul>
</li>
<li>
<p>1.0.0: 2018-12-31</p>
<ul>
<li>全面支持 Docker v18.x 新版本</li>
<li>添加如何调试 Docker</li>
<li>错误修正</li>
</ul>
</li>
<li>
<p>0.9.0: 2017-12-31</p>
<ul>
<li>对 v1.13.x 旧版本的最后支持</li>
</ul>
</li>
<li>
<p>0.9.0-rc2: 2017-12-10</p>
<ul>
<li>
<p>增加 Docker 中文资源链接</p>
</li>
<li>
<p>增加介绍基于 Docker 的 CI/CD 工具 <code>Drone</code></p>
</li>
<li>
<p>增加 <code>docker secret</code> 相关内容</p>
</li>
<li>
<p>增加 <code>docker config</code> 相关内容</p>
</li>
<li>
<p>增加 <code>LinuxKit</code> 相关内容</p>
</li>
<li>
<p>更新 <code>CoreOS</code> 章节</p>
</li>
<li>
<p>更新 <code>etcd</code> 章节，基于 3.x 版本</p>
</li>
<li>
<p>删除 <code>Docker Compose</code> 中的 <code>links</code>指令</p>
</li>
<li>
<p>替换 <code>docker daemon</code> 命令为 <code>dockerd</code></p>
</li>
<li>
<p>替换 <code>docker ps</code> 命令为 <code>docker container ls</code></p>
</li>
<li>
<p>替换 <code>docker images</code> 命令为 <code>docker image ls</code></p>
</li>
<li>
<p>修改 <code>安装 Docker</code> 一节中部分文字表述</p>
</li>
<li>
<p>移除历史遗留文件和错误的文件</p>
</li>
<li>
<p>优化文字排版</p>
</li>
<li>
<p>调整目录结构</p>
</li>
<li>
<p>修复内容逻辑错误</p>
</li>
<li>
<p>修复<code>404</code> 链接</p>
</li>
</ul>
</li>
<li>
<p>0.9.0-rc1: 2017-11-29</p>
<ul>
<li>
<p>根据最新版本（v17.09）修订内容</p>
</li>
<li>
<p>增加 <code>Dockerfile</code> 多阶段构建( <code>multistage builds</code> ) <code>Docker 17.05</code> 新增特性</p>
</li>
<li>
<p>增加 <code>docker exec</code> 子命令介绍</p>
</li>
<li>
<p>增加 <code>docker</code> 管理子命令 <code>container</code> <code>image</code> <code>network</code> <code>volume</code> 介绍</p>
</li>
<li>
<p>增加 <code>树莓派单片电脑</code> 安装 Docker</p>
</li>
<li>
<p>增加 Docker 存储驱动 <code>OverlayFS</code> 相关内容</p>
</li>
<li>
<p>更新 <code>Docker CE</code> <code>v17.x</code> 安装说明</p>
</li>
<li>
<p>更新 <code>Docker 网络</code> 一节</p>
</li>
<li>
<p>更新 <code>Docker Machine</code> 基于 0.13.0 版本</p>
</li>
<li>
<p>更新 <code>Docker Compose</code> 基于 3 文件格式</p>
</li>
<li>
<p>删除 <code>Docker Swarm</code> 相关内容，替换为 <code>Swarm mode</code> <code>Docker 1.12.0</code> 新增特性</p>
</li>
<li>
<p>删除 <code>docker run</code> <code>--link</code> 参数</p>
</li>
<li>
<p>精简 <code>Docker Registry</code> 一节</p>
</li>
<li>
<p>替换 <code>docker run</code> <code>-v</code> 参数为 <code>--mount</code></p>
</li>
<li>
<p>修复 <code>404</code> 链接</p>
</li>
<li>
<p>优化文字排版</p>
</li>
<li>
<p>增加离线阅读功能</p>
</li>
</ul>
</li>
<li>
<p>0.8.0: 2017-01-08</p>
<ul>
<li>修正文字内容</li>
<li>根据最新版本（1.12）修订安装使用</li>
<li>补充附录章节</li>
</ul>
</li>
<li>
<p>0.7.0: 2016-06-12</p>
<ul>
<li>根据最新版本进行命令调整</li>
<li>修正若干文字描述</li>
</ul>
</li>
<li>
<p>0.6.0: 2015-12-24</p>
<ul>
<li>补充 Machine 项目</li>
<li>修正若干 bug</li>
</ul>
</li>
<li>
<p>0.5.0: 2015-06-29</p>
<ul>
<li>添加 Compose 项目</li>
<li>添加 Machine 项目</li>
<li>添加 Swarm 项目</li>
<li>完善 Kubernetes 项目内容</li>
<li>添加 Mesos 项目内容</li>
</ul>
</li>
<li>
<p>0.4.0: 2015-05-08</p>
<ul>
<li>添加 Etcd 项目</li>
<li>添加 Fig 项目</li>
<li>添加 CoreOS 项目</li>
<li>添加 Kubernetes 项目</li>
</ul>
</li>
<li>
<p>0.3.0: 2014-11-25</p>
<ul>
<li>完成仓库章节</li>
<li>重写安全章节</li>
<li>修正底层实现章节的架构、命名空间、控制组、文件系统、容器格式等内容</li>
<li>添加对常见仓库和镜像的介绍</li>
<li>添加 Dockerfile 的介绍</li>
<li>重新校订中英文混排格式</li>
<li>修订文字表达</li>
<li>发布繁体版本分支：zh-Hant</li>
</ul>
</li>
<li>
<p>0.2.0: 2014-09-18</p>
<ul>
<li>对照官方文档重写介绍、基本概念、安装、镜像、容器、仓库、数据管理、网络等章节</li>
<li>添加底层实现章节</li>
<li>添加命令查询和资源链接章节</li>
<li>其它修正</li>
</ul>
</li>
<li>
<p>0.1.0: 2014-09-05</p>
<ul>
<li>添加基本内容</li>
<li>修正错别字和表达不通顺的地方</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Docker — 从入门到实践</title>
      <link>https://vuepress.mirror.docker-practice.com/</link>
      <guid>https://vuepress.mirror.docker-practice.com/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Docker — 从入门到实践</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="docker-从入门到实践"> Docker — 从入门到实践</h1>
<i>Content not supported</i>
<p><a href="https://github.com/yeasy/docker_practice" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/github/stars/yeasy/docker_practice.svg?style=social&amp;label=Stars" alt=""><i>Content not supported</i></a> <a href="https://github.com/yeasy/docker_practice/releases" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/github/release/yeasy/docker_practice/all.svg" alt=""><i>Content not supported</i></a> <a href="https://github.com/docker/docker-ce" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/badge/Based-Docker CE v20.10-blue.svg" alt=""><i>Content not supported</i></a> <a href="https://union-click.jd.com/jdc?e=&amp;p=JF8AANADIgZlGF0VAxUDVBJdHDISBFAfWRcCGzcRRANLXSJeEF4aVwkMGQ1eD0kdSVJKSQVJHBIEUB9ZFwIbGAxeB0gyS34PbFlHVHNkI0MQEAoIcSxyBWFLRAtZK1olABYHXR9eHAoQN2UbXCVQfN_jrYOwsw7T_5SOnZUiBmUbXBYBFwBVG14UBBAAZRxbHDJJUjscCEEHEQ4FSA4VBhBQZStrFjIiN1UrWCVAfARQT1gQA0cFAEwOEAcRDlMTDEALQAFTEwwRUhMAUR1cJQATBlES" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/badge/Docker 技术入门与实战-jd.com-red.svg" alt=""><i>Content not supported</i></a></p>
<p><strong>v1.3.0</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">语言</th>
<th style="text-align:left">-</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://github.com/yeasy/docker_practice" target="_blank" rel="noopener noreferrer">简体中文<i>Content not supported</i></a></td>
<td style="text-align:left"><a href="https://vuepress.mirror.docker-practice.com/" target="_blank" rel="noopener noreferrer">阅读<i>Content not supported</i></a></td>
</tr>
</tbody>
</table>
<p><a href="https://www.docker.com" target="_blank" rel="noopener noreferrer">Docker<i>Content not supported</i></a> 是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的维护效率，降低了云计算应用开发的成本！使用 Docker，可以让应用的部署、测试和分发都变得前所未有的高效和轻松！</p>
<p>无论是应用开发者、运维人员、还是其他信息技术从业人员，都有必要认识和掌握 Docker，节约有限的生命。</p>
<p>本书既适用于具备基础 Linux 知识的 Docker 初学者，也希望可供理解原理和实现的高级用户参考。同时，书中给出的实践案例，可供在进行实际部署时借鉴。前六章为基础内容，供用户理解 Docker 的基本概念和操作；7 ~ 9 章介绍包括数据管理、网络等高级操作；第 10 ~ 12 章介绍了容器生态中的几个核心项目；13、14 章讨论了关于 Docker 安全和实现技术等高级话题。后续章节则分别介绍包括 Etcd、Fedora CoreOS、Kubernetes、容器云等相关热门开源项目。最后，还展示了使用容器技术的典型的应用场景和实践案例。</p>
<ul>
<li>在线阅读：<a href="https://vuepress.mirror.docker-practice.com/" target="_blank" rel="noopener noreferrer">docker-practice.com<i>Content not supported</i></a>，<a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener noreferrer">GitBook<i>Content not supported</i></a>，<a href="https://github.com/yeasy/docker_practice/blob/master/SUMMARY.md" target="_blank" rel="noopener noreferrer">Github<i>Content not supported</i></a></li>
<li>离线阅读：<a href="https://github.com/yeasy/docker_practice/wiki/%E7%A6%BB%E7%BA%BF%E9%98%85%E8%AF%BB%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A3" target="_blank" rel="noopener noreferrer"><code>$ docker run -it --rm -p 4000:80 ccr.ccs.tencentyun.com/dockerpracticesig/docker_practice:vuepress</code><i>Content not supported</i></a></li>
</ul>
<p>Docker 自身仍在快速发展中，生态环境也在蓬勃成长。建议初学者使用最新稳定版本的 Docker 进行学习实践。欢迎 <a href="./CONTRIBUTING.html">参与项目维护</a>。</p>
<ul>
<li><a href="./CHANGELOG.html">修订记录</a></li>
<li><a href="https://github.com/yeasy/docker_practice/graphs/contributors" target="_blank" rel="noopener noreferrer">贡献者名单<i>Content not supported</i></a></li>
</ul>
<h2 id="微信小程序"> 微信小程序</h2>
<p align="center">
<img width="200" src="https://docker_practice.gitee.io/pic/dp-wechat-miniprogram.jpg">
</p>
<p align="center"><strong>微信扫码 随时随地阅读~</strong></p>
<h2 id="技术交流"> 技术交流</h2>
<p align="center">
<img width="200" src="https://docker_practice.gitee.io/pic/dpsig-wechat.jpg">
</p>
<p align="center"><strong>微信扫码 加入群聊~ 或者微信添加 <code>dpsigs</code> 邀请入群</strong></p>
<p>欢迎加入 Docker 技术交流 QQ 群，分享 Docker 资源，交流 Docker 技术。</p>
<ul>
<li>QQ 群 I   （已满）：341410255</li>
<li>QQ 群 II  （已满）：419042067</li>
<li>QQ 群 III （已满）：210028779</li>
<li>QQ 群 IV  （已满）：483702734</li>
<li>QQ 群 V   （已满）：460598761</li>
<li>QQ 群 VI  （已满）：581983671</li>
<li>QQ 群 VII （已满）：252403484</li>
<li>QQ 群 VIII（已满）：544818750</li>
<li>QQ 群 IX  （已满）：571502246</li>
<li>QQ 群 X   （可加）：145983035</li>
</ul>
<blockquote>
<p>如果有容器技术相关的疑问，请通过 <a href="https://github.com/yeasy/docker_practice/issues/new/choose" target="_blank" rel="noopener noreferrer">Issues<i>Content not supported</i></a> 来提出。</p>
</blockquote>
<h2 id="进阶学习"> 进阶学习</h2>
<p><a href="https://union-click.jd.com/jdc?e=&amp;p=JF8AANADIgZlGF0VAxUDVBJdHDISBFAfWRcCGzcRRANLXSJeEF4aVwkMGQ1eD0kdSVJKSQVJHBIEUB9ZFwIbGAxeB0gyS34PbFlHVHNkI0MQEAoIcSxyBWFLRAtZK1olABYHXR9eHAoQN2UbXCVQfN_jrYOwsw7T_5SOnZUiBmUbXBYBFwBVG14UBBAAZRxbHDJJUjscCEEHEQ4FSA4VBhBQZStrFjIiN1UrWCVAfARQT1gQA0cFAEwOEAcRDlMTDEALQAFTEwwRUhMAUR1cJQATBlES" target="_blank" rel="noopener noreferrer"><img src="https://github.com/yeasy/docker_practice/raw/master/_images/docker_primer3.png" alt=""><i>Content not supported</i></a></p>
<p>《<a href="https://union-click.jd.com/jdc?e=&amp;p=JF8AANADIgZlGF0VAxUDVBJdHDISBFAfWRcCGzcRRANLXSJeEF4aVwkMGQ1eD0kdSVJKSQVJHBIEUB9ZFwIbGAxeB0gyS34PbFlHVHNkI0MQEAoIcSxyBWFLRAtZK1olABYHXR9eHAoQN2UbXCVQfN_jrYOwsw7T_5SOnZUiBmUbXBYBFwBVG14UBBAAZRxbHDJJUjscCEEHEQ4FSA4VBhBQZStrFjIiN1UrWCVAfARQT1gQA0cFAEwOEAcRDlMTDEALQAFTEwwRUhMAUR1cJQATBlES" target="_blank" rel="noopener noreferrer">Docker 技术入门与实战<i>Content not supported</i></a>》第三版已经面世，介绍最新的容器技术栈，欢迎大家阅读使用并反馈建议。</p>
<ul>
<li><a href="https://union-click.jd.com/jdc?e=&amp;p=JF8AANADIgZlGF0VAxUDVBJdHDISBFAfWRcCGzcRRANLXSJeEF4aVwkMGQ1eD0kdSVJKSQVJHBIEUB9ZFwIbGAxeB0gyS34PbFlHVHNkI0MQEAoIcSxyBWFLRAtZK1olABYHXR9eHAoQN2UbXCVQfN_jrYOwsw7T_5SOnZUiBmUbXBYBFwBVG14UBBAAZRxbHDJJUjscCEEHEQ4FSA4VBhBQZStrFjIiN1UrWCVAfARQT1gQA0cFAEwOEAcRDlMTDEALQAFTEwwRUhMAUR1cJQATBlES" target="_blank" rel="noopener noreferrer">京东图书<i>Content not supported</i></a></li>
<li><a href="http://product.china-pub.com/8052127" target="_blank" rel="noopener noreferrer">China-Pub<i>Content not supported</i></a></li>
</ul>
<h2 id="鼓励项目"> 鼓励项目</h2>
<p align="center">
<img width="200" src="https://github.com/yeasy/docker_practice/raw/master/_images/donate.jpeg">
</p>
<p align="center"><strong>欢迎鼓励项目一杯 coffee~</strong></p>
]]></content:encoded>
      <enclosure url="https://img.shields.io/github/stars/yeasy/docker_practice.svg?style=social&label=Stars" type="image/"/>
    </item>
    <item>
      <title>如何贡献</title>
      <link>https://vuepress.mirror.docker-practice.com/CONTRIBUTING/</link>
      <guid>https://vuepress.mirror.docker-practice.com/CONTRIBUTING/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">如何贡献</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="如何贡献"> 如何贡献</h1>
<p>领取或创建新的 <a href="https://github.com/yeasy/docker_practice/issues" target="_blank" rel="noopener noreferrer">Issue<i>Content not supported</i></a>，如 <a href="https://github.com/yeasy/docker_practice/issues/235" target="_blank" rel="noopener noreferrer">issue 235<i>Content not supported</i></a>，添加自己为 <code>Assignee</code>。</p>
<p>在 <a href="https://github.com/yeasy/docker_practice/fork" target="_blank" rel="noopener noreferrer">GitHub<i>Content not supported</i></a> 上 <code>fork</code> 到自己的仓库，如 <code>docker_user/docker_practice</code>，然后 <code>clone</code> 到本地，并设置用户信息。</p>
<div><pre><code>$ <span>git</span> clone git@github.com:docker_user/docker_practice.git

$ <span>cd</span> docker_practice
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>修改代码后提交，并推送到自己的仓库，注意修改提交消息为对应 Issue 号和描述。</p>
<div><pre><code><span># Update the content</span>

$ <span>git</span> commit -a -s

<span># In commit msg dialog, add content like "Fix issue #235: describe ur change"</span>

$ <span>git</span> push
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在 <a href="https://github.com/yeasy/docker_practice/pulls" target="_blank" rel="noopener noreferrer">GitHub<i>Content not supported</i></a> 上提交 <code>Pull Request</code>，添加标签，并邀请维护者进行 <code>Review</code>。</p>
<p>定期使用项目仓库内容更新自己仓库内容。</p>
<div><pre><code>$ <span>git</span> remote <span>add</span> upstream https://github.com/yeasy/docker_practice

$ <span>git</span> fetch upstream

$ <span>git</span> rebase upstream/master

$ <span>git</span> push -f origin master
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="排版规范"> 排版规范</h2>
<p>本开源书籍遵循 <a href="https://github.com/mzlogin/chinese-copywriting-guidelines" target="_blank" rel="noopener noreferrer">中文排版指南<i>Content not supported</i></a> 规范。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Docker — 从入门到实践</title>
      <link>https://vuepress.mirror.docker-practice.com/SUMMARY/</link>
      <guid>https://vuepress.mirror.docker-practice.com/SUMMARY/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Docker — 从入门到实践</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="docker-从入门到实践"> <a href="https://github.com/yeasy/docker_practice/blob/master/SUMMARY.md" target="_blank" rel="noopener noreferrer">Docker — 从入门到实践<i>Content not supported</i></a></h1>
<i>Content not supported</i>
<ul>
<li><a href="./">前言</a></li>
<li><a href="./CHANGELOG.html">修订记录</a></li>
<li><a href="./CONTRIBUTING.html">如何贡献</a></li>
<li><a href="./introduction/">Docker 简介</a>
<ul>
<li><a href="./introduction/what.html">什么是 Docker</a></li>
<li><a href="./introduction/why.html">为什么要用 Docker</a></li>
</ul>
</li>
<li><a href="./basic_concept/">基本概念</a>
<ul>
<li><a href="./basic_concept/image.html">镜像</a></li>
<li><a href="./basic_concept/container.html">容器</a></li>
<li><a href="./basic_concept/repository.html">仓库</a></li>
</ul>
</li>
<li><a href="./install/">安装 Docker</a>
<ul>
<li><a href="./install/ubuntu.html">Ubuntu</a></li>
<li><a href="./install/debian.html">Debian</a></li>
<li><a href="./install/fedora.html">Fedora</a></li>
<li><a href="./install/centos.html">CentOS</a></li>
<li><a href="./install/raspberry-pi.html">Raspberry Pi</a></li>
<li><a href="./install/offline.html">Linux 离线安装</a></li>
<li><a href="./install/mac.html">macOS</a></li>
<li><a href="./install/windows.html">Windows 10/11</a></li>
<li><a href="./install/mirror.html">镜像加速器</a></li>
<li><a href="./install/experimental.html">开启实验特性</a></li>
</ul>
</li>
<li><a href="./image/">使用镜像</a>
<ul>
<li><a href="./image/pull.html">获取镜像</a></li>
<li><a href="./image/list.html">列出镜像</a></li>
<li><a href="./image/rm.html">删除本地镜像</a></li>
<li><a href="./image/commit.html">利用 commit 理解镜像构成</a></li>
<li><a href="./image/build.html">使用 Dockerfile 定制镜像</a></li>
<li><a href="./image/dockerfile/">Dockerfile 指令详解</a>
<ul>
<li><a href="./image/dockerfile/copy.html">COPY 复制文件</a></li>
<li><a href="./image/dockerfile/add.html">ADD 更高级的复制文件</a></li>
<li><a href="./image/dockerfile/cmd.html">CMD 容器启动命令</a></li>
<li><a href="./image/dockerfile/entrypoint.html">ENTRYPOINT 入口点</a></li>
<li><a href="./image/dockerfile/env.html">ENV 设置环境变量</a></li>
<li><a href="./image/dockerfile/arg.html">ARG 构建参数</a></li>
<li><a href="./image/dockerfile/volume.html">VOLUME 定义匿名卷</a></li>
<li><a href="./image/dockerfile/expose.html">EXPOSE 暴露端口</a></li>
<li><a href="./image/dockerfile/workdir.html">WORKDIR 指定工作目录</a></li>
<li><a href="./image/dockerfile/user.html">USER 指定当前用户</a></li>
<li><a href="./image/dockerfile/healthcheck.html">HEALTHCHECK 健康检查</a></li>
<li><a href="./image/dockerfile/onbuild.html">ONBUILD 为他人作嫁衣裳</a></li>
<li><a href="./image/dockerfile/label.html">LABEL 为镜像添加元数据</a></li>
<li><a href="./image/dockerfile/shell.html">SHELL 指令</a></li>
<li><a href="./image/dockerfile/references.html">参考文档</a></li>
</ul>
</li>
<li><a href="./image/multistage-builds/">Dockerfile 多阶段构建</a>
<ul>
<li><a href="./image/multistage-builds/laravel.html">实战多阶段构建 Laravel 镜像</a></li>
</ul>
</li>
<li><a href="./image/manifest.html">构建多种系统架构支持的 Docker 镜像</a></li>
<li><a href="./image/other.html">其它制作镜像的方式</a></li>
<li><a href="./image/internal.html">实现原理</a></li>
</ul>
</li>
<li><a href="./container/">操作容器</a>
<ul>
<li><a href="./container/run.html">启动</a></li>
<li><a href="./container/daemon.html">守护态运行</a></li>
<li><a href="./container/stop.html">终止</a></li>
<li><a href="./container/attach_exec.html">进入容器</a></li>
<li><a href="./container/import_export.html">导出和导入</a></li>
<li><a href="./container/rm.html">删除</a></li>
</ul>
</li>
<li><a href="./repository/">访问仓库</a>
<ul>
<li><a href="./repository/dockerhub.html">Docker Hub</a></li>
<li><a href="./repository/registry.html">私有仓库</a></li>
<li><a href="./repository/registry_auth.html">私有仓库高级配置</a></li>
<li><a href="./repository/nexus3_registry.html">Nexus 3</a></li>
</ul>
</li>
<li><a href="./data_management/">数据管理</a>
<ul>
<li><a href="./data_management/volume.html">数据卷</a></li>
<li><a href="./data_management/bind-mounts.html">挂载主机目录</a></li>
</ul>
</li>
<li><a href="./network/">使用网络</a>
<ul>
<li><a href="./network/port_mapping.html">外部访问容器</a></li>
<li><a href="./network/linking.html">容器互联</a></li>
<li><a href="./network/dns.html">配置 DNS</a></li>
</ul>
</li>
<li><a href="./advanced_network/">高级网络配置</a>
<ul>
<li><a href="./advanced_network/quick_guide.html">快速配置指南</a></li>
<li><a href="./advanced_network/access_control.html">容器访问控制</a></li>
<li><a href="./advanced_network/port_mapping.html">端口映射实现</a></li>
<li><a href="./advanced_network/docker0.html">配置 docker0 网桥</a></li>
<li><a href="./advanced_network/bridge.html">自定义网桥</a></li>
<li><a href="./advanced_network/example.html">工具和示例</a></li>
<li><a href="./advanced_network/config_file.html">编辑网络配置文件</a></li>
<li><a href="./advanced_network/ptp.html">实例：创建一个点到点连接</a></li>
</ul>
</li>
<li><a href="./buildx/">Docker Buildx</a>
<ul>
<li><a href="./buildx/buildkit.html">BuildKit</a></li>
<li><a href="./buildx/buildx.html">使用 buildx 构建镜像</a></li>
<li><a href="./buildx/multi-arch-images.html">使用 buildx 构建多种系统架构支持的 Docker 镜像</a></li>
</ul>
</li>
<li><a href="./compose/">Docker Compose</a>
<ul>
<li><a href="./compose/introduction.html">简介</a></li>
<li><a href="./compose/install.html">安装与卸载</a></li>
<li><a href="./compose/usage.html">使用</a></li>
<li><a href="./compose/commands.html">命令说明</a></li>
<li><a href="./compose/compose_file.html">Compose 模板文件</a></li>
<li><a href="./compose/django.html">实战 Django</a></li>
<li><a href="./compose/rails.html">实战 Rails</a></li>
<li><a href="./compose/wordpress.html">实战 WordPress</a></li>
<li><a href="./compose/lnmp.html">实战 LNMP</a></li>
</ul>
</li>
<li><a href="./swarm_mode/">Swarm mode</a>
<ul>
<li><a href="./swarm_mode/overview.html">基本概念</a></li>
<li><a href="./swarm_mode/create.html">创建 Swarm 集群</a></li>
<li><a href="./swarm_mode/deploy.html">部署服务</a></li>
<li><a href="./swarm_mode/stack.html">使用 compose 文件</a></li>
<li><a href="./swarm_mode/secret.html">管理密钥</a></li>
<li><a href="./swarm_mode/config.html">管理配置信息</a></li>
<li><a href="./swarm_mode/rolling_update.html">滚动升级</a></li>
</ul>
</li>
<li><a href="./security/">安全</a>
<ul>
<li><a href="./security/kernel_ns.html">内核命名空间</a></li>
<li><a href="./security/control_group.html">控制组</a></li>
<li><a href="./security/daemon_sec.html">服务端防护</a></li>
<li><a href="./security/kernel_capability.html">内核能力机制</a></li>
<li><a href="./security/other_feature.html">其它安全特性</a></li>
<li><a href="./security/summary.html">总结</a></li>
</ul>
</li>
<li><a href="./underly/">底层实现</a>
<ul>
<li><a href="./underly/arch.html">基本架构</a></li>
<li><a href="./underly/namespace.html">命名空间</a></li>
<li><a href="./underly/cgroups.html">控制组</a></li>
<li><a href="./underly/ufs.html">联合文件系统</a></li>
<li><a href="./underly/container_format.html">容器格式</a></li>
<li><a href="./underly/network.html">网络</a></li>
</ul>
</li>
<li><a href="./etcd/">Etcd 项目</a>
<ul>
<li><a href="./etcd/intro.html">简介</a></li>
<li><a href="./etcd/install.html">安装</a></li>
<li><a href="./etcd/cluster.html">集群</a></li>
<li><a href="./etcd/etcdctl.html">使用 etcdctl</a></li>
</ul>
</li>
<li><a href="./coreos/">Fedora CoreOS</a>
<ul>
<li><a href="./coreos/intro.html">简介</a></li>
<li><a href="./coreos/install.html">安装</a></li>
</ul>
</li>
<li><a href="./kubernetes/">Kubernetes - 开源容器编排引擎</a>
<ul>
<li><a href="./kubernetes/intro.html">简介</a></li>
<li><a href="./kubernetes/concepts.html">基本概念</a></li>
<li><a href="./kubernetes/design.html">架构设计</a></li>
</ul>
</li>
<li><a href="./kubernetes/setup/">部署 Kubernetes</a>
<ul>
<li><a href="./kubernetes/setup/kubeadm.html">使用 kubeadm 部署 kubernetes(CRI 使用 containerd)</a></li>
<li><a href="./kubernetes/setup/docker-desktop.html">在 Docker Desktop 使用</a></li>
<li><a href="./kubernetes/setup/systemd.html">一步步部署 kubernetes 集群</a></li>
<li><a href="./kubernetes/setup/dashboard.html">部署 Dashboard</a></li>
</ul>
</li>
<li><a href="./kubernetes/kubectl/">Kubernetes 命令行 kubectl</a></li>
<li><a href="./cloud/">容器与云计算</a>
<ul>
<li><a href="./cloud/intro.html">简介</a></li>
<li><a href="./cloud/tencentCloud.html">腾讯云</a></li>
<li><a href="./cloud/alicloud.html">阿里云</a></li>
<li><a href="./cloud/aws.html">亚马逊云</a></li>
<li><a href="./cloud/summary.html">小结</a></li>
</ul>
</li>
<li><a href="./cases/os/">实战案例 - 操作系统</a>
<ul>
<li><a href="./cases/os/busybox.html">Busybox</a></li>
<li><a href="./cases/os/alpine.html">Alpine</a></li>
<li><a href="./cases/os/debian.html">Debian Ubuntu</a></li>
<li><a href="./cases/os/centos.html">CentOS Fedora</a></li>
<li><a href="./cases/os/summary.html">本章小结</a></li>
</ul>
</li>
<li><a href="./cases/ci/">CI/CD</a>
<ul>
<li><a href="./cases/ci/actions/">GitHub Actions</a></li>
<li><a href="./cases/ci/drone/">Drone</a>
<ul>
<li><a href="./cases/ci/drone/install.html">部署 Drone</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="./ide/">在 IDE 中使用 Docker</a>
<ul>
<li><a href="./ide/vsCode.html">VS Code</a></li>
</ul>
</li>
<li><a href="./podman/">podman - 下一代 Linux 容器工具</a></li>
<li><a href="./appendix/">附录</a>
<ul>
<li><a href="./appendix/faq/">附录一：常见问题总结</a></li>
<li><a href="./appendix/repo/">附录二：热门镜像介绍</a>
<ul>
<li><a href="./appendix/repo/ubuntu.html">Ubuntu</a></li>
<li><a href="./appendix/repo/centos.html">CentOS</a></li>
<li><a href="./appendix/repo/nginx.html">Nginx</a></li>
<li><a href="./appendix/repo/php.html">PHP</a></li>
<li><a href="./appendix/repo/nodejs.html">Node.js</a></li>
<li><a href="./appendix/repo/mysql.html">MySQL</a></li>
<li><a href="./appendix/repo/wordpress.html">WordPress</a></li>
<li><a href="./appendix/repo/mongodb.html">MongoDB</a></li>
<li><a href="./appendix/repo/redis.html">Redis</a></li>
<li><a href="./appendix/repo/minio.html">Minio</a></li>
</ul>
</li>
<li><a href="./appendix/command/">附录三：Docker 命令查询</a>
<ul>
<li><a href="./appendix/command/docker.html">客户端命令 - docker</a></li>
<li><a href="./appendix/command/dockerd.html">服务端命令 - dockerd</a></li>
</ul>
</li>
<li><a href="./appendix/best_practices.html">附录四：Dockerfile 最佳实践</a></li>
<li><a href="./appendix/debug.html">附录五：如何调试 Docker</a></li>
<li><a href="./appendix/resources.html">附录六：资源链接</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>高级网络配置</title>
      <link>https://vuepress.mirror.docker-practice.com/advanced_network/</link>
      <guid>https://vuepress.mirror.docker-practice.com/advanced_network/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">高级网络配置</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="高级网络配置"> 高级网络配置</h1>
<i>Content not supported</i>
<blockquote>
<p>注意：本章属于 <code>Docker</code> 高级配置，如果您是初学者，您可以暂时跳过本章节，直接学习 <a href="../compose">Docker Compose</a> 一节。</p>
</blockquote>
<p>本章将介绍 Docker 的一些高级网络配置和选项。</p>
<p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>
<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a href="https://datatracker.ietf.org/doc/html/rfc1918" target="_blank" rel="noopener noreferrer">RFC1918<i>Content not supported</i></a> 中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>
<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>
<p><img src="./_images/network.png" alt="Docker 网络"></p>
<p>接下来的部分将介绍在一些场景中，Docker 所有的网络定制配置。以及通过 Linux 命令来调整、补充、甚至替换 Docker 默认的网络配置。</p>
]]></content:encoded>
    </item>
    <item>
      <title>容器访问控制</title>
      <link>https://vuepress.mirror.docker-practice.com/advanced_network/access_control/</link>
      <guid>https://vuepress.mirror.docker-practice.com/advanced_network/access_control/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">容器访问控制</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="容器访问控制"> 容器访问控制</h1>
<i>Content not supported</i>
<p>容器的访问控制，主要通过 Linux 上的 <code>iptables</code> 防火墙来进行管理和实现。<code>iptables</code> 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。</p>
<h2 id="容器访问外部网络"> 容器访问外部网络</h2>
<p>容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p>
<div><pre><code><span>$sysctl</span> net.ipv4.ip_forward
net.ipv4.ip_forward <span>=</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果为 0，说明没有开启转发，则需要手动打开。</p>
<div><pre><code><span>$sysctl</span> -w net.ipv4.ip_forward<span>=</span><span>1</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果在启动 Docker 服务的时候设定 <code>--ip-forward=true</code>, Docker 就会自动设定系统的 <code>ip_forward</code> 参数为 1。</p>
<h2 id="容器之间访问"> 容器之间访问</h2>
<p>容器之间相互访问，需要两方面的支持。</p>
<ul>
<li>容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 <code>docker0</code> 网桥上。</li>
<li>本地系统的防火墙软件 -- <code>iptables</code> 是否允许通过。</li>
</ul>
<h3 id="访问所有端口"> 访问所有端口</h3>
<p>当启动 Docker 服务（即 dockerd）的时候，默认会添加一条转发策略到本地主机 iptables 的 FORWARD 链上。策略为通过（<code>ACCEPT</code>）还是禁止（<code>DROP</code>）取决于配置<code>--icc=true</code>（缺省值）还是 <code>--icc=false</code>。当然，如果手动指定 <code>--iptables=false</code> 则不会添加 <code>iptables</code> 规则。</p>
<p>可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 <code>/etc/docker/daemon.json</code> 文件中配置 <code>{&quot;icc&quot;: false}</code> 来禁止它。</p>
<h3 id="访问指定端口"> 访问指定端口</h3>
<p>在通过 <code>-icc=false</code> 关闭网络访问后，还可以通过 <code>--link=CONTAINER_NAME:ALIAS</code> 选项来访问容器的开放端口。</p>
<p>例如，在启动 Docker 服务时，可以同时使用 <code>icc=false --iptables=true</code> 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 <code>iptables</code> 规则。</p>
<p>此时，系统中的 <code>iptables</code> 规则可能是类似</p>
<div><pre><code>$ <span>sudo</span> iptables -nL
<span>..</span>.
Chain FORWARD <span>(</span>policy ACCEPT<span>)</span>
target     prot opt <span>source</span>               destination
DROP       all  --  <span>0.0</span>.0.0/0            <span>0.0</span>.0.0/0
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>之后，启动容器（<code>docker run</code>）时使用 <code>--link=CONTAINER_NAME:ALIAS</code> 选项。Docker 会在 <code>iptable</code> 中为 两个容器分别添加一条 <code>ACCEPT</code> 规则，允许相互访问开放的端口（取决于 <code>Dockerfile</code> 中的 <code>EXPOSE</code> 指令）。</p>
<p>当添加了 <code>--link=CONTAINER_NAME:ALIAS</code> 选项后，添加了 <code>iptables</code> 规则。</p>
<div><pre><code>$ <span>sudo</span> iptables -nL
<span>..</span>.
Chain FORWARD <span>(</span>policy ACCEPT<span>)</span>
target     prot opt <span>source</span>               destination
ACCEPT     tcp  --  <span>172.17</span>.0.2           <span>172.17</span>.0.3           tcp spt:80
ACCEPT     tcp  --  <span>172.17</span>.0.3           <span>172.17</span>.0.2           tcp dpt:80
DROP       all  --  <span>0.0</span>.0.0/0            <span>0.0</span>.0.0/0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>注意：<code>--link=CONTAINER_NAME:ALIAS</code> 中的 <code>CONTAINER_NAME</code> 目前必须是 Docker 分配的名字，或使用 <code>--name</code> 参数指定的名字。主机名则不会被识别。</p>
]]></content:encoded>
    </item>
    <item>
      <title>自定义网桥</title>
      <link>https://vuepress.mirror.docker-practice.com/advanced_network/bridge/</link>
      <guid>https://vuepress.mirror.docker-practice.com/advanced_network/bridge/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">自定义网桥</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="自定义网桥"> 自定义网桥</h1>
<i>Content not supported</i>
<p>除了默认的 <code>docker0</code> 网桥，用户也可以指定网桥来连接各个容器。</p>
<p>在启动 Docker 服务的时候，使用 <code>-b BRIDGE</code>或<code>--bridge=BRIDGE</code> 来指定使用的网桥。</p>
<p>如果服务已经运行，那需要先停止服务，并删除旧的网桥。</p>
<div><pre><code>$ <span>sudo</span> systemctl stop <span>docker</span>
$ <span>sudo</span> <span>ip</span> <span>link</span> <span>set</span> dev docker0 down
$ <span>sudo</span> brctl delbr docker0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后创建一个网桥 <code>bridge0</code>。</p>
<div><pre><code>$ <span>sudo</span> brctl addbr bridge0
$ <span>sudo</span> <span>ip</span> addr <span>add</span> <span>192.168</span>.5.1/24 dev bridge0
$ <span>sudo</span> <span>ip</span> <span>link</span> <span>set</span> dev bridge0 up
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>查看确认网桥创建并启动。</p>
<div><pre><code>$ <span>ip</span> addr show bridge0
<span>4</span>: bridge0: <span>&lt;</span>BROADCAST,MULTICAST<span>></span> mtu <span>1500</span> qdisc noop state UP group default
    link/ether <span>66</span>:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff
    inet <span>192.168</span>.5.1/24 scope global bridge0
       valid_lft forever preferred_lft forever
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容，即可将 Docker 默认桥接到创建的网桥上。</p>
<div><pre><code><span>{</span>
  <span>"bridge"</span><span>:</span> <span>"bridge0"</span><span>,</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>启动 Docker 服务。</p>
<p>新建一个容器，可以看到它已经桥接到了 <code>bridge0</code> 上。</p>
<p>可以继续用 <code>brctl show</code> 命令查看桥接的信息。另外，在容器中可以使用 <code>ip addr</code> 和 <code>ip route</code> 命令来查看 IP 地址配置和路由信息。</p>
]]></content:encoded>
    </item>
    <item>
      <title>编辑网络配置文件</title>
      <link>https://vuepress.mirror.docker-practice.com/advanced_network/config_file/</link>
      <guid>https://vuepress.mirror.docker-practice.com/advanced_network/config_file/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">编辑网络配置文件</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="编辑网络配置文件"> 编辑网络配置文件</h1>
<i>Content not supported</i>
<p>Docker 1.2.0 开始支持在运行中的容器里编辑 <code>/etc/hosts</code>, <code>/etc/hostname</code> 和 <code>/etc/resolv.conf</code> 文件。</p>
<p>但是这些修改是临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来，也不会被 <code>docker commit</code> 提交。</p>
]]></content:encoded>
    </item>
    <item>
      <title>配置 docker0 网桥</title>
      <link>https://vuepress.mirror.docker-practice.com/advanced_network/docker0/</link>
      <guid>https://vuepress.mirror.docker-practice.com/advanced_network/docker0/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">配置 docker0 网桥</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="配置-docker0-网桥"> 配置 docker0 网桥</h1>
<i>Content not supported</i>
<p>Docker 服务默认会创建一个 <code>docker0</code> 网桥（其上有一个 <code>docker0</code> 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p>
<p>Docker 默认指定了 <code>docker0</code> 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信，它还给出了 MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。</p>
<ul>
<li><code>--bip=CIDR</code> IP 地址加掩码格式，例如 192.168.1.5/24</li>
<li><code>--mtu=BYTES</code> 覆盖默认的 Docker mtu 配置</li>
</ul>
<p>也可以在配置文件中配置 DOCKER_OPTS，然后重启服务。</p>
<p>由于目前 Docker 网桥是 Linux 网桥，用户可以使用 <code>brctl show</code> 来查看网桥和端口连接信息。</p>
<div><pre><code>$ <span>sudo</span> brctl show
bridge name     bridge <span>id</span>               STP enabled     interfaces
docker0         <span>8000</span>.3a1d7362b4ee       no              veth65f9
                                             vethdda6
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>*注：<code>brctl</code> 命令在 Debian、Ubuntu 中可以使用 <code>sudo apt-get install bridge-utils</code> 来安装。</p>
<p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 <code>docker0</code> 接口的 IP 作为所有容器的默认网关。</p>
<div><pre><code>$ <span>sudo</span> <span>docker</span> run -i -t --rm base /bin/bash
$ <span>ip</span> addr show eth0
<span>24</span>: eth0: <span>&lt;</span>BROADCAST,UP,LOWER_UP<span>></span> mtu <span>1500</span> qdisc pfifo_fast state UP group default qlen <span>1000</span>
    link/ether <span>32</span>:6f:e0:35:57:91 brd ff:ff:ff:ff:ff:ff
    inet <span>172.17</span>.0.3/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::306f:e0ff:fe35:5791/64 scope <span>link</span>
       valid_lft forever preferred_lft forever
$ <span>ip</span> route
default via <span>172.17</span>.42.1 dev eth0
<span>172.17</span>.0.0/16 dev eth0  proto kernel  scope <span>link</span>  src <span>172.17</span>.0.3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>工具和示例</title>
      <link>https://vuepress.mirror.docker-practice.com/advanced_network/example/</link>
      <guid>https://vuepress.mirror.docker-practice.com/advanced_network/example/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">工具和示例</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="工具和示例"> 工具和示例</h1>
<i>Content not supported</i>
<p>在介绍自定义网络拓扑之前，你可能会对一些外部工具和例子感兴趣：</p>
<h2 id="pipework"> pipework</h2>
<p>Jérôme Petazzoni 编写了一个叫 <a href="https://github.com/jpetazzo/pipework" target="_blank" rel="noopener noreferrer">pipework<i>Content not supported</i></a> 的 shell 脚本，可以帮助用户在比较复杂的场景中完成容器的连接。</p>
<h2 id="playground"> playground</h2>
<p>Brandon Rhodes 创建了一个提供完整的 Docker 容器网络拓扑管理的 <a href="https://github.com/brandon-rhodes/fopnp/tree/m/playground" target="_blank" rel="noopener noreferrer">Python库<i>Content not supported</i></a>，包括路由、NAT 防火墙；以及一些提供 <code>HTTP</code> <code>SMTP</code> <code>POP</code> <code>IMAP</code> <code>Telnet</code> <code>SSH</code> <code>FTP</code> 的服务器。</p>
]]></content:encoded>
    </item>
    <item>
      <title>映射容器端口到宿主主机的实现</title>
      <link>https://vuepress.mirror.docker-practice.com/advanced_network/port_mapping/</link>
      <guid>https://vuepress.mirror.docker-practice.com/advanced_network/port_mapping/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">映射容器端口到宿主主机的实现</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="映射容器端口到宿主主机的实现"> 映射容器端口到宿主主机的实现</h1>
<i>Content not supported</i>
<p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p>
<h2 id="容器访问外部实现"> 容器访问外部实现</h2>
<p>容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 <code>iptables</code> 的源地址伪装操作实现的。</p>
<p>查看主机的 NAT 规则。</p>
<div><pre><code>$ <span>sudo</span> iptables -t nat -nL
<span>..</span>.
Chain POSTROUTING <span>(</span>policy ACCEPT<span>)</span>
target     prot opt <span>source</span>               destination
MASQUERADE  all  --  <span>172.17</span>.0.0/16       <span>!</span><span>172.17</span>.0.0/16
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>其中，上述规则将所有源地址在 <code>172.17.0.0/16</code> 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。</p>
<h2 id="外部访问容器实现"> 外部访问容器实现</h2>
<p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。</p>
<p>不管用那种办法，其实也是在本地的 <code>iptable</code> 的 nat 表中添加相应的规则。</p>
<p>使用 <code>-P</code> 时：</p>
<div><pre><code>$ iptables -t nat -nL
<span>..</span>.
Chain DOCKER <span>(</span><span>2</span> references<span>)</span>
target     prot opt <span>source</span>               destination
DNAT       tcp  --  <span>0.0</span>.0.0/0            <span>0.0</span>.0.0/0            tcp dpt:49153 to:172.17.0.2:80
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>使用 <code>-p 80:80</code> 时：</p>
<div><pre><code>$ iptables -t nat -nL
Chain DOCKER <span>(</span><span>2</span> references<span>)</span>
target     prot opt <span>source</span>               destination
DNAT       tcp  --  <span>0.0</span>.0.0/0            <span>0.0</span>.0.0/0            tcp dpt:80 to:172.17.0.2:80
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意：</p>
<ul>
<li>
<p>这里的规则映射了 <code>0.0.0.0</code>，意味着将接受主机来自所有接口的流量。用户可以通过 <code>-p IP:host_port:container_port</code> 或 <code>-p IP::port</code> 来指定允许访问容器的主机上的 IP、接口等，以制定更严格的规则。</p>
</li>
<li>
<p>如果希望永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容。</p>
</li>
</ul>
<div><pre><code><span>{</span>
  <span>"ip"</span><span>:</span> <span>"0.0.0.0"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>示例：创建一个点到点连接</title>
      <link>https://vuepress.mirror.docker-practice.com/advanced_network/ptp/</link>
      <guid>https://vuepress.mirror.docker-practice.com/advanced_network/ptp/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">示例：创建一个点到点连接</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="示例-创建一个点到点连接"> 示例：创建一个点到点连接</h1>
<p>默认情况下，Docker 会将所有容器连接到由 <code>docker0</code> 提供的虚拟子网中。
<i>Content not supported</i></p>
<p>用户有时候需要两个容器之间可以直连通信，而不用通过主机网桥进行桥接。</p>
<p>解决办法很简单：创建一对 <code>peer</code> 接口，分别放到两个容器中，配置成点到点链路类型即可。</p>
<p>首先启动 2 个容器：</p>
<div><pre><code>$ <span>docker</span> run -i -t --rm --net<span>=</span>none base /bin/bash
root@1f1f4c1f931a:/<span>#</span>
$ <span>docker</span> run -i -t --rm --net<span>=</span>none base /bin/bash
root@12e343489d2f:/<span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>找到进程号，然后创建网络命名空间的跟踪文件。</p>
<div><pre><code>$ <span>docker</span> inspect -f <span>'{{.State.Pid}}'</span> 1f1f4c1f931a
<span>2989</span>
$ <span>docker</span> inspect -f <span>'{{.State.Pid}}'</span> 12e343489d2f
<span>3004</span>
$ <span>sudo</span> <span>mkdir</span> -p /var/run/netns
$ <span>sudo</span> <span>ln</span> -s /proc/2989/ns/net /var/run/netns/2989
$ <span>sudo</span> <span>ln</span> -s /proc/3004/ns/net /var/run/netns/3004
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>创建一对 <code>peer</code> 接口，然后配置路由</p>
<div><pre><code>$ <span>sudo</span> <span>ip</span> <span>link</span> <span>add</span> A <span>type</span> veth peer name B

$ <span>sudo</span> <span>ip</span> <span>link</span> <span>set</span> A netns <span>2989</span>
$ <span>sudo</span> <span>ip</span> netns <span>exec</span> <span>2989</span> <span>ip</span> addr <span>add</span> <span>10.1</span>.1.1/32 dev A
$ <span>sudo</span> <span>ip</span> netns <span>exec</span> <span>2989</span> <span>ip</span> <span>link</span> <span>set</span> A up
$ <span>sudo</span> <span>ip</span> netns <span>exec</span> <span>2989</span> <span>ip</span> route <span>add</span> <span>10.1</span>.1.2/32 dev A

$ <span>sudo</span> <span>ip</span> <span>link</span> <span>set</span> B netns <span>3004</span>
$ <span>sudo</span> <span>ip</span> netns <span>exec</span> <span>3004</span> <span>ip</span> addr <span>add</span> <span>10.1</span>.1.2/32 dev B
$ <span>sudo</span> <span>ip</span> netns <span>exec</span> <span>3004</span> <span>ip</span> <span>link</span> <span>set</span> B up
$ <span>sudo</span> <span>ip</span> netns <span>exec</span> <span>3004</span> <span>ip</span> route <span>add</span> <span>10.1</span>.1.1/32 dev B
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>现在这 2 个容器就可以相互 ping 通，并成功建立连接。点到点链路不需要子网和子网掩码。</p>
<p>此外，也可以不指定 <code>--net=none</code> 来创建点到点链路。这样容器还可以通过原先的网络来通信。</p>
<p>利用类似的办法，可以创建一个只跟主机通信的容器。但是一般情况下，更推荐使用 <code>--icc=false</code> 来关闭容器之间的通信。</p>
]]></content:encoded>
    </item>
    <item>
      <title>快速配置指南</title>
      <link>https://vuepress.mirror.docker-practice.com/advanced_network/quick_guide/</link>
      <guid>https://vuepress.mirror.docker-practice.com/advanced_network/quick_guide/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">快速配置指南</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="快速配置指南"> 快速配置指南</h1>
<i>Content not supported</i>
<p>下面是一个跟 Docker 网络相关的命令列表。</p>
<p>其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。</p>
<ul>
<li><code>-b BRIDGE</code> 或 <code>--bridge=BRIDGE</code> 指定容器挂载的网桥</li>
<li><code>--bip=CIDR</code> 定制 docker0 的掩码</li>
<li><code>-H SOCKET...</code> 或 <code>--host=SOCKET...</code> Docker 服务端接收命令的通道</li>
<li><code>--icc=true|false</code> 是否支持容器之间进行通信</li>
<li><code>--ip-forward=true|false</code> 请看下文容器之间的通信</li>
<li><code>--iptables=true|false</code> 是否允许 Docker 添加 iptables 规则</li>
<li><code>--mtu=BYTES</code> 容器网络中的 MTU</li>
</ul>
<p>下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker 服务启动的时候指定则会成为默认值，后面执行 <code>docker run</code> 时可以覆盖设置的默认值。</p>
<ul>
<li><code>--dns=IP_ADDRESS...</code> 使用指定的DNS服务器</li>
<li><code>--dns-search=DOMAIN...</code> 指定DNS搜索域</li>
</ul>
<p>最后这些选项只有在 <code>docker run</code> 执行时使用，因为它是针对容器的特性内容。</p>
<ul>
<li><code>-h HOSTNAME</code> 或 <code>--hostname=HOSTNAME</code> 配置容器主机名</li>
<li><code>--link=CONTAINER_NAME:ALIAS</code> 添加到另一个容器的连接</li>
<li><code>--net=bridge|none|container:NAME_or_ID|host</code> 配置容器的桥接模式</li>
<li><code>-p SPEC</code> 或 <code>--publish=SPEC</code> 映射容器端口到宿主主机</li>
<li><code>-P or --publish-all=true|false</code> 映射容器所有端口到宿主主机</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>附录</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">附录</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="附录"> 附录</h1>
]]></content:encoded>
    </item>
    <item>
      <title>Dockerfile 最佳实践</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/best_practices/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/best_practices/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Dockerfile 最佳实践</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="dockerfile-最佳实践"> Dockerfile 最佳实践</h1>
<i>Content not supported</i>
<p>本附录是笔者对 Docker 官方文档中 <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener noreferrer">Best practices for writing Dockerfiles<i>Content not supported</i></a> 的理解与翻译。</p>
<h2 id="一般性的指南和建议"> 一般性的指南和建议</h2>
<h3 id="容器应该是短暂的"> 容器应该是短暂的</h3>
<p>通过 <code>Dockerfile</code> 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。</p>
<h3 id="使用-dockerignore-文件"> 使用 <code>.dockerignore</code> 文件</h3>
<p>使用 <code>Dockerfile</code> 构建镜像时最好是将 <code>Dockerfile</code> 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，你可以在目录下新建一个 <code>.dockerignore</code> 文件来指定要忽略的文件和目录。<code>.dockerignore</code> 文件的排除模式语法和 Git 的 <code>.gitignore</code> 文件相似。</p>
<h3 id="使用多阶段构建"> 使用多阶段构建</h3>
<p>在 <code>Docker 17.05</code> 以上版本中，你可以使用 <a href="./../image/multistage-builds.html">多阶段构建</a> 来减少所构建镜像的大小。</p>
<h3 id="避免安装不必要的包"> 避免安装不必要的包</h3>
<p>为了降低复杂性、减少依赖、减小文件大小、节约构建时间，你应该避免安装任何不必要的包。例如，不要在数据库镜像中包含一个文本编辑器。</p>
<h3 id="一个容器只运行一个进程"> 一个容器只运行一个进程</h3>
<p>应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web应用、数据库、缓存。</p>
<p>如果容器互相依赖，你可以使用 <a href="./../network/linking.html">Docker 自定义网络</a> 来把这些容器连接起来。</p>
<h3 id="镜像层数尽可能少"> 镜像层数尽可能少</h3>
<p>你需要在 <code>Dockerfile</code> 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。</p>
<h3 id="将多行参数排序"> 将多行参数排序</h3>
<p>将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助你避免重复包含同一个包，更新包列表时也更容易。也便于 <code>PRs</code> 阅读和审查。建议在反斜杠符号 <code>\</code> 之前添加一个空格，以增加可读性。</p>
<p>下面是来自 <code>buildpack-deps</code> 镜像的例子：</p>
<div><pre><code><span><span>RUN</span> apt-get update &amp;&amp; apt-get install -y <span>\</span>
  bzr <span>\</span>
  cvs <span>\</span>
  git <span>\</span>
  mercurial <span>\</span>
  subversion</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="构建缓存"> 构建缓存</h3>
<p>在镜像的构建过程中，Docker 会遍历 <code>Dockerfile</code> 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 <code>docker build</code> 命令中使用 <code>--no-cache=true</code> 选项。</p>
<p>但是，如果你想在构建的过程中使用缓存，你得明白什么时候会，什么时候不会找到匹配的镜像，遵循的基本规则如下：</p>
<ul>
<li>从一个基础镜像开始（<code>FROM</code> 指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。</li>
<li>在大多数情况下，只需要简单地对比 <code>Dockerfile</code> 中的指令和子镜像。然而，有些指令需要更多的检查和解释。</li>
<li>对于 <code>ADD</code> 和 <code>COPY</code> 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。</li>
<li>除了 <code>ADD</code> 和 <code>COPY</code> 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 <code>RUN apt-get -y update</code> 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。</li>
</ul>
<p>一旦缓存失效，所有后续的 <code>Dockerfile</code> 指令都将产生新的镜像，缓存不会被使用。</p>
<h2 id="dockerfile-指令"> Dockerfile 指令</h2>
<p>下面针对 <code>Dockerfile</code> 中各种指令的最佳编写方式给出建议。</p>
<h3 id="from"> FROM</h3>
<p>尽可能使用当前官方仓库作为你构建镜像的基础。推荐使用 <a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener noreferrer">Alpine<i>Content not supported</i></a> 镜像，因为它被严格控制并保持最小尺寸（目前小于 5 MB），但它仍然是一个完整的发行版。</p>
<h3 id="label"> LABEL</h3>
<p>你可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 <code>LABEL</code> 开头加上一个或多个标签对。下面的示例展示了各种不同的可能格式。<code>#</code> 开头的行是注释内容。</p>
<blockquote>
<p>注意：如果你的字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。</p>
</blockquote>
<div><pre><code><span># Set one or more individual labels</span>
<span><span>LABEL</span> com.example.version=<span>"0.0.1-beta"</span></span>

<span><span>LABEL</span> vendor=<span>"ACME Incorporated"</span></span>

<span><span>LABEL</span> com.example.release-date=<span>"2015-02-12"</span></span>

<span><span>LABEL</span> com.example.version.is-production=<span>""</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>一个镜像可以包含多个标签，但建议将多个标签放入到一个 <code>LABEL</code> 指令中。</p>
<div><pre><code><span># Set multiple labels at once, using line-continuation characters to break long lines</span>
<span><span>LABEL</span> vendor=ACME\ Incorporated <span>\</span>
      com.example.is-beta= <span>\</span>
      com.example.is-production=<span>""</span> <span>\</span>
      com.example.version=<span>"0.0.1-beta"</span> <span>\</span>
      com.example.release-date=<span>"2015-02-12"</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>关于标签可以接受的键值对，参考 <a href="https://docs.docker.com/config/labels-custom-metadata/" target="_blank" rel="noopener noreferrer">Understanding object labels<i>Content not supported</i></a>。关于查询标签信息，参考 <a href="https://docs.docker.com/config/labels-custom-metadata/" target="_blank" rel="noopener noreferrer">Managing labels on objects<i>Content not supported</i></a>。</p>
<h3 id="run"> RUN</h3>
<p>为了保持 <code>Dockerfile</code> 文件的可读性，可理解性，以及可维护性，建议将长的或复杂的 <code>RUN</code> 指令用反斜杠 <code>\</code> 分割成多行。</p>
<h4 id="apt-get"> apt-get</h4>
<p><code>RUN</code> 指令最常见的用法是安装包用的 <code>apt-get</code>。因为 <code>RUN apt-get</code> 指令会安装包，所以有几个问题需要注意。</p>
<p>不要使用 <code>RUN apt-get upgrade</code> 或 <code>dist-upgrade</code>，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级。如果基础镜像中的某个包过时了，你应该联系它的维护者。如果你确定某个特定的包，比如 <code>foo</code>，需要升级，使用 <code>apt-get install -y foo</code> 就行，该指令会自动升级 <code>foo</code> 包。</p>
<p>永远将 <code>RUN apt-get update</code> 和 <code>apt-get install</code> 组合成一条 <code>RUN</code> 声明，例如：</p>
<div><pre><code><span><span>RUN</span> apt-get update &amp;&amp; apt-get install -y <span>\</span>
        package-bar <span>\</span>
        package-baz <span>\</span>
        package-foo</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>将 <code>apt-get update</code> 放在一条单独的 <code>RUN</code> 声明中会导致缓存问题以及后续的 <code>apt-get install</code> 失败。比如，假设你有一个 <code>Dockerfile</code> 文件：</p>
<div><pre><code><span><span>FROM</span> ubuntu:18.04</span>

<span><span>RUN</span> apt-get update</span>

<span><span>RUN</span> apt-get install -y curl</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>构建镜像后，所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 <code>apt-get install</code> 添加了一个包：</p>
<div><pre><code><span><span>FROM</span> ubuntu:18.04</span>

<span><span>RUN</span> apt-get update</span>

<span><span>RUN</span> apt-get install -y curl nginx</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>Docker 发现修改后的 <code>RUN apt-get update</code> 指令和之前的完全一样。所以，<code>apt-get update</code> 不会执行，而是使用之前的缓存镜像。因为 <code>apt-get update</code> 没有运行，后面的 <code>apt-get install</code> 可能安装的是过时的 <code>curl</code> 和 <code>nginx</code> 版本。</p>
<p>使用 <code>RUN apt-get update &amp;&amp; apt-get install -y</code> 可以确保你的 Dockerfiles 每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作 <code>cache busting</code>。你也可以显示指定一个包的版本号来达到 <code>cache-busting</code>，这就是所谓的固定版本，例如：</p>
<div><pre><code><span><span>RUN</span> apt-get update &amp;&amp; apt-get install -y <span>\</span>
    package-bar <span>\</span>
    package-baz <span>\</span>
    package-foo=1.3.*</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。</p>
<p>下面是一个 <code>RUN</code> 指令的示例模板，展示了所有关于 <code>apt-get</code> 的建议。</p>
<div><pre><code><span><span>RUN</span> apt-get update &amp;&amp; apt-get install -y <span>\</span>
    aufs-tools <span>\</span>
    automake <span>\</span>
    build-essential <span>\</span>
    curl <span>\</span>
    dpkg-sig <span>\</span>
    libcap-dev <span>\</span>
    libsqlite3-dev <span>\</span>
    mercurial <span>\</span>
    reprepro <span>\</span>
    ruby1.9.1 <span>\</span>
    ruby1.9.1-dev <span>\</span>
    s3cmd=1.1.* <span>\</span>
 &amp;&amp; rm -rf /var/lib/apt/lists/*</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>其中 <code>s3cmd</code> 指令指定了一个版本号 <code>1.1.*</code>。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 <code>apt-get udpate</code> 缓存失效并确保安装的是新版本。</p>
<p>另外，清理掉 apt 缓存 <code>var/lib/apt/lists</code> 可以减小镜像大小。因为 <code>RUN</code> 指令的开头为 <code>apt-get udpate</code>，包缓存总是会在 <code>apt-get install</code> 之前刷新。</p>
<blockquote>
<p>注意：官方的 Debian 和 Ubuntu 镜像会自动运行 apt-get clean，所以不需要显式的调用 apt-get clean。</p>
</blockquote>
<h3 id="cmd"> CMD</h3>
<p><code>CMD</code> 指令用于执行目标镜像中包含的软件，可以包含参数。<code>CMD</code> 大多数情况下都应该以 <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;...]</code> 的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 <code>Apache</code>)，你可能会执行类似于 <code>CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;]</code> 形式的命令。我们建议任何服务镜像都使用这种形式的命令。</p>
<p>多数情况下，<code>CMD</code> 都需要一个交互式的 <code>shell</code> (bash, Python, perl 等)，例如 <code>CMD [&quot;perl&quot;, &quot;-de0&quot;]</code>，或者 <code>CMD [&quot;PHP&quot;, &quot;-a&quot;]</code>。使用这种形式意味着，当你执行类似 <code>docker run -it python</code> 时，你会进入一个准备好的 <code>shell</code> 中。<code>CMD</code> 应该在极少的情况下才能以 <code>CMD [&quot;param&quot;, &quot;param&quot;]</code> 的形式与 <code>ENTRYPOINT</code> 协同使用，除非你和你的镜像使用者都对 <code>ENTRYPOINT</code> 的工作方式十分熟悉。</p>
<h3 id="expose"> EXPOSE</h3>
<p><code>EXPOSE</code> 指令用于指定容器将要监听的端口。因此，你应该为你的应用程序使用常见的端口。例如，提供 <code>Apache</code> web 服务的镜像应该使用 <code>EXPOSE 80</code>，而提供 <code>MongoDB</code> 服务的镜像使用 <code>EXPOSE 27017</code>。</p>
<p>对于外部访问，用户可以在执行 <code>docker run</code> 时使用一个标志来指示如何将指定的端口映射到所选择的端口。</p>
<h3 id="env"> ENV</h3>
<p>为了方便新程序运行，你可以使用 <code>ENV</code> 来为容器中安装的程序更新 <code>PATH</code> 环境变量。例如使用 <code>ENV PATH /usr/local/nginx/bin:$PATH</code> 来确保 <code>CMD [&quot;nginx&quot;]</code> 能正确运行。</p>
<p><code>ENV</code> 指令也可用于为你想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 <code>PGDATA</code>。</p>
<p>最后，<code>ENV</code> 也能用于设置常见的版本号，比如下面的示例：</p>
<div><pre><code><span><span>ENV</span> PG_MAJOR 9.3</span>

<span><span>ENV</span> PG_VERSION 9.3.4</span>

<span><span>RUN</span> curl -SL http://example.com/postgres-<span>$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span>

<span><span>ENV</span> PATH /usr/local/postgres-<span>$PG_MAJOR</span>/bin:<span>$PATH</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>类似于程序中的常量，这种方法可以让你只需改变 <code>ENV</code> 指令来自动的改变容器中的软件版本。</p>
<h3 id="add-和-copy"> ADD 和 COPY</h3>
<p>虽然 <code>ADD</code> 和 <code>COPY</code> 功能类似，但一般优先使用 <code>COPY</code>。因为它比 <code>ADD</code> 更透明。<code>COPY</code> 只支持简单将本地文件拷贝到容器中，而 <code>ADD</code> 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，<code>ADD</code> 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 <code>ADD rootfs.tar.xz</code>。</p>
<p>如果你的 <code>Dockerfile</code> 有多个步骤需要使用上下文中不同的文件。单独 <code>COPY</code> 每个文件，而不是一次性的 <code>COPY</code> 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如：</p>
<div><pre><code><span><span>COPY</span> requirements.txt /tmp/</span>

<span><span>RUN</span> pip install --requirement /tmp/requirements.txt</span>

<span><span>COPY</span> . /tmp/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果将 <code>COPY . /tmp/</code> 放置在 <code>RUN</code> 指令之前，只要 <code>.</code> 目录中任何一个文件变化，都会导致后续指令的缓存失效。</p>
<p>为了让镜像尽量小，最好不要使用 <code>ADD</code> 指令从远程 URL 获取包，而是使用 <code>curl</code> 和 <code>wget</code>。这样你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法：</p>
<div><pre><code><span><span>ADD</span> http://example.com/big.tar.xz /usr/src/things/</span>

<span><span>RUN</span> tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span>

<span><span>RUN</span> make -C /usr/src/things all</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>而是应该使用下面这种方法：</p>
<div><pre><code><span><span>RUN</span> mkdir -p /usr/src/things <span>\</span>
    &amp;&amp; curl -SL http://example.com/big.tar.xz <span>\</span>
    | tar -xJC /usr/src/things <span>\</span>
    &amp;&amp; make -C /usr/src/things all</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面使用的管道操作，所以没有中间文件需要删除。</p>
<p>对于其他不需要 <code>ADD</code> 的自动提取功能的文件或目录，你应该使用 <code>COPY</code>。</p>
<h3 id="entrypoint"> ENTRYPOINT</h3>
<p><code>ENTRYPOINT</code> 的最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行（用 <code>CMD</code> 提供默认选项）。</p>
<p>例如，下面的示例镜像提供了命令行工具 <code>s3cmd</code>:</p>
<div><pre><code><span><span>ENTRYPOINT</span> [<span>"s3cmd"</span>]</span>

<span><span>CMD</span> [<span>"--help"</span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>现在直接运行该镜像创建的容器会显示命令帮助：</p>
<div><pre><code>$ <span>docker</span> run s3cmd
</code></pre>
<div><span>1</span><br></div></div><p>或者提供正确的参数来执行某个命令：</p>
<div><pre><code>$ <span>docker</span> run s3cmd <span>ls</span> s3://mybucket
</code></pre>
<div><span>1</span><br></div></div><p>这样镜像名可以当成命令行的参考。</p>
<p><code>ENTRYPOINT</code> 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。</p>
<p>例如，<code>Postgres</code> 官方镜像使用下面的脚本作为 <code>ENTRYPOINT</code>：</p>
<div><pre><code><span>#!/bin/bash</span>
<span>set</span> -e

<span>if</span> <span>[</span> <span>"<span>$1</span>"</span> <span>=</span> <span>'postgres'</span> <span>]</span><span>;</span> <span>then</span>
    <span>chown</span> -R postgres <span>"<span>$PGDATA</span>"</span>

    <span>if</span> <span>[</span> -z <span>"<span><span>$(</span><span>ls</span> -A <span>"<span>$PGDATA</span>"</span><span>)</span></span>"</span> <span>]</span><span>;</span> <span>then</span>
        gosu postgres initdb
    <span>fi</span>

    <span>exec</span> gosu postgres <span>"<span>$@</span>"</span>
<span>fi</span>

<span>exec</span> <span>"<span>$@</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><blockquote>
<p>注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。</p>
</blockquote>
<p>该辅助脚本被拷贝到容器，并在容器启动时通过 <code>ENTRYPOINT</code> 执行：</p>
<div><pre><code><span><span>COPY</span> ./docker-entrypoint.sh /</span>

<span><span>ENTRYPOINT</span> [<span>"/docker-entrypoint.sh"</span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>该脚本可以让用户用几种不同的方式和 <code>Postgres</code> 交互。</p>
<p>你可以很简单地启动 <code>Postgres</code>：</p>
<div><pre><code>$ <span>docker</span> run postgres
</code></pre>
<div><span>1</span><br></div></div><p>也可以执行 <code>Postgres</code> 并传递参数：</p>
<div><pre><code>$ <span>docker</span> run postgres postgres --help
</code></pre>
<div><span>1</span><br></div></div><p>最后，你还可以启动另外一个完全不同的工具，比如 <code>Bash</code>：</p>
<div><pre><code>$ <span>docker</span> run --rm -it postgres <span>bash</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="volume"> VOLUME</h3>
<p><code>VOLUME</code> 指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 <code>VOLUME</code> 来管理镜像中的可变部分和用户可以改变的部分。</p>
<h3 id="user"> USER</h3>
<p>如果某个服务不需要特权执行，建议使用 <code>USER</code> 指令切换到非 root 用户。先在 <code>Dockerfile</code> 中使用类似 <code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code> 的指令创建用户和用户组。</p>
<blockquote>
<p>注意：在镜像中，用户和用户组每次被分配的 UID/GID 都是不确定的，下次重新构建镜像时被分配到的 UID/GID 可能会不一样。如果要依赖确定的 UID/GID，你应该显式的指定一个 UID/GID。</p>
</blockquote>
<p>你应该避免使用 <code>sudo</code>，因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 <code>sudo</code> 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），你可以使用 <a href="https://github.com/tianon/gosu" target="_blank" rel="noopener noreferrer">gosu<i>Content not supported</i></a>。</p>
<p>最后，为了减少层数和复杂度，避免频繁地使用 <code>USER</code> 来回切换用户。</p>
<h3 id="workdir"> WORKDIR</h3>
<p>为了清晰性和可靠性，你应该总是在 <code>WORKDIR</code> 中使用绝对路径。另外，你应该使用 <code>WORKDIR</code> 来替代类似于 <code>RUN cd ... &amp;&amp; do-something</code> 的指令，后者难以阅读、排错和维护。</p>
<h2 id="官方镜像示例"> 官方镜像示例</h2>
<p>这些官方镜像的 Dockerfile 都是参考典范：https://github.com/docker-library/docs</p>
]]></content:encoded>
    </item>
    <item>
      <title>Docker 命令查询</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/command/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/command/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Docker 命令查询</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="docker-命令查询"> Docker 命令查询</h1>
<i>Content not supported</i>
<h2 id="基本语法"> 基本语法</h2>
<p>Docker 命令有两大类，客户端命令和服务端命令。前者是主要的操作接口，后者用来启动 Docker Daemon。</p>
<ul>
<li>
<p>客户端命令：基本命令格式为 <code>docker [OPTIONS] COMMAND [arg...]</code>；</p>
</li>
<li>
<p>服务端命令：基本命令格式为 <code>dockerd [OPTIONS]</code>。</p>
</li>
</ul>
<p>可以通过 <code>man docker</code> 或 <code>docker help</code> 来查看这些命令。</p>
<p>接下来的小节对这两个命令进行介绍。</p>
]]></content:encoded>
    </item>
    <item>
      <title>客户端命令(docker)</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/command/docker/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/command/docker/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">客户端命令(docker)</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="客户端命令-docker"> 客户端命令(docker)</h1>
<i>Content not supported</i>
<h2 id="客户端命令选项"> 客户端命令选项</h2>
<ul>
<li><code>--config=&quot;&quot;</code>：指定客户端配置文件，默认为 <code>~/.docker</code>；</li>
<li><code>-D=true|false</code>：是否使用 debug 模式。默认不开启；</li>
<li><code>-H, --host=[]</code>：指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字 <code>unix:///path/to/socket</code>，文件句柄 <code>fd://socketfd</code> 或 tcp 套接字 <code>tcp://[host[:port]]</code>，默认为 <code>unix:///var/run/docker.sock</code>；</li>
<li><code>-l, --log-level=&quot;debug|info|warn|error|fatal&quot;</code>：指定日志输出级别；</li>
<li><code>--tls=true|false</code>：是否对 Docker 守护进程启用 TLS 安全机制，默认为否；</li>
<li><code>--tlscacert=/.docker/ca.pem</code>：TLS CA 签名的可信证书文件路径；</li>
<li><code>--tlscert=/.docker/cert.pem</code>：TLS 可信证书文件路径；</li>
<li><code>--tlscert=/.docker/key.pem</code>：TLS 密钥文件路径；</li>
<li><code>--tlsverify=true|false</code>：启用 TLS 校验，默认为否。</li>
</ul>
<h2 id="客户端命令"> 客户端命令</h2>
<p>可以通过 <code>docker COMMAND --help</code> 来查看这些命令的具体用法。</p>
<ul>
<li><code>attach</code>：依附到一个正在运行的容器中；</li>
<li><code>build</code>：从一个 Dockerfile 创建一个镜像；</li>
<li><code>commit</code>：从一个容器的修改中创建一个新的镜像；</li>
<li><code>cp</code>：在容器和本地宿主系统之间复制文件中；</li>
<li><code>create</code>：创建一个新容器，但并不运行它；</li>
<li><code>diff</code>：检查一个容器内文件系统的修改，包括修改和增加；</li>
<li><code>events</code>：从服务端获取实时的事件；</li>
<li><code>exec</code>：在运行的容器内执行命令；</li>
<li><code>export</code>：导出容器内容为一个 <code>tar</code> 包；</li>
<li><code>history</code>：显示一个镜像的历史信息；</li>
<li><code>images</code>：列出存在的镜像；</li>
<li><code>import</code>：导入一个文件（典型为 <code>tar</code> 包）路径或目录来创建一个本地镜像；</li>
<li><code>info</code>：显示一些相关的系统信息；</li>
<li><code>inspect</code>：显示一个容器的具体配置信息；</li>
<li><code>kill</code>：关闭一个运行中的容器 (包括进程和所有相关资源)；</li>
<li><code>load</code>：从一个 tar 包中加载一个镜像；</li>
<li><code>login</code>：注册或登录到一个 Docker 的仓库服务器；</li>
<li><code>logout</code>：从 Docker 的仓库服务器登出；</li>
<li><code>logs</code>：获取容器的 log 信息；</li>
<li><code>network</code>：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；</li>
<li><code>node</code>：管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；</li>
<li><code>pause</code>：暂停一个容器中的所有进程；</li>
<li><code>port</code>：查找一个 nat 到一个私有网口的公共口；</li>
<li><code>ps</code>：列出主机上的容器；</li>
<li><code>pull</code>：从一个Docker的仓库服务器下拉一个镜像或仓库；</li>
<li><code>push</code>：将一个镜像或者仓库推送到一个 Docker 的注册服务器；</li>
<li><code>rename</code>：重命名一个容器；</li>
<li><code>restart</code>：重启一个运行中的容器；</li>
<li><code>rm</code>：删除给定的若干个容器；</li>
<li><code>rmi</code>：删除给定的若干个镜像；</li>
<li><code>run</code>：创建一个新容器，并在其中运行给定命令；</li>
<li><code>save</code>：保存一个镜像为 tar 包文件；</li>
<li><code>search</code>：在 Docker index 中搜索一个镜像；</li>
<li><code>service</code>：管理 Docker 所启动的应用服务，包括创建、更新、删除等；</li>
<li><code>start</code>：启动一个容器；</li>
<li><code>stats</code>：输出（一个或多个）容器的资源使用统计信息；</li>
<li><code>stop</code>：终止一个运行中的容器；</li>
<li><code>swarm</code>：管理 Docker swarm 集群，包括创建、加入、退出、更新等；</li>
<li><code>tag</code>：为一个镜像打标签；</li>
<li><code>top</code>：查看一个容器中的正在运行的进程信息；</li>
<li><code>unpause</code>：将一个容器内所有的进程从暂停状态中恢复；</li>
<li><code>update</code>：更新指定的若干容器的配置信息；</li>
<li><code>version</code>：输出 Docker 的版本信息；</li>
<li><code>volume</code>：管理 Docker volume，包括查看、创建、删除等；</li>
<li><code>wait</code>：阻塞直到一个容器终止，然后输出它的退出符。</li>
</ul>
<h2 id="一张图总结-docker-的命令"> 一张图总结 Docker 的命令</h2>
<p><img src="./../_images/cmd_logic.png" alt="Docker 命令总结"></p>
<h2 id="参考"> 参考</h2>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/cli/" target="_blank" rel="noopener noreferrer">官方文档<i>Content not supported</i></a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>服务端命令(dockerd)</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/command/dockerd/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/command/dockerd/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">服务端命令(dockerd)</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="服务端命令-dockerd"> 服务端命令(dockerd)</h1>
<i>Content not supported</i>
<h2 id="dockerd-命令选项"> dockerd 命令选项</h2>
<ul>
<li><code>--api-cors-header=&quot;&quot;</code>：CORS 头部域，默认不允许 CORS，要允许任意的跨域访问，可以指定为 &quot;*&quot;；</li>
<li><code>--authorization-plugin=&quot;&quot;</code>：载入认证的插件；</li>
<li><code>-b=&quot;&quot;</code>：将容器挂载到一个已存在的网桥上。指定为 <code>none</code> 时则禁用容器的网络，与 <code>--bip</code> 选项互斥；</li>
<li><code>--bip=&quot;&quot;</code>：让动态创建的 <code>docker0</code> 网桥采用给定的 CIDR 地址; 与 <code>-b</code> 选项互斥；</li>
<li><code>--cgroup-parent=&quot;&quot;</code>：指定 cgroup 的父组，默认 fs cgroup 驱动为 <code>/docker</code>，systemd cgroup 驱动为 <code>system.slice</code>；</li>
<li><code>--cluster-store=&quot;&quot;</code>：构成集群（如 <code>Swarm</code>）时，集群键值数据库服务地址；</li>
<li><code>--cluster-advertise=&quot;&quot;</code>：构成集群时，自身的被访问地址，可以为 <code>host:port</code> 或 <code>interface:port</code>；</li>
<li><code>--cluster-store-opt=&quot;&quot;</code>：构成集群时，键值数据库的配置选项；</li>
<li><code>--config-file=&quot;/etc/docker/daemon.json&quot;</code>：daemon 配置文件路径；</li>
<li><code>--containerd=&quot;&quot;</code>：containerd 文件的路径；</li>
<li><code>-D, --debug=true|false</code>：是否使用 Debug 模式。缺省为 false；</li>
<li><code>--default-gateway=&quot;&quot;</code>：容器的 IPv4 网关地址，必须在网桥的子网段内；</li>
<li><code>--default-gateway-v6=&quot;&quot;</code>：容器的 IPv6 网关地址；</li>
<li><code>--default-ulimit=[]</code>：默认的 ulimit 值；</li>
<li><code>--disable-legacy-registry=true|false</code>：是否允许访问旧版本的镜像仓库服务器；</li>
<li><code>--dns=&quot;&quot;</code>：指定容器使用的 DNS 服务器地址；</li>
<li><code>--dns-opt=&quot;&quot;</code>：DNS 选项；</li>
<li><code>--dns-search=[]</code>：DNS 搜索域；</li>
<li><code>--exec-opt=[]</code>：运行时的执行选项；</li>
<li><code>--exec-root=&quot;&quot;</code>：容器执行状态文件的根路径，默认为 <code>/var/run/docker</code>；</li>
<li><code>--fixed-cidr=&quot;&quot;</code>：限定分配 IPv4 地址范围；</li>
<li><code>--fixed-cidr-v6=&quot;&quot;</code>：限定分配 IPv6 地址范围；</li>
<li><code>-G, --group=&quot;&quot;</code>：分配给 unix 套接字的组，默认为 <code>docker</code>；</li>
<li><code>-g, --graph=&quot;&quot;</code>：Docker 运行时的根路径，默认为 <code>/var/lib/docker</code>；</li>
<li><code>-H, --host=[]</code>：指定命令对应 Docker daemon 的监听接口，可以为 unix 套接字 <code>unix:///path/to/socket</code>，文件句柄 <code>fd://socketfd</code> 或 tcp 套接字 <code>tcp://[host[:port]]</code>，默认为 <code>unix:///var/run/docker.sock</code>；</li>
<li><code>--icc=true|false</code>：是否启用容器间以及跟 daemon 所在主机的通信。默认为 true。</li>
<li><code>--insecure-registry=[]</code>：允许访问给定的非安全仓库服务；</li>
<li><code>--ip=&quot;&quot;</code>：绑定容器端口时候的默认 IP 地址。缺省为 <code>0.0.0.0</code>；</li>
<li><code>--ip-forward=true|false</code>：是否检查启动在 Docker 主机上的启用 IP 转发服务，默认开启。注意关闭该选项将不对系统转发能力进行任何检查修改；</li>
<li><code>--ip-masq=true|false</code>：是否进行地址伪装，用于容器访问外部网络，默认开启；</li>
<li><code>--iptables=true|false</code>：是否允许 Docker 添加 iptables 规则。缺省为 true；</li>
<li><code>--ipv6=true|false</code>：是否启用 IPv6 支持，默认关闭；</li>
<li><code>-l, --log-level=&quot;debug|info|warn|error|fatal&quot;</code>：指定日志输出级别；</li>
<li><code>--label=&quot;[]&quot;</code>：添加指定的键值对标注；</li>
<li><code>--log-driver=&quot;json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none&quot;</code>：指定日志后端驱动，默认为 <code>json-file</code>；</li>
<li><code>--log-opt=[]</code>：日志后端的选项；</li>
<li><code>--mtu=VALUE</code>：指定容器网络的 <code>mtu</code>；</li>
<li><code>-p=&quot;&quot;</code>：指定 daemon 的 PID 文件路径。缺省为 <code>/var/run/docker.pid</code>；</li>
<li><code>--raw-logs</code>：输出原始，未加色彩的日志信息；</li>
<li><code>--registry-mirror=&lt;scheme&gt;://&lt;host&gt;</code>：指定 <code>docker pull</code> 时使用的注册服务器镜像地址；</li>
<li><code>-s, --storage-driver=&quot;&quot;</code>：指定使用给定的存储后端；</li>
<li><code>--selinux-enabled=true|false</code>：是否启用 SELinux 支持。缺省值为 false。SELinux 目前尚不支持 overlay 存储驱动；</li>
<li><code>--storage-opt=[]</code>：驱动后端选项；</li>
<li><code>--tls=true|false</code>：是否对 Docker daemon 启用 TLS 安全机制，默认为否；</li>
<li><code>--tlscacert=/.docker/ca.pem</code>：TLS CA 签名的可信证书文件路径；</li>
<li><code>--tlscert=/.docker/cert.pem</code>：TLS 可信证书文件路径；</li>
<li><code>--tlscert=/.docker/key.pem</code>：TLS 密钥文件路径；</li>
<li><code>--tlsverify=true|false</code>：启用 TLS 校验，默认为否；</li>
<li><code>--userland-proxy=true|false</code>：是否使用用户态代理来实现容器间和出容器的回环通信，默认为 true；</li>
<li><code>--userns-remap=default|uid:gid|user:group|user|uid</code>：指定容器的用户命名空间，默认是创建新的 UID 和 GID 映射到容器内进程。</li>
</ul>
<h2 id="参考"> 参考</h2>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/dockerd/" target="_blank" rel="noopener noreferrer">官方文档<i>Content not supported</i></a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>如何调试 Docker</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/debug/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/debug/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">如何调试 Docker</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="如何调试-docker"> 如何调试 Docker</h1>
<i>Content not supported</i>
<h2 id="开启-debug-模式"> 开启 Debug 模式</h2>
<p>在 dockerd 配置文件 daemon.json（默认位于 /etc/docker/）中添加</p>
<div><pre><code><span>{</span>
  <span>"debug"</span><span>:</span> <span>true</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>重启守护进程。</p>
<div><pre><code>$ <span>sudo</span> <span>kill</span> -SIGHUP <span><span>$(</span>pidof dockerd<span>)</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>此时 dockerd 会在日志中输入更多信息供分析。</p>
<h2 id="检查内核日志"> 检查内核日志</h2>
<div><pre><code>$ <span>sudo</span> <span>dmesg</span> <span>|</span><span>grep</span> dockerd
$ <span>sudo</span> <span>dmesg</span> <span>|</span><span>grep</span> runc
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="docker-不响应时处理"> Docker 不响应时处理</h2>
<p>可以杀死 dockerd 进程查看其堆栈调用情况。</p>
<div><pre><code>$ <span>sudo</span> <span>kill</span> -SIGUSR1 <span><span>$(</span>pidof dockerd<span>)</span></span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="重置-docker-本地数据"> 重置 Docker 本地数据</h2>
<p><em>注意，本操作会移除所有的 Docker 本地数据，包括镜像和容器等。</em></p>
<div><pre><code>$ <span>sudo</span> <span>rm</span> -rf /var/lib/docker
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>常见问题总结</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/faq/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/faq/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">常见问题总结</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="常见问题总结"> 常见问题总结</h1>
<i>Content not supported</i>
<h2 id="镜像相关"> 镜像相关</h2>
<h3 id="如何批量清理临时镜像文件"> 如何批量清理临时镜像文件？</h3>
<p>答：可以使用 <code>docker image prune</code> 命令。</p>
<h3 id="如何查看镜像支持的环境变量"> 如何查看镜像支持的环境变量？</h3>
<p>答：可以使用 <code>docker run IMAGE env</code> 命令。</p>
<h3 id="本地的镜像文件都存放在哪里"> 本地的镜像文件都存放在哪里？</h3>
<p>答：与 Docker 相关的本地资源默认存放在 <code>/var/lib/docker/</code> 目录下，以 <code>overlay2</code> 文件系统为例，其中 <code>containers</code> 目录存放容器信息，<code>image</code> 目录存放镜像信息，<code>overlay2</code> 目录下存放具体的镜像层文件。</p>
<h3 id="构建-docker-镜像应该遵循哪些原则"> 构建 Docker 镜像应该遵循哪些原则？</h3>
<p>答：整体原则上，尽量保持镜像功能的明确和内容的精简，要点包括</p>
<ul>
<li>
<p>尽量选取满足需求但较小的基础系统镜像，例如大部分时候可以选择 <code>alpine</code> 镜像，仅有不足六兆大小；</p>
</li>
<li>
<p>清理编译生成文件、安装包的缓存等临时文件；</p>
</li>
<li>
<p>安装各个软件时候要指定准确的版本号，并避免引入不需要的依赖；</p>
</li>
<li>
<p>从安全角度考虑，应用要尽量使用系统的库和依赖；</p>
</li>
<li>
<p>如果安装应用时候需要配置一些特殊的环境变量，在安装后要还原不需要保持的变量值；</p>
</li>
<li>
<p>使用 Dockerfile 创建镜像时候要添加 .dockerignore 文件或使用干净的工作目录。</p>
</li>
</ul>
<p>更多内容请查看 <a href="./../best_practices.html">Dockerfile 最佳实践</a></p>
<h3 id="碰到网络问题-无法-pull-镜像-命令行指定-http-proxy-无效"> 碰到网络问题，无法 pull 镜像，命令行指定 http_proxy 无效？</h3>
<p>答：在 Docker 配置文件中添加 <code>export http_proxy=&quot;http://&lt;PROXY_HOST&gt;:&lt;PROXY_PORT&gt;&quot;</code>，之后重启 Docker 服务即可。</p>
<h2 id="容器相关"> 容器相关</h2>
<h3 id="容器退出后-通过-docker-container-ls-命令查看不到-数据会丢失么"> 容器退出后，通过 docker container ls 命令查看不到，数据会丢失么？</h3>
<p>答：容器退出后会处于终止（exited）状态，此时可以通过 <code>docker container ls -a</code> 查看。其中的数据也不会丢失，还可以通过 <code>docker start</code> 命令来启动它。只有删除掉容器才会清除所有数据。</p>
<h3 id="如何停止所有正在运行的容器"> 如何停止所有正在运行的容器？</h3>
<p>答：可以使用 <code>docker stop $(docker container ls -q)</code> 命令。</p>
<h3 id="如何批量清理已经停止的容器"> 如何批量清理已经停止的容器？</h3>
<p>答：可以使用 <code>docker container prune</code> 命令。</p>
<h3 id="如何获取某个容器的-pid-信息"> 如何获取某个容器的 PID 信息？</h3>
<p>答：可以使用</p>
<div><pre><code><span>docker</span> inspect --format <span>'{{ .State.Pid }}'</span> <span>&lt;</span>CONTAINER ID or NAME<span>></span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="如何获取某个容器的-ip-地址"> 如何获取某个容器的 IP 地址？</h3>
<p>答：可以使用</p>
<div><pre><code><span>docker</span> inspect --format <span>'{{ .NetworkSettings.IPAddress }}'</span> <span>&lt;</span>CONTAINER ID or NAME<span>></span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="如何给容器指定一个固定-ip-地址-而不是每次重启容器-ip-地址都会变"> 如何给容器指定一个固定 IP 地址，而不是每次重启容器 IP 地址都会变？</h3>
<p>答：使用以下命令启动容器可以使容器 IP 固定不变</p>
<div><pre><code>$ <span>docker</span> network create -d bridge --subnet <span>172.25</span>.0.0/16 my-net

$ <span>docker</span> run --network<span>=</span>my-net --ip<span>=</span><span>172.25</span>.3.3 -itd --name<span>=</span>my-container busybox
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="如何临时退出一个正在交互的容器的终端-而不终止它"> 如何临时退出一个正在交互的容器的终端，而不终止它？</h3>
<p>答：按 <code>Ctrl-p Ctrl-q</code>。如果按 <code>Ctrl-c</code> 往往会让容器内应用进程终止，进而会终止容器。</p>
<h3 id="使用-docker-port-命令映射容器的端口时-系统报错-error-no-public-port-80-published-for-xxx"> 使用 <code>docker port</code> 命令映射容器的端口时，系统报错“Error: No public port '80' published for xxx”？</h3>
<p>答：</p>
<ul>
<li>
<p>创建镜像时 <code>Dockerfile</code> 要通过 <code>EXPOSE</code> 指定正确的开放端口；</p>
</li>
<li>
<p>容器启动时指定 <code>PublishAllPort = true</code>。</p>
</li>
</ul>
<h3 id="可以在一个容器中同时运行多个应用进程么"> 可以在一个容器中同时运行多个应用进程么？</h3>
<p>答：一般并不推荐在同一个容器内运行多个应用进程。如果有类似需求，可以通过一些额外的进程管理机制，比如 <code>supervisord</code> 来管理所运行的进程。可以参考 https://docs.docker.com/config/containers/multi-service_container/ 。</p>
<h3 id="如何控制容器占用系统资源-cpu、内存-的份额"> 如何控制容器占用系统资源（CPU、内存）的份额？</h3>
<p>答：在使用 <code>docker create</code> 命令创建容器或使用 <code>docker run</code> 创建并启动容器的时候，可以使用 -c|--cpu-shares[=0] 参数来调整容器使用 CPU 的权重；使用 -m|--memory[=MEMORY] 参数来调整容器使用内存的大小。</p>
<h2 id="仓库相关"> 仓库相关</h2>
<h3 id="仓库-repository-、注册服务器-registry-、注册索引-index-有何关系"> 仓库（Repository）、注册服务器（Registry）、注册索引（Index） 有何关系？</h3>
<p>首先，仓库是存放一组关联镜像的集合，比如同一个应用的不同版本的镜像。</p>
<p>注册服务器是存放实际的镜像文件的地方。注册索引则负责维护用户的账号、权限、搜索、标签等的管理。因此，注册服务器利用注册索引来实现认证等管理。</p>
<h2 id="配置相关"> 配置相关</h2>
<h3 id="docker-的配置文件放在哪里-如何修改配置"> Docker 的配置文件放在哪里，如何修改配置？</h3>
<p>答：使用 <code>systemd</code> 的系统（如 Ubuntu 16.04、Centos 等）的配置文件在 <code>/etc/docker/daemon.json</code>。</p>
<h3 id="如何更改-docker-的默认存储位置"> 如何更改 Docker 的默认存储位置？</h3>
<p>答：Docker 的默认存储位置是 <code>/var/lib/docker</code>，如果希望将 Docker 的本地文件存储到其他分区，可以使用 Linux 软连接的方式来完成，或者在启动 daemon 时通过 <code>-g</code> 参数指定，或者修改配置文件 <code>/etc/docker/daemon.json</code> 的 &quot;data-root&quot; 项 。可以使用 <code>docker system info | grep &quot;Root Dir&quot;</code> 查看当前使用的存储位置。</p>
<p>例如，如下操作将默认存储位置迁移到 /storage/docker。</p>
<div><pre><code><span>[</span>root@s26 ~<span>]</span><span># df -h</span>
Filesystem                    Size  Used Avail Use% Mounted on
/dev/mapper/VolGroup-lv_root   50G  <span>5</span>.3G   42G  <span>12</span>% /
tmpfs                          48G  228K   48G   <span>1</span>% /dev/shm
/dev/sda1                     485M   40M  420M   <span>9</span>% /boot
/dev/mapper/VolGroup-lv_home  222G  188M  210G   <span>1</span>% /home
/dev/sdb2                     <span>2</span>.7T  323G  <span>2</span>.3T  <span>13</span>% /storage
<span>[</span>root@s26 ~<span>]</span><span># service docker stop</span>
<span>[</span>root@s26 ~<span>]</span><span># cd /var/lib/</span>
<span>[</span>root@s26 lib<span>]</span><span># mv docker /storage/</span>
<span>[</span>root@s26 lib<span>]</span><span># ln -s /storage/docker/ docker</span>
<span>[</span>root@s26 lib<span>]</span><span># ls -la docker</span>
lrwxrwxrwx. <span>1</span> root root <span>15</span> <span>11</span>月 <span>17</span> <span>13</span>:43 <span>docker</span> -<span>></span> /storage/docker
<span>[</span>root@s26 lib<span>]</span><span># service docker start</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="使用内存和-swap-限制启动容器时候报警告-warning-your-kernel-does-not-support-cgroup-swap-limit-warning-your-kernel-does-not-support-swap-limit-capabilities-limitation-discarded"> 使用内存和 swap 限制启动容器时候报警告：&quot;WARNING: Your kernel does not support cgroup swap limit. WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.&quot;？</h3>
<p>答：这是因为系统默认没有开启对内存和 swap 使用的统计功能，引入该功能会带来性能的下降。要开启该功能，可以采取如下操作：</p>
<ul>
<li>
<p>编辑 <code>/etc/default/grub</code> 文件（Ubuntu 系统为例），配置 <code>GRUB_CMDLINE_LINUX=&quot;cgroup_enable=memory swapaccount=1&quot;</code></p>
</li>
<li>
<p>更新 grub：<code>$ sudo update-grub</code></p>
</li>
<li>
<p>重启系统，即可。</p>
</li>
</ul>
<h2 id="docker-与虚拟化"> Docker 与虚拟化</h2>
<h3 id="docker-与-lxc-linux-container-有何不同"> Docker 与 LXC（Linux Container）有何不同？</h3>
<p>答：LXC 利用 Linux 上相关技术实现了容器。Docker 则在如下的几个方面进行了改进：</p>
<ul>
<li>移植性：通过抽象容器配置，容器可以实现从一个平台移植到另一个平台；</li>
<li>镜像系统：基于 OverlayFS 的镜像系统为容器的分发带来了很多的便利，同时共同的镜像层只需要存储一份，实现高效率的存储；</li>
<li>版本管理：类似于Git的版本管理理念，用户可以更方便的创建、管理镜像文件；</li>
<li>仓库系统：仓库系统大大降低了镜像的分发和管理的成本；</li>
<li>周边工具：各种现有工具（配置管理、云平台）对 Docker 的支持，以及基于 Docker的 PaaS、CI 等系统，让 Docker 的应用更加方便和多样化。</li>
</ul>
<h3 id="docker-与-vagrant-有何不同"> Docker 与 Vagrant 有何不同？</h3>
<p>答：两者的定位完全不同。</p>
<ul>
<li>
<p>Vagrant 类似 Boot2Docker（一款运行 Docker 的最小内核），是一套虚拟机的管理环境。Vagrant 可以在多种系统上和虚拟机软件中运行，可以在 Windows，Mac 等非 Linux 平台上为 Docker 提供支持，自身具有较好的包装性和移植性。</p>
</li>
<li>
<p>原生的 Docker 自身只能运行在 Linux 平台上，但启动和运行的性能都比虚拟机要快，往往更适合快速开发和部署应用的场景。</p>
</li>
</ul>
<p>简单说：Vagrant 适合用来管理虚拟机，而 Docker 适合用来管理应用环境。</p>
<h3 id="开发环境中-docker-和-vagrant-该如何选择"> 开发环境中 Docker 和 Vagrant 该如何选择？</h3>
<p>答：Docker 不是虚拟机，而是进程隔离，对于资源的消耗很少，但是目前需要 Linux 环境支持。Vagrant 是虚拟机上做的封装，虚拟机本身会消耗资源。</p>
<p>如果本地使用的 Linux 环境，推荐都使用 Docker。</p>
<p>如果本地使用的是 macOS 或者 Windows 环境，那就需要开虚拟机，单一开发环境下 Vagrant 更简单；多环境开发下推荐在 Vagrant 里面再使用 Docker 进行环境隔离。</p>
<h2 id="其它"> 其它</h2>
<h3 id="docker-能在非-linux-平台-比如-windows-或-macos-上运行么"> Docker 能在非 Linux 平台（比如 Windows 或 macOS ）上运行么？</h3>
<p>答：完全可以。安装方法请查看 <a href="./../../install/">安装 Docker</a> 一节</p>
<h3 id="如何将一台宿主主机的-docker-环境迁移到另外一台宿主主机"> 如何将一台宿主主机的 Docker 环境迁移到另外一台宿主主机？</h3>
<p>答：停止 Docker 服务。将整个 Docker 存储文件夹复制到另外一台宿主主机，然后调整另外一台宿主主机的配置即可。</p>
<h3 id="如何进入-docker-容器的网络命名空间"> 如何进入 Docker 容器的网络命名空间？</h3>
<p>答：Docker 在创建容器后，删除了宿主主机上 <code>/var/run/netns</code> 目录中的相关的网络命名空间文件。因此，在宿主主机上是无法看到或访问容器的网络命名空间的。</p>
<p>用户可以通过如下方法来手动恢复它。</p>
<p>首先，使用下面的命令查看容器进程信息，比如这里的 1234。</p>
<div><pre><code>$ <span>docker</span> inspect --format<span>=</span><span>'{{. State.Pid}} '</span> <span>$container_id</span>
<span>1234</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>接下来，在 <code>/proc</code> 目录下，把对应的网络命名空间文件链接到 <code>/var/run/netns</code> 目录。</p>
<div><pre><code>$ <span>sudo</span> <span>ln</span> -s /proc/1234/ns/net /var/run/netns/
</code></pre>
<div><span>1</span><br></div></div><p>然后，在宿主主机上就可以看到容器的网络命名空间信息。例如</p>
<div><pre><code>$ <span>sudo</span> <span>ip</span> netns show
<span>1234</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>此时，用户可以通过正常的系统命令来查看或操作容器的命名空间了。例如修改容器的 IP 地址信息为 <code>172.17.0.100/16</code>。</p>
<div><pre><code>$ <span>sudo</span> <span>ip</span> netns <span>exec</span> <span>1234</span> <span>ifconfig</span> eth0 <span>172.17</span>.0.100/16
</code></pre>
<div><span>1</span><br></div></div><h3 id="如何获取容器绑定到本地那个-veth-接口上"> 如何获取容器绑定到本地那个 veth 接口上？</h3>
<p>答：Docker 容器启动后，会通过 veth 接口对连接到本地网桥，veth 接口命名跟容器命名毫无关系，十分难以找到对应关系。</p>
<p>最简单的一种方式是通过查看接口的索引号，在容器中执行 <code>ip a</code> 命令，查看到本地接口最前面的接口索引号，如 <code>205</code>，将此值加上 1，即 <code>206</code>，然后在本地主机执行 <code>ip a</code> 命令，查找接口索引号为 <code>206</code> 的接口，两者即为连接的 veth 接口对。</p>
]]></content:encoded>
    </item>
    <item>
      <title>热门镜像介绍</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/repo/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/repo/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">热门镜像介绍</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="热门镜像介绍"> 热门镜像介绍</h1>
<i>Content not supported</i>
<p>本章将介绍一些热门镜像的功能，使用方法等。包括 Ubuntu、CentOS、MySQL、MongoDB、Redis、Nginx、Wordpress、Node.js 等。</p>
]]></content:encoded>
    </item>
    <item>
      <title>CentOS</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/repo/centos/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/repo/centos/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">CentOS</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="centos"> <a href="https://hub.docker.com/_/centos" target="_blank" rel="noopener noreferrer">CentOS<i>Content not supported</i></a></h1>
<i>Content not supported</i>
<h2 id="基本信息"> 基本信息</h2>
<p><a href="https://en.wikipedia.org/wiki/CentOS" target="_blank" rel="noopener noreferrer">CentOS<i>Content not supported</i></a> 是流行的 Linux 发行版，其软件包大多跟 RedHat 系列保持一致。</p>
<p>该仓库位于 <code>https://hub.docker.com/_/centos</code> ，提供了 CentOS 从 5 ~ 8 各个版本的镜像。</p>
<h2 id="使用方法"> 使用方法</h2>
<p>默认会启动一个最小化的 CentOS 环境。</p>
<div><pre><code>$ <span>docker</span> run --name centos -it centos <span>bash</span>
bash-4.2<span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="dockerfile"> Dockerfile</h2>
<p>请到 https://github.com/docker-library/docs/tree/master/centos 查看。</p>
]]></content:encoded>
    </item>
    <item>
      <title>minio</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/repo/minio/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/repo/minio/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">minio</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="minio"> minio</h1>
<i>Content not supported</i>
<p><strong>MinIO</strong> 是一个基于 Apache License v2.0 开源协议的对象存储服务。它兼容亚马逊 S3 云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从几 kb 到最大 5T 不等。</p>
<p>MinIO 是一个非常轻量的服务,可以很简单的和其他应用的结合，类似 NodeJS, Redis 或者 MySQL。</p>
<p><a href="https://docs.min.io/" target="_blank" rel="noopener noreferrer">官方文档<i>Content not supported</i></a></p>
<h2 id="简单使用"> 简单使用</h2>
<p>测试、开发环境下不考虑数据存储的情况下可以使用下面的命令快速开启服务。</p>
<div><pre><code>$ <span>docker</span> run -d -p <span>9000</span>:9000 -p <span>9090</span>:9090 minio/minio server /data --console-address <span>':9090'</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="离线部署"> 离线部署</h2>
<p>许多生产环境是一般是没有公网资源的，这就需要从有公网资源的服务器上把镜像导出，然后导入到需要运行镜像的内网服务器。</p>
<h3 id="导出镜像"> 导出镜像</h3>
<p>在有公网资源的服务器上下载好<code>minio/minio</code>镜像</p>
<div><pre><code>$ <span>docker</span> save -o minio.tar minio/minio:latest
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>使用docker save 的时候，也可以使用image id 来导出，但是那样导出的时候，就会丢失原来的镜像名称，推荐，还是使用镜像名字+tag来导出镜像</p>
</blockquote>
<h3 id="导入镜像"> 导入镜像</h3>
<p>把压缩文件复制到内网服务器上，使用下面的命令导入镜像</p>
<div><pre><code>$ <span>docker</span> load minio.tar 
</code></pre>
<div><span>1</span><br></div></div><h3 id="运行-minio"> 运行 minio</h3>
<ul>
<li>把 <code>/mnt/data</code> 改成要替换的数据目录</li>
<li>替换 <code>MINIO_ROOT_USER</code> 的值</li>
<li>替换 <code>MINIO_ROOT_PASSWORD</code> 的值</li>
<li>替换 name,minio1(可选)</li>
<li>如果 9000、9090 端口冲突,替换端口前面的如 <code>9009:9000</code></li>
</ul>
<div><pre><code>$ <span>sudo</span> <span>docker</span> run -d -p <span>9000</span>:9000 -p <span>9090</span>:9090 --name minio1 <span>\</span>
  -e <span>"MINIO_ROOT_USER=改成自己需要的"</span> <span>\</span>
  -e <span>"MINIO_ROOT_PASSWORD=改成自己需要的"</span> <span>\</span>
  -v /mnt/data:/data <span>\</span>
  --restart<span>=</span>always <span>\</span>
  minio/minio server /data --console-address <span>':9090'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="访问-web-管理页面"> 访问 web 管理页面</h3>
<p>http://x.x.x.x:9090</p>
]]></content:encoded>
    </item>
    <item>
      <title>MongoDB</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/repo/mongodb/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/repo/mongodb/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">MongoDB</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="mongodb"> <a href="https://hub.docker.com/_/mongo/" target="_blank" rel="noopener noreferrer">MongoDB<i>Content not supported</i></a></h1>
<i>Content not supported</i>
<h2 id="基本信息"> 基本信息</h2>
<p><a href="https://en.wikipedia.org/wiki/MongoDB" target="_blank" rel="noopener noreferrer">MongoDB<i>Content not supported</i></a> 是开源的 NoSQL 数据库实现。</p>
<p>该仓库位于 <code>https://hub.docker.com/_/mongo/</code> ，提供了 MongoDB 2.x ~ 4.x 各个版本的镜像。</p>
<h2 id="使用方法"> 使用方法</h2>
<p>默认会在 <code>27017</code> 端口启动数据库。</p>
<div><pre><code>$ <span>docker</span> run --name mongo -d mongo
</code></pre>
<div><span>1</span><br></div></div><p>使用其他应用连接到容器，可以用</p>
<div><pre><code>$ <span>docker</span> run --name some-app --link some-mongo:mongo -d application-that-uses-mongo
</code></pre>
<div><span>1</span><br></div></div><p>或者通过 <code>mongo</code></p>
<div><pre><code>$ <span>docker</span> run -it --rm <span>\</span>
    --link some-mongo:mongo <span>\</span>
    mongo <span>\</span>
    <span>sh</span> -c <span>'exec mongo "$MONGO_PORT_27017_TCP_ADDR:$MONGO_PORT_27017_TCP_PORT/test"'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="dockerfile"> Dockerfile</h2>
<p>请到 https://github.com/docker-library/docs/tree/master/mongo 查看。</p>
]]></content:encoded>
    </item>
    <item>
      <title>MySQL</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/repo/mysql/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/repo/mysql/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">MySQL</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="mysql"> <a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener noreferrer">MySQL<i>Content not supported</i></a></h1>
<i>Content not supported</i>
<h2 id="基本信息"> 基本信息</h2>
<p><a href="https://en.wikipedia.org/wiki/MySQL" target="_blank" rel="noopener noreferrer">MySQL<i>Content not supported</i></a> 是开源的关系数据库实现。</p>
<p>该仓库位于 <code>https://hub.docker.com/_/mysql/</code> ，提供了 MySQL 5.5 ~ 8.x 各个版本的镜像。</p>
<h2 id="使用方法"> 使用方法</h2>
<p>默认会在 <code>3306</code> 端口启动数据库。</p>
<div><pre><code>$ <span>docker</span> run --name some-mysql -e <span>MYSQL_ROOT_PASSWORD</span><span>=</span>mysecretpassword -d mysql
</code></pre>
<div><span>1</span><br></div></div><p>之后就可以使用其它应用来连接到该容器。</p>
<div><pre><code>$ <span>docker</span> run --name some-app --link some-mysql:mysql -d application-that-uses-mysql
</code></pre>
<div><span>1</span><br></div></div><p>或者通过 <code>mysql</code> 命令行连接。</p>
<div><pre><code>$ <span>docker</span> run -it --rm <span>\</span>
    --link some-mysql:mysql <span>\</span>
    mysql <span>\</span>
    <span>sh</span> -c <span>'exec mysql -h"$MYSQL_PORT_3306_TCP_ADDR" -P"$MYSQL_PORT_3306_TCP_PORT" -uroot -p"$MYSQL_ENV_MYSQL_ROOT_PASSWORD"'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="dockerfile"> Dockerfile</h2>
<p>请到 https://github.com/docker-library/docs/tree/master/mysql 查看</p>
]]></content:encoded>
    </item>
    <item>
      <title>Nginx</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/repo/nginx/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/repo/nginx/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Nginx</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="nginx"> <a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener noreferrer">Nginx<i>Content not supported</i></a></h1>
<i>Content not supported</i>
<h2 id="基本信息"> 基本信息</h2>
<p><a href="https://en.wikipedia.org/wiki/Nginx" target="_blank" rel="noopener noreferrer">Nginx<i>Content not supported</i></a> 是开源的高效的 Web 服务器实现，支持 HTTP、HTTPS、SMTP、POP3、IMAP 等协议。</p>
<p>该仓库位于 <code>https://hub.docker.com/_/nginx/</code> ，提供了 Nginx 1.0 ~ 1.19.x 各个版本的镜像。</p>
<h2 id="使用方法"> 使用方法</h2>
<p>下面的命令将作为一个静态页面服务器启动。</p>
<div><pre><code>$ <span>docker</span> run --name some-nginx -v /some/content:/usr/share/nginx/html:ro -d nginx
</code></pre>
<div><span>1</span><br></div></div><p>用户也可以不使用这种映射方式，通过利用 Dockerfile 来直接将静态页面内容放到镜像中，内容为</p>
<div><pre><code><span><span>FROM</span> nginx</span>
<span><span>COPY</span> static-html-directory /usr/share/nginx/html</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>之后生成新的镜像，并启动一个容器。</p>
<div><pre><code>$ <span>docker</span> build -t some-content-nginx <span>.</span>
$ <span>docker</span> run --name some-nginx -d some-content-nginx
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>开放端口，并映射到本地的 <code>8080</code> 端口。</p>
<div><pre><code>$ <span>docker</span> run --name some-nginx -d -p <span>8080</span>:80 some-content-nginx
</code></pre>
<div><span>1</span><br></div></div><p>Nginx的默认配置文件路径为 <code>/etc/nginx/nginx.conf</code>，可以通过映射它来使用本地的配置文件，例如</p>
<div><pre><code>$ <span>docker</span> run -d <span>\</span>
    --name some-nginx <span>\</span>
    -p <span>8080</span>:80 <span>\</span>
    -v /path/nginx.conf:/etc/nginx/nginx.conf:ro <span>\</span>
    nginx
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="dockerfile"> Dockerfile</h2>
<p>请到 https://github.com/docker-library/docs/tree/master/nginx 查看。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Node.js</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/repo/nodejs/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/repo/nodejs/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Node.js</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="node-js"> <a href="https://hub.docker.com/_/node/" target="_blank" rel="noopener noreferrer">Node.js<i>Content not supported</i></a></h1>
<i>Content not supported</i>
<h2 id="基本信息"> 基本信息</h2>
<p><a href="https://en.wikipedia.org/wiki/Node.js" target="_blank" rel="noopener noreferrer">Node.js<i>Content not supported</i></a> 是基于 JavaScript 的可扩展服务端和网络软件开发平台。</p>
<p>该仓库位于 <code>https://hub.docker.com/_/node/</code> ，提供了 Node.js 0.10 ~ 14.x 各个版本的镜像。</p>
<h2 id="使用方法"> 使用方法</h2>
<p>在项目中创建一个 Dockerfile。</p>
<div><pre><code><span><span>FROM</span> node:12</span>
<span># replace this with your application's default port</span>
<span><span>EXPOSE</span> 8888</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后创建镜像，并启动容器。</p>
<div><pre><code>$ <span>docker</span> build -t my-nodejs-app
$ <span>docker</span> run -it --rm --name my-running-app my-nodejs-app
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>也可以直接运行一个简单容器。</p>
<div><pre><code>$ <span>docker</span> run -it --rm <span>\</span>
    --name my-running-script <span>\</span>
    <span># -v "$(pwd)":/usr/src/myapp \</span>
    --mount <span>type</span><span>=</span>bind,src<span>=</span><span><span>`</span><span>$(</span><span>pwd</span><span>)</span><span>`</span></span>,target<span>=</span>/usr/src/myapp <span>\</span>
    -w /usr/src/myapp <span>\</span>
    node:12-alpine <span>\</span>
    <span>node</span> your-daemon-or-script.js
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="dockerfile"> Dockerfile</h2>
<p>请到 https://github.com/docker-library/docs/tree/master/node 查看。</p>
]]></content:encoded>
    </item>
    <item>
      <title>PHP</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/repo/php/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/repo/php/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">PHP</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="php"> <a href="https://hub.docker.com/_/php/" target="_blank" rel="noopener noreferrer">PHP<i>Content not supported</i></a></h1>
<i>Content not supported</i>
<h2 id="基本信息"> 基本信息</h2>
<p><a href="https://en.wikipedia.org/wiki/Php" target="_blank" rel="noopener noreferrer">PHP<i>Content not supported</i></a>（Hypertext Preprocessor 超文本预处理器的字母缩写）是一种被广泛应用的开放源代码的多用途脚本语言，它可嵌入到 HTML 中，尤其适合 web 开发。</p>
<p>该仓库位于 <code>https://hub.docker.com/_/php/</code> ，提供了 PHP 5.x ~ 8.x 各个版本的镜像。</p>
<h2 id="使用方法"> 使用方法</h2>
<p>下面的命令将运行一个已有的 PHP 脚本。</p>
<div><pre><code>$ <span>docker</span> run -it --rm -v <span>"<span>$PWD</span>"</span>:/app -w /app php:alpine php your-script.php
</code></pre>
<div><span>1</span><br></div></div><h2 id="dockerfile"> Dockerfile</h2>
<p>请到 https://github.com/docker-library/docs/tree/master/php 查看。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Redis</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/repo/redis/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/repo/redis/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Redis</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="redis"> <a href="https://hub.docker.com/_/redis/" target="_blank" rel="noopener noreferrer">Redis<i>Content not supported</i></a></h1>
<i>Content not supported</i>
<h2 id="基本信息"> 基本信息</h2>
<p><a href="https://en.wikipedia.org/wiki/Redis" target="_blank" rel="noopener noreferrer">Redis<i>Content not supported</i></a> 是开源的内存 Key-Value 数据库实现。</p>
<p>该仓库位于 <code>https://hub.docker.com/_/redis/</code> ，提供了 Redis 3.x ~ 6.x 各个版本的镜像。</p>
<h2 id="使用方法"> 使用方法</h2>
<p>默认会在 <code>6379</code> 端口启动数据库。</p>
<div><pre><code>$ <span>docker</span> run --name some-redis -d -p <span>6379</span>:6379 redis
</code></pre>
<div><span>1</span><br></div></div><p>另外还可以启用 <a href="https://redis.io/topics/persistence" target="_blank" rel="noopener noreferrer">持久存储<i>Content not supported</i></a>。</p>
<div><pre><code>$ <span>docker</span> run --name some-redis -d -p <span>6379</span>:6379 redis redis-server --appendonly <span>yes</span>
</code></pre>
<div><span>1</span><br></div></div><p>默认数据存储位置在 <code>VOLUME/data</code>。可以使用 <code>--volumes-from some-volume-container</code> 或 <code>-v /docker/host/dir:/data</code> 将数据存放到本地。</p>
<p>使用其他应用连接到容器，可以用</p>
<div><pre><code>$ <span>docker</span> run --name some-app --link some-redis:redis -d application-that-uses-redis
</code></pre>
<div><span>1</span><br></div></div><p>或者通过 <code>redis-cli</code></p>
<div><pre><code>$ <span>docker</span> run -it --rm <span>\</span>
    --link some-redis:redis <span>\</span>
    redis <span>\</span>
    <span>sh</span> -c <span>'exec redis-cli -h "$REDIS_PORT_6379_TCP_ADDR" -p "$REDIS_PORT_6379_TCP_PORT"'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="dockerfile"> Dockerfile</h2>
<p>请到 https://github.com/docker-library/docs/tree/master/redis 查看。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Ubuntu</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/repo/ubuntu/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/repo/ubuntu/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Ubuntu</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="ubuntu"> <a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="noopener noreferrer">Ubuntu<i>Content not supported</i></a></h1>
<i>Content not supported</i>
<h2 id="基本信息"> 基本信息</h2>
<p><a href="https://en.wikipedia.org/wiki/Ubuntu" target="_blank" rel="noopener noreferrer">Ubuntu<i>Content not supported</i></a> 是流行的 Linux 发行版，其自带软件版本往往较新一些。</p>
<p>该仓库位于 <code>https://hub.docker.com/_/ubuntu/</code> ，提供了 Ubuntu 从 12.04 ~ 20.04 各个版本的镜像。</p>
<h2 id="使用方法"> 使用方法</h2>
<p>默认会启动一个最小化的 Ubuntu 环境。</p>
<div><pre><code>$ <span>docker</span> run --name some-ubuntu -it ubuntu:20.04
root@523c70904d54:/<span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="dockerfile"> Dockerfile</h2>
<p>请到 https://github.com/docker-library/docs/tree/master/ubuntu 查看。</p>
]]></content:encoded>
    </item>
    <item>
      <title>WordPress</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/repo/wordpress/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/repo/wordpress/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">WordPress</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="wordpress"> <a href="https://hub.docker.com/_/wordpress/" target="_blank" rel="noopener noreferrer">WordPress<i>Content not supported</i></a></h1>
<i>Content not supported</i>
<h2 id="基本信息"> 基本信息</h2>
<p><a href="https://en.wikipedia.org/wiki/WordPress" target="_blank" rel="noopener noreferrer">WordPress<i>Content not supported</i></a> 是开源的 Blog 和内容管理系统框架，它基于 PHP 和 MySQL。</p>
<p>该仓库位于 <code>https://hub.docker.com/_/wordpress/</code> ，提供了 WordPress 4.x ~ 5.x 版本的镜像。</p>
<h2 id="使用方法"> 使用方法</h2>
<p>启动容器需要 MySQL 的支持，默认端口为 <code>80</code>。</p>
<div><pre><code>$ <span>docker</span> run --name some-wordpress --link some-mysql:mysql -d wordpress
</code></pre>
<div><span>1</span><br></div></div><p>启动 WordPress 容器时可以指定的一些环境变量包括：</p>
<ul>
<li><code>WORDPRESS_DB_USER</code> 缺省为 <code>root</code></li>
<li><code>WORDPRESS_DB_PASSWORD</code> 缺省为连接 mysql 容器的环境变量 <code>MYSQL_ROOT_PASSWORD</code> 的值</li>
<li><code>WORDPRESS_DB_NAME</code> 缺省为 <code>wordpress</code></li>
</ul>
<h2 id="dockerfile"> Dockerfile</h2>
<p>请到 https://github.com/docker-library/docs/tree/master/wordpress 查看。</p>
]]></content:encoded>
    </item>
    <item>
      <title>资源链接</title>
      <link>https://vuepress.mirror.docker-practice.com/appendix/resources/</link>
      <guid>https://vuepress.mirror.docker-practice.com/appendix/resources/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">资源链接</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="资源链接"> 资源链接</h1>
<i>Content not supported</i>
<h2 id="官方网站"> 官方网站</h2>
<ul>
<li>Docker 官方主页：https://www.docker.com</li>
<li>Docker 官方博客：https://www.docker.com/blog/</li>
<li>Docker 官方文档：https://docs.docker.com/</li>
<li>Docker Hub：https://hub.docker.com</li>
<li>Docker 的源代码仓库：https://github.com/moby/moby</li>
<li>Docker 路线图 https://github.com/docker/roadmap/projects</li>
<li>Docker 发布版本历史：https://docs.docker.com/release-notes/</li>
<li>Docker 常见问题：https://docs.docker.com/engine/faq/</li>
<li>Docker 远端应用 API：https://docs.docker.com/develop/sdk/</li>
</ul>
<h2 id="实践参考"> 实践参考</h2>
<ul>
<li>Dockerfile 参考：https://docs.docker.com/engine/reference/builder/</li>
<li>Dockerfile 最佳实践：https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/</li>
</ul>
<h2 id="技术交流"> 技术交流</h2>
<ul>
<li>Docker 邮件列表： https://groups.google.com/forum/#!forum/docker-user</li>
<li>Docker 的 IRC 频道：https://chat.freenode.net#docker</li>
<li>Docker 的 Twitter 主页：https://twitter.com/docker</li>
</ul>
<h2 id="其它"> 其它</h2>
<ul>
<li>Docker 的 StackOverflow 问答主页：https://stackoverflow.com/search?q=docker</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>归档项目</title>
      <link>https://vuepress.mirror.docker-practice.com/archive/</link>
      <guid>https://vuepress.mirror.docker-practice.com/archive/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">归档项目</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="归档项目"> 归档项目</h1>
<i>Content not supported</i>
<p>以下项目不被官方支持或内容陈旧，将在下一版本中删除（或已经删除）。</p>
<ul>
<li><a href="https://github.com/yeasy/docker_practice/tree/ca29ab51b121f43563f5d6659dedbda5cb6f048d/machine" target="_blank" rel="noopener noreferrer">Docker Machine<i>Content not supported</i></a></li>
<li><a href="https://github.com/yeasy/docker_practice/tree/ca29ab51b121f43563f5d6659dedbda5cb6f048d/swarm" target="_blank" rel="noopener noreferrer">Docker Swarm<i>Content not supported</i></a></li>
<li>Mesos</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>基本概念</title>
      <link>https://vuepress.mirror.docker-practice.com/basic_concept/</link>
      <guid>https://vuepress.mirror.docker-practice.com/basic_concept/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">基本概念</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="基本概念"> 基本概念</h1>
<i>Content not supported</i>
<p><strong>Docker</strong> 包括三个基本概念</p>
<ul>
<li><strong>镜像</strong>（<code>Image</code>）</li>
<li><strong>容器</strong>（<code>Container</code>）</li>
<li><strong>仓库</strong>（<code>Repository</code>）</li>
</ul>
<p>理解了这三个概念，就理解了 <strong>Docker</strong> 的整个生命周期。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Docker 容器</title>
      <link>https://vuepress.mirror.docker-practice.com/basic_concept/container/</link>
      <guid>https://vuepress.mirror.docker-practice.com/basic_concept/container/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Docker 容器</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="docker-容器"> Docker 容器</h1>
<i>Content not supported</i>
<p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener noreferrer">命名空间<i>Content not supported</i></a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href="./../data_management/volume.html">数据卷（Volume）</a>、或者 <a href="./../data_management/bind-mounts.html">绑定宿主目录</a>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Docker 镜像</title>
      <link>https://vuepress.mirror.docker-practice.com/basic_concept/image/</link>
      <guid>https://vuepress.mirror.docker-practice.com/basic_concept/image/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Docker 镜像</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="docker-镜像"> Docker 镜像</h1>
<i>Content not supported</i>
<p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p>
<p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p>
<h2 id="分层存储"> 分层存储</h2>
<p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener noreferrer">Union FS<i>Content not supported</i></a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<p>关于镜像构建，将会在后续相关章节中做进一步的讲解。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Docker Registry</title>
      <link>https://vuepress.mirror.docker-practice.com/basic_concept/repository/</link>
      <guid>https://vuepress.mirror.docker-practice.com/basic_concept/repository/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Docker Registry</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="docker-registry"> Docker Registry</h1>
<i>Content not supported</i>
<p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="./../repository/registry.html">Docker Registry</a> 就是这样的服务。</p>
<p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p>
<p>以 <a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener noreferrer">Ubuntu 镜像<i>Content not supported</i></a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p>
<p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<h2 id="docker-registry-公开服务"> Docker Registry 公开服务</h2>
<p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">Docker Hub<i>Content not supported</i></a>，这也是默认的 Registry，并拥有大量的高质量的 <a href="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=official" target="_blank" rel="noopener noreferrer">官方镜像<i>Content not supported</i></a>。除此以外，还有 Red Hat 的 <a href="https://quay.io/repository/" target="_blank" rel="noopener noreferrer">Quay.io<i>Content not supported</i></a>；Google 的 <a href="https://cloud.google.com/container-registry/" target="_blank" rel="noopener noreferrer">Google Container Registry<i>Content not supported</i></a>，<a href="https://kubernetes.io/" target="_blank" rel="noopener noreferrer">Kubernetes<i>Content not supported</i></a> 的镜像使用的就是这个服务；代码托管平台 <a href="https://github.com" target="_blank" rel="noopener noreferrer">GitHub<i>Content not supported</i></a> 推出的 <a href="https://docs.github.com/cn/packages/working-with-a-github-packages-registry/working-with-the-container-registry" target="_blank" rel="noopener noreferrer">ghcr.io<i>Content not supported</i></a>。</p>
<p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为 <strong>加速器</strong>。常见的有 <a href="https://www.aliyun.com/product/acr?source=5176.11533457&amp;userCode=8lx5zmtu" target="_blank" rel="noopener noreferrer">阿里云加速器<i>Content not supported</i></a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener noreferrer">DaoCloud 加速器<i>Content not supported</i></a> 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 <a href="./../install/mirror.html">安装 Docker</a>  一节中有详细的配置方法。</p>
<p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener noreferrer">网易云镜像服务<i>Content not supported</i></a>、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener noreferrer">DaoCloud 镜像市场<i>Content not supported</i></a>、<a href="https://www.aliyun.com/product/acr?source=5176.11533457&amp;userCode=8lx5zmtu" target="_blank" rel="noopener noreferrer">阿里云镜像库<i>Content not supported</i></a> 等。</p>
<h2 id="私有-docker-registry"> 私有 Docker Registry</h2>
<p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener noreferrer">Docker Registry<i>Content not supported</i></a> 镜像，可以直接使用做为私有 Registry 服务。在 <a href="./../repository/registry.html">私有仓库</a> 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p>
<p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener noreferrer">Docker Registry API<i>Content not supported</i></a> 的服务端实现，足以支持 <code>docker</code> 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p>
<p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener noreferrer">Harbor<i>Content not supported</i></a> 和 <a href="./../repository/nexus3_registry.html">Sonatype Nexus</a>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Docker Buildx</title>
      <link>https://vuepress.mirror.docker-practice.com/buildx/</link>
      <guid>https://vuepress.mirror.docker-practice.com/buildx/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Docker Buildx</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="docker-buildx"> Docker Buildx</h1>
<i>Content not supported</i>
<p>Docker Buildx 是一个 docker CLI 插件，其扩展了 docker 命令，支持 <a href="./buildkit.html">Moby BuildKit</a> 提供的功能。提供了与 docker build 相同的用户体验，并增加了许多新功能。</p>
<blockquote>
<p>该功能仅适用于 Docker v19.03+ 版本</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>使用 BuildKit 构建镜像</title>
      <link>https://vuepress.mirror.docker-practice.com/buildx/buildkit/</link>
      <guid>https://vuepress.mirror.docker-practice.com/buildx/buildkit/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">使用 BuildKit 构建镜像</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="使用-buildkit-构建镜像"> 使用 <code>BuildKit</code> 构建镜像</h1>
<i>Content not supported</i>
<p><strong>BuildKit</strong> 是下一代的镜像构建组件，在 https://github.com/moby/buildkit 开源。</p>
<p><strong>注意：如果您的镜像构建使用的是云服务商提供的镜像构建服务（腾讯云容器服务、阿里云容器服务等），由于上述服务提供商的 Docker 版本低于 18.09，BuildKit 无法使用，将造成镜像构建失败。建议使用 BuildKit 构建镜像时使用一个新的 Dockerfile 文件（例如 Dockerfile.buildkit）</strong></p>
<p>目前，Docker Hub 自动构建已经支持 buildkit，具体请参考 https://github.com/docker-practice/docker-hub-buildx</p>
<h2 id="dockerfile-新增指令详解"> <code>Dockerfile</code> 新增指令详解</h2>
<p>启用 <code>BuildKit</code> 之后，我们可以使用下面几个新的 <code>Dockerfile</code> 指令来加快镜像构建。</p>
<h3 id="run-mount-type-cache"> <code>RUN --mount=type=cache</code></h3>
<p>目前，几乎所有的程序都会使用依赖管理工具，例如 <code>Go</code> 中的 <code>go mod</code>、<code>Node.js</code> 中的 <code>npm</code> 等等，当我们构建一个镜像时，往往会重复的从互联网中获取依赖包，难以缓存，大大降低了镜像的构建效率。</p>
<p>例如一个前端工程需要用到 <code>npm</code>：</p>
<div><pre><code><span><span>FROM</span> node:alpine <span>as</span> builder</span>

<span><span>WORKDIR</span> /app</span>

<span><span>COPY</span> package.json /app/</span>

<span><span>RUN</span> npm i --registry=https://registry.npm.taobao.org <span>\</span>
        &amp;&amp; rm -rf ~/.npm</span>

<span><span>COPY</span> src /app/src</span>

<span><span>RUN</span> npm run build</span>

<span><span>FROM</span> nginx:alpine</span>

<span><span>COPY</span> <span><span>--from</span><span>=</span><span>builder</span></span> /app/dist /app/dist</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>使用多阶段构建，构建的镜像中只包含了目标文件夹 <code>dist</code>，但仍然存在一些问题，当 <code>package.json</code> 文件变动时，<code>RUN npm i &amp;&amp; rm -rf ~/.npm</code> 这一层会重新执行，变更多次后，生成了大量的中间层镜像。</p>
<p>为解决这个问题，进一步的我们可以设想一个类似 <strong>数据卷</strong> 的功能，在镜像构建时把 <code>node_modules</code> 文件夹挂载上去，在构建完成后，这个 <code>node_modules</code> 文件夹会自动卸载，实际的镜像中并不包含 <code>node_modules</code> 这个文件夹，这样我们就省去了每次获取依赖的时间，大大增加了镜像构建效率，同时也避免了生成了大量的中间层镜像。</p>
<p><code>BuildKit</code> 提供了 <code>RUN --mount=type=cache</code> 指令，可以实现上边的设想。</p>
<div><pre><code><span># syntax = docker/dockerfile:experimental</span>
<span><span>FROM</span> node:alpine <span>as</span> builder</span>

<span><span>WORKDIR</span> /app</span>

<span><span>COPY</span> package.json /app/</span>

<span><span>RUN</span> <span><span>--mount</span><span>=</span><span>type=cache,target=/app/node_modules,id=my_app_npm_module,sharing=locked</span> <span>\</span>
    <span>--mount</span><span>=</span><span>type=cache,target=/root/.npm,id=npm_cache</span></span> <span>\</span>
        npm i --registry=https://registry.npm.taobao.org</span>

<span><span>COPY</span> src /app/src</span>

<span><span>RUN</span> <span><span>--mount</span><span>=</span><span>type=cache,target=/app/node_modules,id=my_app_npm_module,sharing=locked</span></span> <span>\</span>
<span># --mount=type=cache,target=/app/dist,id=my_app_dist,sharing=locked \</span>
        npm run build</span>

<span><span>FROM</span> nginx:alpine</span>

<span># COPY --from=builder /app/dist /app/dist</span>

<span># 为了更直观的说明 from 和 source 指令，这里使用 RUN 指令</span>
<span><span>RUN</span> <span><span>--mount</span><span>=</span><span>type=cache,target=/tmp/dist,from=builder,source=/app/dist</span></span> <span>\</span>
    <span># --mount=type=cache,target/tmp/dist,from=my_app_dist,sharing=locked \</span>
    mkdir -p /app/dist &amp;&amp; cp -r /tmp/dist/* /app/dist</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p><strong>由于 <code>BuildKit</code> 为实验特性，每个 <code>Dockerfile</code> 文件开头都必须加上如下指令</strong></p>
<div><pre><code><span># syntax = docker/dockerfile:experimental</span>
</code></pre>
<div><span>1</span><br></div></div><p>第一个 <code>RUN</code> 指令执行后，<code>id</code> 为 <code>my_app_npm_module</code> 的缓存文件夹挂载到了 <code>/app/node_modules</code> 文件夹中。多次执行也不会产生多个中间层镜像。</p>
<p>第二个 <code>RUN</code> 指令执行时需要用到 <code>node_modules</code> 文件夹，<code>node_modules</code> 已经挂载，命令也可以正确执行。</p>
<p>第三个 <code>RUN</code> 指令将上一阶段产生的文件复制到指定位置，<code>from</code> 指明缓存的来源，这里 <code>builder</code> 表示缓存来源于构建的第一阶段，<code>source</code> 指明缓存来源的文件夹。</p>
<p>上面的 <code>Dockerfile</code> 中 <code>--mount=type=cache,...</code> 中指令作用如下：</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id</code></td>
<td><code>id</code> 设置一个标志，以便区分缓存。</td>
</tr>
<tr>
<td><code>target</code> (必填项)</td>
<td>缓存的挂载目标文件夹。</td>
</tr>
<tr>
<td><code>ro</code>,<code>readonly</code></td>
<td>只读，缓存文件夹不能被写入。</td>
</tr>
<tr>
<td><code>sharing</code></td>
<td>有 <code>shared</code> <code>private</code> <code>locked</code> 值可供选择。<code>sharing</code> 设置当一个缓存被多次使用时的表现，由于 <code>BuildKit</code> 支持并行构建，当多个步骤使用同一缓存时（同一 <code>id</code>）会发生冲突。<code>shared</code> 表示多个步骤可以同时读写，<code>private</code> 表示当多个步骤使用同一缓存时，每个步骤使用不同的缓存，<code>locked</code> 表示当一个步骤完成释放缓存后，后一个步骤才能继续使用该缓存。</td>
</tr>
<tr>
<td><code>from</code></td>
<td>缓存来源（构建阶段），不填写时为空文件夹。</td>
</tr>
<tr>
<td><code>source</code></td>
<td>来源的文件夹路径。</td>
</tr>
</tbody>
</table>
<h3 id="run-mount-type-bind"> <code>RUN --mount=type=bind</code></h3>
<p>该指令可以将一个镜像（或上一构建阶段）的文件挂载到指定位置。</p>
<div><pre><code><span># syntax = docker/dockerfile:experimental</span>
<span><span>RUN</span> <span><span>--mount</span><span>=</span><span>type=bind,from=php:alpine,source=/usr/local/bin/docker-php-entrypoint,target=/docker-php-entrypoint</span></span> <span>\</span>
        cat /docker-php-entrypoint</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="run-mount-type-tmpfs"> <code>RUN --mount=type=tmpfs</code></h3>
<p>该指令可以将一个 <code>tmpfs</code> 文件系统挂载到指定位置。</p>
<div><pre><code><span># syntax = docker/dockerfile:experimental</span>
<span><span>RUN</span> <span><span>--mount</span><span>=</span><span>type=tmpfs,target=/temp</span></span> <span>\</span>
        mount | grep /temp</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="run-mount-type-secret"> <code>RUN --mount=type=secret</code></h3>
<p>该指令可以将一个文件(例如密钥)挂载到指定位置。</p>
<div><pre><code><span># syntax = docker/dockerfile:experimental</span>
<span><span>RUN</span> <span><span>--mount</span><span>=</span><span>type=secret,id=aws,target=/root/.aws/credentials</span></span> <span>\</span>
        cat /root/.aws/credentials</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code>$ <span>docker</span> build -t <span>test</span> --secret <span>id</span><span>=</span>aws,src<span>=</span><span>$HOME</span>/.aws/credentials <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="run-mount-type-ssh"> <code>RUN --mount=type=ssh</code></h3>
<p>该指令可以挂载 <code>ssh</code> 密钥。</p>
<div><pre><code><span># syntax = docker/dockerfile:experimental</span>
<span><span>FROM</span> alpine</span>
<span><span>RUN</span> apk add --no-cache openssh-client</span>
<span><span>RUN</span> mkdir -p -m 0700 ~/.ssh &amp;&amp; ssh-keyscan gitlab.com >> ~/.ssh/known_hosts</span>
<span><span>RUN</span> <span><span>--mount</span><span>=</span><span>type=ssh</span></span> ssh git@gitlab.com | tee /hello</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>$ <span>eval</span> <span><span>$(</span>ssh-agent<span>)</span></span>
$ ssh-add ~/.ssh/id_rsa
<span>(</span>Input your passphrase here<span>)</span>
$ <span>docker</span> build -t <span>test</span> --ssh <span>default</span><span>=</span><span>$SSH_AUTH_SOCK</span> <span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="官方文档"> 官方文档</h2>
<ul>
<li>https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>使用 Buildx 构建镜像</title>
      <link>https://vuepress.mirror.docker-practice.com/buildx/buildx/</link>
      <guid>https://vuepress.mirror.docker-practice.com/buildx/buildx/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">使用 Buildx 构建镜像</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="使用-buildx-构建镜像"> 使用 Buildx 构建镜像</h1>
<i>Content not supported</i>
<h2 id="使用"> 使用</h2>
<p>你可以直接使用 <code>docker buildx build</code> 命令构建镜像。</p>
<div><pre><code>$ <span>docker</span> buildx build <span>.</span>
<span>[</span>+<span>]</span> Building <span>8</span>.4s <span>(</span><span>23</span>/32<span>)</span>
 <span>=</span><span>></span> <span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Buildx 使用 <a href="./buildkit.html">BuildKit 引擎</a> 进行构建，支持许多新的功能，具体参考 <a href="./buildkit.html">Buildkit</a> 一节。</p>
<h2 id="官方文档"> 官方文档</h2>
<ul>
<li>https://docs.docker.com/engine/reference/commandline/buildx/</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>使用 buildx 构建多种系统架构支持的 Docker 镜像</title>
      <link>https://vuepress.mirror.docker-practice.com/buildx/multi-arch-images/</link>
      <guid>https://vuepress.mirror.docker-practice.com/buildx/multi-arch-images/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">使用 buildx 构建多种系统架构支持的 Docker 镜像</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="使用-buildx-构建多种系统架构支持的-docker-镜像"> 使用 buildx 构建多种系统架构支持的 Docker 镜像</h1>
<i>Content not supported</i>
<p>在之前的版本中构建多种系统架构支持的 Docker 镜像，要想使用统一的名字必须使用 <a href="./../image/manifest.html"><code>$ docker manifest</code></a> 命令。</p>
<p>在 Docker 19.03+ 版本中可以使用 <code>$ docker buildx build</code> 命令使用 <code>BuildKit</code> 构建镜像。该命令支持 <code>--platform</code> 参数可以同时构建支持多种系统架构的 Docker 镜像，大大简化了构建步骤。</p>
<h2 id="新建-builder-实例"> 新建 <code>builder</code> 实例</h2>
<p>Docker for Linux 不支持构建 <code>arm</code> 架构镜像，我们可以运行一个新的容器让其支持该特性，Docker 桌面版无需进行此项设置。</p>
<div><pre><code>$ <span>docker</span> run --rm --privileged tonistiigi/binfmt:latest --install all
</code></pre>
<div><span>1</span><br></div></div><p>由于 Docker 默认的 <code>builder</code> 实例不支持同时指定多个 <code>--platform</code>，我们必须首先创建一个新的 <code>builder</code> 实例。同时由于国内拉取镜像较缓慢，我们可以使用配置了 <a href="https://github.com/moby/buildkit/blob/master/docs/buildkitd.toml.md" target="_blank" rel="noopener noreferrer">镜像加速地址<i>Content not supported</i></a>  的 <a href="https://github.com/docker-practice/buildx" target="_blank" rel="noopener noreferrer"><code>dockerpracticesig/buildkit:master</code><i>Content not supported</i></a> 镜像替换官方镜像。</p>
<blockquote>
<p>如果你有私有的镜像加速器，可以基于 https://github.com/docker-practice/buildx 构建自己的 buildkit 镜像并使用它。</p>
</blockquote>
<div><pre><code><span># 适用于国内环境</span>
$ <span>docker</span> buildx create --use --name<span>=</span>mybuilder-cn --driver docker-container --driver-opt <span>image</span><span>=</span>dockerpracticesig/buildkit:master

<span># 适用于腾讯云环境(腾讯云主机、coding.net 持续集成)</span>
$ <span>docker</span> buildx create --use --name<span>=</span>mybuilder-cn --driver docker-container --driver-opt <span>image</span><span>=</span>dockerpracticesig/buildkit:master-tencent

<span># $ docker buildx create --name mybuilder --driver docker-container</span>

$ <span>docker</span> buildx use mybuilder
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="构建镜像"> 构建镜像</h2>
<p>新建 Dockerfile 文件。</p>
<div><pre><code><span><span>FROM</span> <span><span>--platform</span><span>=</span><span>$TARGETPLATFORM</span></span> alpine</span>

<span><span>RUN</span> uname -a > /os.txt</span>

<span><span>CMD</span> cat /os.txt</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>使用 <code>$ docker buildx build</code> 命令构建镜像，注意将 <code>myusername</code> 替换为自己的 Docker Hub 用户名。</p>
<p><code>--push</code> 参数表示将构建好的镜像推送到 Docker 仓库。</p>
<div><pre><code>$ <span>docker</span> buildx build --platform linux/arm,linux/arm64,linux/amd64 -t myusername/hello <span>.</span> --push

<span># 查看镜像信息</span>
$ <span>docker</span> buildx imagetools inspect myusername/hello
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在不同架构运行该镜像，可以得到该架构的信息。</p>
<div><pre><code><span># arm</span>
$ <span>docker</span> run -it --rm myusername/hello
Linux buildkitsandbox <span>4.9</span>.125-linuxkit <span>#1 SMP Fri Sep 7 08:20:28 UTC 2018 armv7l Linux</span>

<span># arm64</span>
$ <span>docker</span> run -it --rm myusername/hello
Linux buildkitsandbox <span>4.9</span>.125-linuxkit <span>#1 SMP Fri Sep 7 08:20:28 UTC 2018 aarch64 Linux</span>

<span># amd64</span>
$ <span>docker</span> run -it --rm myusername/hello
Linux buildkitsandbox <span>4.9</span>.125-linuxkit <span>#1 SMP Fri Sep 7 08:20:28 UTC 2018 x86_64 Linux</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="架构相关变量"> 架构相关变量</h2>
<p><code>Dockerfile</code> 支持如下架构相关的变量</p>
<p><strong>TARGETPLATFORM</strong></p>
<p>构建镜像的目标平台，例如 <code>linux/amd64</code>, <code>linux/arm/v7</code>, <code>windows/amd64</code>。</p>
<p><strong>TARGETOS</strong></p>
<p><code>TARGETPLATFORM</code> 的 OS 类型，例如 <code>linux</code>, <code>windows</code></p>
<p><strong>TARGETARCH</strong></p>
<p><code>TARGETPLATFORM</code> 的架构类型，例如 <code>amd64</code>, <code>arm</code></p>
<p><strong>TARGETVARIANT</strong></p>
<p><code>TARGETPLATFORM</code> 的变种，该变量可能为空，例如 <code>v7</code></p>
<p><strong>BUILDPLATFORM</strong></p>
<p>构建镜像主机平台，例如 <code>linux/amd64</code></p>
<p><strong>BUILDOS</strong></p>
<p><code>BUILDPLATFORM</code> 的 OS 类型，例如 <code>linux</code></p>
<p><strong>BUILDARCH</strong></p>
<p><code>BUILDPLATFORM</code> 的架构类型，例如 <code>amd64</code></p>
<p><strong>BUILDVARIANT</strong></p>
<p><code>BUILDPLATFORM</code> 的变种，该变量可能为空，例如 <code>v7</code></p>
<h3 id="使用举例"> 使用举例</h3>
<p>例如我们要构建支持 <code>linux/arm/v7</code> 和 <code>linux/amd64</code> 两种架构的镜像。假设已经生成了两个平台对应的二进制文件：</p>
<ul>
<li><code>bin/dist-linux-arm</code></li>
<li><code>bin/dist-linux-amd64</code></li>
</ul>
<p>那么 <code>Dockerfile</code> 可以这样书写：</p>
<div><pre><code><span><span>FROM</span> scratch</span>

<span># 使用变量必须申明</span>
<span><span>ARG</span> TARGETOS</span>

<span><span>ARG</span> TARGETARCH</span>

<span><span>COPY</span> bin/dist-<span>${TARGETOS}</span>-<span>${TARGETARCH}</span> /dist</span>

<span><span>ENTRYPOINT</span> [<span>"dist"</span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>CI/CD</title>
      <link>https://vuepress.mirror.docker-practice.com/cases/ci/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cases/ci/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">CI/CD</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="ci-cd"> CI/CD</h1>
<i>Content not supported</i>
<p><strong>持续集成(Continuous integration)</strong> 是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>
<p><strong>持续部署(continuous deployment)</strong> 是通过自动化的构建、测试和部署循环来快速交付高质量的产品。</p>
<p>与 <code>Jenkins</code> 不同的是，基于 Docker 的 CI/CD 每一步都运行在 Docker 容器中，所以理论上支持所有的编程语言。</p>
]]></content:encoded>
    </item>
    <item>
      <title>GitHub Actions</title>
      <link>https://vuepress.mirror.docker-practice.com/cases/ci/actions/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cases/ci/actions/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">GitHub Actions</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="github-actions"> GitHub Actions</h1>
<i>Content not supported</i>
<p>GitHub <a href="https://github.com/features/actions" target="_blank" rel="noopener noreferrer">Actions<i>Content not supported</i></a> 是 GitHub 推出的一款 CI/CD 工具。</p>
<p>我们可以在每个 <code>job</code> 的 <code>step</code> 中使用 Docker 执行构建步骤。</p>
<div><pre><code><span>on</span><span>:</span> push

<span>name</span><span>:</span> CI

<span>jobs</span><span>:</span>
  <span>my-job</span><span>:</span>
    <span>name</span><span>:</span> Build
    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest
    <span>steps</span><span>:</span>
      <span>-</span> <span>uses</span><span>:</span> actions/checkout@master
        <span>with</span><span>:</span>
          <span>fetch-depth</span><span>:</span> <span>2</span>
      <span>-</span> <span>name</span><span>:</span> run docker container
        <span>uses</span><span>:</span> docker<span>:</span>//golang<span>:</span>alpine
        <span>with</span><span>:</span>
          <span>args</span><span>:</span> go version
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://docs.github.com/en/actions" target="_blank" rel="noopener noreferrer">Actions Docs<i>Content not supported</i></a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Drone Demo</title>
      <link>https://vuepress.mirror.docker-practice.com/cases/ci/drone/demo/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cases/ci/drone/demo/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Drone Demo</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="drone-demo"> Drone Demo</h1>
]]></content:encoded>
    </item>
    <item>
      <title>Drone</title>
      <link>https://vuepress.mirror.docker-practice.com/cases/ci/drone/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cases/ci/drone/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Drone</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="drone"> Drone</h1>
<i>Content not supported</i>
<p>基于 <code>Docker</code> 的 <code>CI/CD</code> 工具 <code>Drone</code> 所有编译、测试的流程都在 <code>Docker</code> 容器中进行。</p>
<p>开发者只需在项目中包含 <code>.drone.yml</code> 文件，将代码推送到 git 仓库，<code>Drone</code> 就能够自动化的进行编译、测试、发布。</p>
<p>本小节以 <code>GitHub</code> + <code>Drone</code> 来演示 <code>Drone</code> 的工作流程。当然在实际开发过程中，你的代码也许不在 GitHub 托管，那么你可以尝试使用 <code>Gogs</code> + <code>Drone</code> 来进行 <code>CI/CD</code>。</p>
<h2 id="drone-关联项目"> Drone 关联项目</h2>
<p>在 Github 新建一个名为 <code>drone-demo</code> 的仓库。</p>
<p>打开我们已经 <a href="./install.html">部署好的 Drone 网站</a> 或者 <a href="https://cloud.drone.io" target="_blank" rel="noopener noreferrer">Drone Cloud<i>Content not supported</i></a>，使用 GitHub 账号登录，在界面中关联刚刚新建的 <code>drone-demo</code> 仓库。</p>
<h2 id="编写项目源代码"> 编写项目源代码</h2>
<p>初始化一个 git 仓库</p>
<div><pre><code>$ <span>mkdir</span> drone-demo

$ <span>cd</span> drone-demo

$ <span>git</span> init

$ <span>git</span> remote <span>add</span> origin git@github.com:username/drone-demo.git
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这里以一个简单的 <code>Go</code> 程序为例，该程序输出 <code>Hello World!</code></p>
<p>编写 <code>app.go</code> 文件</p>
<div><pre><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>func</span> <span>main</span><span>(</span><span>)</span><span>{</span>
    fmt<span>.</span><span>Printf</span><span>(</span><span>"Hello World!\n"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>编写 <code>.drone.yml</code> 文件</p>
<div><pre><code><span>kind</span><span>:</span> pipeline
<span>type</span><span>:</span> docker
<span>name</span><span>:</span> build
<span>steps</span><span>:</span>
<span>-</span> <span>name</span><span>:</span> build
  <span>image</span><span>:</span> golang<span>:</span>alpine
  <span>pull</span><span>:</span> if<span>-</span>not<span>-</span>exists <span># always never</span>
  <span>environment</span><span>:</span>
    <span>KEY</span><span>:</span> VALUE
  <span>commands</span><span>:</span>
    <span>-</span> echo $KEY
    <span>-</span> pwd
    <span>-</span> ls
    <span>-</span> CGO_ENABLED=0 GOOS=linux go build <span>-</span>a <span>-</span>installsuffix cgo <span>-</span>o app .
    <span>-</span> ./app

<span>trigger</span><span>:</span>
  <span>branch</span><span>:</span>
  <span>-</span> master
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>现在目录结构如下</p>
<div><pre><code><span>.</span>
├── .drone.yml
└── app.go
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="推送项目源代码到-github"> 推送项目源代码到 GitHub</h2>
<div><pre><code>$ <span>git</span> <span>add</span> <span>.</span>

$ <span>git</span> commit -m <span>"test drone ci"</span>

$ <span>git</span> push origin master
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="查看项目构建过程及结果"> 查看项目构建过程及结果</h2>
<p>打开我们部署好的 <code>Drone</code> 网站或者 Drone Cloud，即可看到构建结果。</p>
<p><img src="./_images/drone-build.png" alt=""></p>
<p>当然我们也可以把构建结果上传到 GitHub，Docker Registry，云服务商提供的对象存储，或者生产环境中。</p>
<p>本书 GitBook 也使用 Drone 进行 CI/CD，具体配置信息请查看本书根目录 <a href="https://github.com/yeasy/docker_practice/blob/master/.drone.yml" target="_blank" rel="noopener noreferrer"><code>.drone.yml</code><i>Content not supported</i></a> 文件。</p>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://github.com/drone/drone" target="_blank" rel="noopener noreferrer">Drone Github<i>Content not supported</i></a></li>
<li><a href="https://docs.drone.io/" target="_blank" rel="noopener noreferrer">Drone 文档<i>Content not supported</i></a></li>
<li><a href="https://github.com/docker-practice/drone-demo" target="_blank" rel="noopener noreferrer">Drone 示例<i>Content not supported</i></a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>部署 Drone</title>
      <link>https://vuepress.mirror.docker-practice.com/cases/ci/drone/install/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cases/ci/drone/install/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">部署 Drone</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="部署-drone"> 部署 Drone</h1>
<i>Content not supported</i>
<h2 id="要求"> 要求</h2>
<ul>
<li>
<p>拥有公网 IP、域名 (如果你不满足要求，可以尝试在本地使用 Gogs + Drone)</p>
</li>
<li>
<p>域名 SSL 证书 (目前国内有很多云服务商提供免费证书)</p>
</li>
<li>
<p>熟悉 <code>Docker</code> 以及 <code>Docker Compose</code></p>
</li>
<li>
<p>熟悉 <code>Git</code> 基本命令</p>
</li>
<li>
<p>对 <code>CI/CD</code> 有一定了解</p>
</li>
</ul>
<h2 id="新建-github-应用"> 新建 GitHub 应用</h2>
<p>登录 GitHub，在 https://github.com/settings/applications/new 新建一个应用。</p>
<p><img src="https://docs.drone.io/screenshots/github_application_create.png" alt=""></p>
<p>接下来查看这个应用的详情，记录 <code>Client ID</code> 和 <code>Client Secret</code>，之后配置 Drone 会用到。</p>
<h2 id="配置-drone"> 配置 Drone</h2>
<p>我们通过使用 <code>Docker Compose</code> 来启动 <code>Drone</code>，编写 <code>docker-compose.yml</code> 文件。</p>
<div><pre><code><span>version</span><span>:</span> <span>'3'</span>

<span>services</span><span>:</span>

  <span>drone-server</span><span>:</span>
    <span>image</span><span>:</span> drone/drone<span>:</span>2.3.1
    <span>ports</span><span>:</span>
      <span>-</span> 443<span>:</span><span>443</span>
      <span>-</span> <span>80:80</span>
    <span>volumes</span><span>:</span>
      <span>-</span> drone<span>-</span>data<span>:</span>/data<span>:</span>rw
      <span>-</span> ./ssl<span>:</span>/etc/certs
    <span>restart</span><span>:</span> always
    <span>environment</span><span>:</span>
      <span>-</span> DRONE_SERVER_HOST=$<span>{</span>DRONE_SERVER_HOST<span>:</span><span>-</span>https<span>:</span>//drone.yeasy.com<span>}</span>
      <span>-</span> DRONE_SERVER_PROTO=$<span>{</span>DRONE_SERVER_PROTO<span>:</span><span>-</span>https<span>}</span>
      <span>-</span> DRONE_RPC_SECRET=$<span>{</span>DRONE_RPC_SECRET<span>:</span><span>-</span>secret<span>}</span>
      <span>-</span> DRONE_GITHUB_SERVER=https<span>:</span>//github.com
      <span>-</span> DRONE_GITHUB_CLIENT_ID=$<span>{</span>DRONE_GITHUB_CLIENT_ID<span>}</span>
      <span>-</span> DRONE_GITHUB_CLIENT_SECRET=$<span>{</span>DRONE_GITHUB_CLIENT_SECRET<span>}</span>

  <span>drone-agent</span><span>:</span>
    <span>image</span><span>:</span> drone/drone<span>-</span>runner<span>-</span>docker<span>:</span><span>1</span>
    <span>restart</span><span>:</span> always
    <span>depends_on</span><span>:</span>
      <span>-</span> drone<span>-</span>server
    <span>volumes</span><span>:</span>
      <span>-</span> /var/run/docker.sock<span>:</span>/var/run/docker.sock<span>:</span>rw
    <span>environment</span><span>:</span>
      <span>-</span> DRONE_RPC_PROTO=http
      <span>-</span> DRONE_RPC_HOST=drone<span>-</span>server
      <span>-</span> DRONE_RPC_SECRET=$<span>{</span>DRONE_RPC_SECRET<span>:</span><span>-</span>secret<span>}</span>
      <span>-</span> DRONE_RUNNER_NAME=$<span>{</span>HOSTNAME<span>:</span><span>-</span>demo<span>}</span>
      <span>-</span> DRONE_RUNNER_CAPACITY=2
    <span>dns</span><span>:</span> 114.114.114.114

<span>volumes</span><span>:</span>
  <span>drone-data</span><span>:</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>新建 <code>.env</code> 文件，输入变量及其值</p>
<div><pre><code><span># 必填 服务器地址，例如 drone.domain.com</span>
<span>DRONE_SERVER_HOST</span><span>=</span>
<span>DRONE_SERVER_PROTO</span><span>=</span>https
<span>DRONE_RPC_SECRET</span><span>=</span>secret
<span><span>HOSTNAME</span></span><span>=</span>demo
<span># 必填 在 GitHub 应用页面查看</span>
<span>DRONE_GITHUB_CLIENT_ID</span><span>=</span>
<span># 必填 在 GitHub 应用页面查看</span>
<span>DRONE_GITHUB_CLIENT_SECRET</span><span>=</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="启动-drone"> 启动 Drone</h3>
<div><pre><code>$ <span>docker</span> compose up -d
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
      <enclosure url="https://docs.drone.io/screenshots/github_application_create.png" type="image/png"/>
    </item>
    <item>
      <title>操作系统</title>
      <link>https://vuepress.mirror.docker-practice.com/cases/os/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cases/os/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">操作系统</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="操作系统"> 操作系统</h1>
<i>Content not supported</i>
<p>目前常用的 Linux 发行版主要包括 <code>Debian/Ubuntu</code> 系列和 <code>CentOS/Fedora</code> 系列。</p>
<p>前者以自带软件包版本较新而出名；后者则宣称运行更稳定一些。选择哪个操作系统取决于读者的具体需求。</p>
<p>使用 Docker，读者只需要一个命令就能快速获取一个 Linux 发行版镜像，这是以往包括各种虚拟化技术都难以实现的。这些镜像一般都很精简，但是可以支持完整 Linux 系统的大部分功能。</p>
<p>本章将介绍如何使用 Docker 安装和使用 <code>Busybox</code>、<code>Alphine</code>、<code>Debian/Ubuntu</code>、<code>CentOS/Fedora</code> 等操作系统。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Alpine</title>
      <link>https://vuepress.mirror.docker-practice.com/cases/os/alpine/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cases/os/alpine/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Alpine</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="alpine"> Alpine</h1>
<i>Content not supported</i>
<h2 id="简介"> 简介</h2>
<p><img src="./_images/alpinelinux-logo.png" alt="Alpine Linux 操作系统"></p>
<p><code>Alpine</code> 操作系统是一个面向安全的轻型 <code>Linux</code> 发行版。它不同于通常 <code>Linux</code> 发行版，<code>Alpine</code> 采用了 <code>musl libc</code> 和 <code>busybox</code> 以减小系统的体积和运行时资源消耗，但功能上比 <code>busybox</code> 又完善的多，因此得到开源社区越来越多的青睐。在保持瘦身的同时，<code>Alpine</code> 还提供了自己的包管理工具 <code>apk</code>，可以通过 <code>https://pkgs.alpinelinux.org/packages</code> 网站上查询包信息，也可以直接通过 <code>apk</code> 命令直接查询和安装各种软件。</p>
<p><code>Alpine</code> 由非商业组织维护的，支持广泛场景的 <code>Linux</code>发行版，它特别为资深/重度<code>Linux</code>用户而优化，关注安全，性能和资源效能。<code>Alpine</code> 镜像可以适用于更多常用场景，并且是一个优秀的可以适用于生产的基础系统/环境。</p>
<p><code>Alpine</code> Docker 镜像也继承了 <code>Alpine Linux</code> 发行版的这些优势。相比于其他 <code>Docker</code> 镜像，它的容量非常小，仅仅只有 <strong>5 MB</strong> 左右（对比 <code>Ubuntu</code> 系列镜像接近 <code>200 MB</code>），且拥有非常友好的包管理机制。官方镜像来自 <code>docker-alpine</code> 项目。</p>
<p>目前 Docker 官方已开始推荐使用 <code>Alpine</code> 替代之前的 <code>Ubuntu</code> 做为基础镜像环境。这样会带来多个好处。包括镜像下载速度加快，镜像安全性提高，主机之间的切换更方便，占用更少磁盘空间等。</p>
<p>下表是官方镜像的大小比较：</p>
<div><pre><code>REPOSITORY          TAG           IMAGE ID          VIRTUAL SIZE
alpine              latest        4e38e38c8ce0      <span>4.799</span> MB
debian              latest        4d6ce913b130      <span>84.98</span> MB
ubuntu              latest        b39b81afc8ca      <span>188.3</span> MB
centos              latest        8efe422e6104      <span>210</span> MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="获取并使用官方镜像"> 获取并使用官方镜像</h2>
<p>由于镜像很小，下载时间往往很短，读者可以直接使用 <code>docker run</code> 指令直接运行一个 <code>Alpine</code> 容器，并指定运行的 Linux 指令，例如：</p>
<div><pre><code>$ <span>docker</span> run alpine <span>echo</span> <span>'123'</span>
<span>123</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="迁移至-alpine-基础镜像"> 迁移至 <code>Alpine</code> 基础镜像</h2>
<p>目前，大部分 Docker 官方镜像都已经支持 <code>Alpine</code> 作为基础镜像，可以很容易进行迁移。</p>
<p>例如：</p>
<ul>
<li><code>ubuntu/debian</code> -&gt; <code>alpine</code></li>
<li><code>python:3</code> -&gt; <code>python:3-alpine</code></li>
<li><code>ruby:2.6</code> -&gt; <code>ruby:2.6-alpine</code></li>
</ul>
<p>另外，如果使用 <code>Alpine</code> 镜像替换 <code>Ubuntu</code> 基础镜像，安装软件包时需要用 <code>apk</code> 包管理器替换 <code>apt</code> 工具，如</p>
<div><pre><code>$ apk <span>add</span> --no-cache <span>&lt;</span>package<span>></span>
</code></pre>
<div><span>1</span><br></div></div><p><code>Alpine</code> 中软件安装包的名字可能会与其他发行版有所不同，可以在 <code>https://pkgs.alpinelinux.org/packages</code> 网站搜索并确定安装包名称。如果需要的安装包不在主索引内，但是在测试或社区索引中。那么可以按照以下方法使用这些安装包。</p>
<div><pre><code>$ <span>echo</span> <span>"http://dl-cdn.alpinelinux.org/alpine/edge/testing"</span> <span>>></span> /etc/apk/repositories
$ apk --update <span>add</span> --no-cache <span>&lt;</span>package<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>由于在国内访问 <code>apk</code> 仓库较缓慢，建议在使用 <code>apk</code> 之前先替换仓库地址为国内镜像。</p>
<div><pre><code><span><span>RUN</span> sed -i <span>"s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g"</span> /etc/apk/repositories <span>\</span>
      &amp;&amp; apk add --no-cache &lt;package></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="相关资源"> 相关资源</h2>
<ul>
<li><code>Alpine</code> 官网：https://www.alpinelinux.org/</li>
<li><code>Alpine</code> 官方仓库：https://github.com/alpinelinux</li>
<li><code>Alpine</code> 官方镜像：https://hub.docker.com/_/alpine/</li>
<li><code>Alpine</code> 官方镜像仓库：https://github.com/gliderlabs/docker-alpine</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Busybox</title>
      <link>https://vuepress.mirror.docker-practice.com/cases/os/busybox/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cases/os/busybox/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Busybox</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="busybox"> Busybox</h1>
<i>Content not supported</i>
<h2 id="简介"> 简介</h2>
<p><img src="./_images/busybox-logo.png" alt="Busybox - Linux 瑞士军刀"></p>
<p><code>BusyBox</code> 是一个集成了一百多个最常用 Linux 命令和工具（如 <code>cat</code>、<code>echo</code>、<code>grep</code>、<code>mount</code>、<code>telnet</code> 等）的精简工具箱，它只需要几 MB 的大小，很方便进行各种快速验证，被誉为“Linux 系统的瑞士军刀”。</p>
<p><code>BusyBox</code> 可运行于多款 <code>POSIX</code> 环境的操作系统中，如 <code>Linux</code>（包括 <code>Android</code>）、<code>Hurd</code>、<code>FreeBSD</code> 等。</p>
<h2 id="获取官方镜像"> 获取官方镜像</h2>
<p>可以使用 <code>docker pull</code> 指令下载 <code>busybox:latest</code> 镜像：</p>
<div><pre><code>$ <span>docker</span> pull busybox:latest
latest: Pulling from library/busybox
5c4213be9af9: Pull complete
Digest: sha256:c6b45a95f932202dbb27c31333c4789f45184a744060f6e569cc9d2bf1b9ad6f
Status: Downloaded newer image <span>for</span> busybox:latest
docker.io/library/busybox:latest
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>下载后，可以看到 <code>busybox</code> 镜像只有 <strong>2.433 MB</strong>：</p>
<div><pre><code>$ <span>docker</span> image <span>ls</span>
REPOSITORY                   TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
busybox                   latest              e72ac664f4f0        <span>6</span> weeks ago         <span>2.433</span> MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="运行-busybox"> 运行 busybox</h2>
<p>启动一个 <code>busybox</code> 容器，并在容器中执行 <code>grep</code> 命令。</p>
<div><pre><code>$ <span>docker</span> run -it busybox
/ <span># grep</span>
BusyBox v1.22.1 <span>(</span><span>2014</span>-05-22 <span>23</span>:22:11 UTC<span>)</span> multi-call binary.

Usage: <span>grep</span> <span>[</span>-HhnlLoqvsriwFE<span>]</span> <span>[</span>-m N<span>]</span> <span>[</span>-A/B/C N<span>]</span> PATTERN/-e PATTERN<span>..</span>./-f FILE <span>[</span>FILE<span>]</span><span>..</span>.

Search <span>for</span> <span>PATTERN</span> <span>in</span> FILEs <span>(</span>or stdin<span>)</span>

        -H      Add <span>'filename:'</span> prefix
        -h      Do not <span>add</span> <span>'filename:'</span> prefix
        -n      Add <span>'line_no:'</span> prefix
        -l      Show only names of files that match
        -L      Show only names of files that don<span>'t match
        -c      Show only count of matching lines
        -o      Show only the matching part of line
        -q      Quiet. Return 0 if PATTERN is found, 1 otherwise
        -v      Select non-matching lines
        -s      Suppress open and read errors
        -r      Recurse
        -i      Ignore case
        -w      Match whole words only
        -x      Match whole lines only
        -F      PATTERN is a literal (not regexp)
        -E      PATTERN is an extended regexp
        -m N    Match up to N times per file
        -A N    Print N lines of trailing context
        -B N    Print N lines of leading context
        -C N    Same as '</span>-A N -B N'
        -e PTRN Pattern to match
        -f FILE Read pattern from <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>查看容器内的挂载信息。</p>
<div><pre><code>/ <span># mount</span>
overlay on / <span>type</span> overlay <span>(</span>rw,relatime,lowerdir<span>=</span>/var/lib/docker/overlay2/l/BOTCI5RF24AMC4A2UWF4N6ZWFP:/var/lib/docker/overlay2/l/TWVP5T5DMKJGXZOROR7CAPWGFP,upperdir<span>=</span>/var/lib/docker/overlay2/801ef0bf6cce35288dbb8fe00a4f9cc47760444693bfdf339ed0bdcf926e12a3/diff,workdir<span>=</span>/var/lib/docker/overlay2/801ef0bf6cce35288dbb8fe00a4f9cc47760444693bfdf339ed0bdcf926e12a3/work<span>)</span>
proc on /proc <span>type</span> proc <span>(</span>rw,nosuid,nodev,noexec,relatime<span>)</span>
tmpfs on /dev <span>type</span> tmpfs <span>(</span>rw,nosuid,size<span>=</span>65536k,mode<span>=</span><span>755</span><span>)</span>
devpts on /dev/pts <span>type</span> devpts <span>(</span>rw,nosuid,noexec,relatime,gid<span>=</span><span>5</span>,mode<span>=</span><span>620</span>,ptmxmode<span>=</span><span>666</span><span>)</span>
sysfs on /sys <span>type</span> sysfs <span>(</span>ro,nosuid,nodev,noexec,relatime<span>)</span>
tmpfs on /sys/fs/cgroup <span>type</span> tmpfs <span>(</span>ro,nosuid,nodev,noexec,relatime,mode<span>=</span><span>755</span><span>)</span>
cgroup on /sys/fs/cgroup/systemd <span>type</span> cgroup <span>(</span>ro,nosuid,nodev,noexec,relatime,xattr,release_agent<span>=</span>/lib/systemd/systemd-cgroups-agent,name<span>=</span>systemd<span>)</span>
cgroup on /sys/fs/cgroup/net_cls,net_prio <span>type</span> cgroup <span>(</span>ro,nosuid,nodev,noexec,relatime,net_cls,net_prio<span>)</span>
cgroup on /sys/fs/cgroup/freezer <span>type</span> cgroup <span>(</span>ro,nosuid,nodev,noexec,relatime,freezer<span>)</span>
cgroup on /sys/fs/cgroup/cpu,cpuacct <span>type</span> cgroup <span>(</span>ro,nosuid,nodev,noexec,relatime,cpu,cpuacct<span>)</span>
cgroup on /sys/fs/cgroup/cpuset <span>type</span> cgroup <span>(</span>ro,nosuid,nodev,noexec,relatime,cpuset<span>)</span>
cgroup on /sys/fs/cgroup/blkio <span>type</span> cgroup <span>(</span>ro,nosuid,nodev,noexec,relatime,blkio<span>)</span>
cgroup on /sys/fs/cgroup/perf_event <span>type</span> cgroup <span>(</span>ro,nosuid,nodev,noexec,relatime,perf_event<span>)</span>
cgroup on /sys/fs/cgroup/memory <span>type</span> cgroup <span>(</span>ro,nosuid,nodev,noexec,relatime,memory<span>)</span>
cgroup on /sys/fs/cgroup/devices <span>type</span> cgroup <span>(</span>ro,nosuid,nodev,noexec,relatime,devices<span>)</span>
cgroup on /sys/fs/cgroup/pids <span>type</span> cgroup <span>(</span>ro,nosuid,nodev,noexec,relatime,pids<span>)</span>
mqueue on /dev/mqueue <span>type</span> mqueue <span>(</span>rw,nosuid,nodev,noexec,relatime<span>)</span>
shm on /dev/shm <span>type</span> tmpfs <span>(</span>rw,nosuid,nodev,noexec,relatime,size<span>=</span>65536k<span>)</span>
/dev/vda1 on /etc/resolv.conf <span>type</span> ext3 <span>(</span>rw,noatime,data<span>=</span>ordered<span>)</span>
/dev/vda1 on /etc/hostname <span>type</span> ext3 <span>(</span>rw,noatime,data<span>=</span>ordered<span>)</span>
/dev/vda1 on /etc/hosts <span>type</span> ext3 <span>(</span>rw,noatime,data<span>=</span>ordered<span>)</span>
devpts on /dev/console <span>type</span> devpts <span>(</span>rw,nosuid,noexec,relatime,gid<span>=</span><span>5</span>,mode<span>=</span><span>620</span>,ptmxmode<span>=</span><span>666</span><span>)</span>
proc on /proc/bus <span>type</span> proc <span>(</span>ro,relatime<span>)</span>
proc on /proc/fs <span>type</span> proc <span>(</span>ro,relatime<span>)</span>
proc on /proc/irq <span>type</span> proc <span>(</span>ro,relatime<span>)</span>
proc on /proc/sys <span>type</span> proc <span>(</span>ro,relatime<span>)</span>
proc on /proc/sysrq-trigger <span>type</span> proc <span>(</span>ro,relatime<span>)</span>
tmpfs on /proc/acpi <span>type</span> tmpfs <span>(</span>ro,relatime<span>)</span>
tmpfs on /proc/kcore <span>type</span> tmpfs <span>(</span>rw,nosuid,size<span>=</span>65536k,mode<span>=</span><span>755</span><span>)</span>
tmpfs on /proc/keys <span>type</span> tmpfs <span>(</span>rw,nosuid,size<span>=</span>65536k,mode<span>=</span><span>755</span><span>)</span>
tmpfs on /proc/timer_list <span>type</span> tmpfs <span>(</span>rw,nosuid,size<span>=</span>65536k,mode<span>=</span><span>755</span><span>)</span>
tmpfs on /proc/sched_debug <span>type</span> tmpfs <span>(</span>rw,nosuid,size<span>=</span>65536k,mode<span>=</span><span>755</span><span>)</span>
tmpfs on /sys/firmware <span>type</span> tmpfs <span>(</span>ro,relatime<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p><code>busybox</code> 镜像虽然小巧，但包括了大量常见的 <code>Linux</code> 命令，读者可以用它快速熟悉 <code>Linux</code> 命令。</p>
<h2 id="相关资源"> 相关资源</h2>
<ul>
<li><code>Busybox</code> 官网：https://busybox.net/</li>
<li><code>Busybox</code> 官方仓库：https://git.busybox.net/busybox/</li>
<li><code>Busybox</code> 官方镜像：https://hub.docker.com/_/busybox/</li>
<li><code>Busybox</code> 官方仓库：https://github.com/docker-library/busybox</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>CentOS/Fedora</title>
      <link>https://vuepress.mirror.docker-practice.com/cases/os/centos/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cases/os/centos/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">CentOS/Fedora</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="centos-fedora"> CentOS/Fedora</h1>
<i>Content not supported</i>
<h2 id="centos-系统简介"> CentOS 系统简介</h2>
<p><code>CentOS</code> 和 <code>Fedora</code> 都是基于 <code>Redhat</code> 的常见 Linux 分支。<code>CentOS</code> 是目前企业级服务器的常用操作系统；<code>Fedora</code> 则主要面向个人桌面用户。</p>
<p><img src="./_images/centos-logo.png" alt="CentOS 操作系统"></p>
<p>CentOS（Community Enterprise Operating System，中文意思是：社区企业操作系统），它是基于 <code>Red Hat Enterprise Linux</code> 源代码编译而成。由于 <code>CentOS</code> 与 <code>Redhat Linux</code> 源于相同的代码基础，所以很多成本敏感且需要高稳定性的公司就使用 <code>CentOS</code> 来替代商业版 <code>Red Hat Enterprise Linux</code>。<code>CentOS</code> 自身不包含闭源软件。</p>
<h3 id="使用-centos-官方镜像"> 使用 CentOS 官方镜像</h3>
<p>使用 <code>docker run</code> 直接运行 <code>CentOS 7</code> 镜像，并登录 <code>bash</code>。</p>
<div><pre><code>$ <span>docker</span> run -it centos:7 <span>bash</span>
Unable to <span>find</span> image <span>'centos:latest'</span> locally
latest: Pulling from library/centos
3d8673bd162a: Pull complete
Digest: sha256:a66ffcb73930584413de83311ca11a4cb4938c9b2521d331026dad970c19adf4
Status: Downloaded newer image <span>for</span> centos:latest
<span>[</span>root@43eb3b194d48 /<span>]</span><span># cat /etc/redhat-release</span>
CentOS Linux release <span>7.9</span>.2009 <span>(</span>Core<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="fedora-系统简介"> Fedora 系统简介</h2>
<p><img src="./_images/fedora-logo.png" alt="Fedora 操作系统"></p>
<p><code>Fedora</code> 由 <code>Fedora Project</code> 社区开发，红帽公司赞助的 <code>Linux</code> 发行版。它的目标是创建一套新颖、多功能并且自由和开源的操作系统。<code>Fedora</code> 的功能对于用户而言，它是一套功能完备的，可以更新的免费操作系统，而对赞助商 <code>Red Hat</code> 而言，它是许多新技术的测试平台。被认为可用的技术最终会加入到 <code>Red Hat Enterprise Linux</code> 中。</p>
<h3 id="使用-fedora-官方镜像"> 使用 Fedora 官方镜像</h3>
<p>使用 <code>docker run</code> 命令直接运行 <code>Fedora</code> 官方镜像，并登录 <code>bash</code>。</p>
<div><pre><code>$ <span>docker</span> run -it fedora <span>bash</span>
Unable to <span>find</span> image <span>'fedora:latest'</span> locally
latest: Pulling from library/fedora
2bf01635e2a0: Pull complete
Digest: sha256:64a02df6aac27d1200c2572fe4b9949f1970d05f74d367ce4af994ba5dc3669e
Status: Downloaded newer image <span>for</span> fedora:latest
<span>[</span>root@196ca341419b /<span>]</span><span># cat /etc/redhat-release</span>
Fedora release <span>24</span> <span>(</span>Twenty Four<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="相关资源"> 相关资源</h2>
<ul>
<li><code>Fedora</code> 官网：https://getfedora.org/</li>
<li><code>Fedora</code> 官方仓库：https://github.com/fedora-infra</li>
<li><code>Fedora</code> 官方镜像：https://hub.docker.com/_/fedora/</li>
<li><code>Fedora</code> 官方镜像仓库：https://github.com/fedora-cloud/docker-brew-fedora</li>
<li><code>CentOS</code> 官网：https://www.centos.org</li>
<li><code>CentOS</code> 官方仓库：https://github.com/CentOS</li>
<li><code>CentOS</code> 官方镜像：https://hub.docker.com/_/centos/</li>
<li><code>CentOS</code> 官方镜像仓库：https://github.com/CentOS/CentOS-Dockerfiles</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>本章小结</title>
      <link>https://vuepress.mirror.docker-practice.com/cases/os/summary/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cases/os/summary/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">本章小结</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="本章小结"> 本章小结</h1>
<i>Content not supported</i>
<p>本章讲解了典型操作系统镜像的下载和使用。</p>
<p>除了官方的镜像外，在 <code>Docker Hub</code> 上还有许多第三方组织或个人上传的 Docker 镜像。</p>
<p>读者可以根据具体情况来选择。一般来说：</p>
<ul>
<li>
<p>官方镜像体积都比较小，只带有一些基本的组件。 精简的系统有利于安全、稳定和高效的运行，也适合进行个性化定制。</p>
</li>
<li>
<p>出于安全考虑，几乎所有官方制作的镜像都没有安装 SSH 服务，无法通过用户名和密码直接登录到容器中。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Debian/Ubuntu</title>
      <link>https://vuepress.mirror.docker-practice.com/cases/os/debian/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cases/os/debian/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Debian/Ubuntu</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="debian-ubuntu"> Debian/Ubuntu</h1>
<i>Content not supported</i>
<p><code>Debian</code> 和 <code>Ubuntu</code> 都是目前较为流行的 <strong>Debian 系</strong> 的服务器操作系统，十分适合研发场景。<code>Docker Hub</code> 上提供了官方镜像，国内各大容器云服务也基本都提供了相应的支持。</p>
<h2 id="debian-系统简介"> Debian 系统简介</h2>
<p><img src="./_images/debian-logo.png" alt="Debian 操作系统"></p>
<p><code>Debian</code> 是由 <code>GPL</code> 和其他自由软件许可协议授权的自由软件组成的操作系统，由 <strong>Debian 计划（Debian Project）</strong> 组织维护。<strong>Debian 计划</strong> 是一个独立的、分散的组织，由 <code>3000</code> 人志愿者组成，接受世界多个非盈利组织的资金支持，<code>Software in the Public Interest</code> 提供支持并持有商标作为保护机构。<code>Debian</code> 以其坚守 <code>Unix</code> 和自由软件的精神，以及其给予用户的众多选择而闻名。现时 <code>Debian</code> 包括了超过 <code>25,000</code> 个软件包并支持 <code>12</code> 个计算机系统结构。</p>
<p><code>Debian</code> 作为一个大的系统组织框架，其下有多种不同操作系统核心的分支计划，主要为采用 <code>Linux</code> 核心的 <code>Debian GNU/Linux</code> 系统，其他还有采用 <code>GNU Hurd</code> 核心的 <code>Debian GNU/Hurd</code> 系统、采用 <code>FreeBSD</code> 核心的 <code>Debian GNU/kFreeBSD</code> 系统，以及采用 <code>NetBSD</code> 核心的 <code>Debian GNU/NetBSD</code> 系统。甚至还有利用 <code>Debian</code> 的系统架构和工具，采用 <code>OpenSolaris</code> 核心构建而成的 <code>Nexenta OS</code> 系统。在这些 <code>Debian</code> 系统中，以采用 <code>Linux</code> 核心的 <code>Debian GNU/Linux</code> 最为著名。</p>
<p>众多的 <code>Linux</code> 发行版，例如 <code>Ubuntu</code>、<code>Knoppix</code> 和 <code>Linspire</code> 及 <code>Xandros</code> 等，都基于 <code>Debian GNU/Linux</code>。</p>
<h3 id="使用-debian-官方镜像"> 使用 Debian 官方镜像</h3>
<p>官方提供了大家熟知的 <code>debian</code> 镜像以及面向科研领域的 <code>neurodebian</code> 镜像。可以使用 <code>docker run</code> 直接运行 <code>Debian</code> 镜像。</p>
<div><pre><code>$ <span>docker</span> run -it debian <span>bash</span>
root@668e178d8d69:/<span># cat /etc/issue</span>
Debian GNU/Linux <span>8</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>Debian</code> 镜像很适合作为基础镜像，构建自定义镜像。</p>
<h2 id="ubuntu-系统简介"> Ubuntu 系统简介</h2>
<p><img src="./_images/ubuntu-logo.jpg" alt="Ubuntu 操作系统"></p>
<p><code>Ubuntu</code> 是一个以桌面应用为主的 <code>GNU/Linux</code> 操作系统，其名称来自非洲南部祖鲁语或豪萨语的“ubuntu”一词（官方译名“友帮拓”，另有“吾帮托”、“乌班图”、“有奔头”或“乌斑兔”等译名）。<code>Ubuntu</code> 意思是“人性”以及“我的存在是因为大家的存在”，是非洲传统的一种价值观，类似华人社会的“仁爱”思想。 <code>Ubuntu</code> 基于 <code>Debian</code> 发行版和 <code>GNOME/Unity</code> 桌面环境，与 <code>Debian</code> 的不同在于它每 6 个月会发布一个新版本，每 2 年推出一个长期支持 <strong>（Long Term Support，LTS）</strong> 版本，一般支持 3 年时间。</p>
<h3 id="使用-ubuntu-官方镜像"> 使用 Ubuntu 官方镜像</h3>
<p>下面以 <code>ubuntu:18.04</code> 为例，演示如何使用该镜像安装一些常用软件。</p>
<p>首先使用 <code>-ti</code> 参数启动容器，登录 <code>bash</code>，查看 <code>ubuntu</code> 的发行版本号。</p>
<div><pre><code>$ <span>docker</span> run -ti ubuntu:18.04 /bin/bash
root@7d93de07bf76:/<span># cat /etc/os-release</span>
<span>NAME</span><span>=</span><span>"Ubuntu"</span>
<span>VERSION</span><span>=</span><span>"18.04.1 LTS (Bionic Beaver)"</span>
<span>ID</span><span>=</span>ubuntu
<span>ID_LIKE</span><span>=</span>debian
<span>PRETTY_NAME</span><span>=</span><span>"Ubuntu 18.04.1 LTS"</span>
<span>VERSION_ID</span><span>=</span><span>"18.04"</span>
<span>HOME_URL</span><span>=</span><span>"https://www.ubuntu.com/"</span>
<span>SUPPORT_URL</span><span>=</span><span>"https://help.ubuntu.com/"</span>
<span>BUG_REPORT_URL</span><span>=</span><span>"https://bugs.launchpad.net/ubuntu/"</span>
<span>PRIVACY_POLICY_URL</span><span>=</span><span>"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span>
<span>VERSION_CODENAME</span><span>=</span>bionic
<span>UBUNTU_CODENAME</span><span>=</span>bionic
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>当试图直接使用 <code>apt-get</code> 安装一个软件的时候，会提示 <code>E: Unable to locate package</code>。</p>
<div><pre><code>root@7d93de07bf76:/<span># apt-get install curl</span>
Reading package lists<span>..</span>. Done
Building dependency tree
Reading state information<span>..</span>. Done
E: Unable to <span>locate</span> package <span>curl</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这并非系统不支持 <code>apt-get</code> 命令。Docker 镜像在制作时为了精简清除了 <code>apt</code> 仓库信息，因此需要先执行 <code>apt-get update</code> 命令来更新仓库信息。更新信息后即可成功通过 <code>apt-get</code> 命令来安装软件。</p>
<div><pre><code>root@7d93de07bf76:/<span># apt-get update</span>
Get:1 http://archive.ubuntu.com/ubuntu bionic InRelease <span>[</span><span>242</span> kB<span>]</span>
Get:2 http://security.ubuntu.com/ubuntu bionic-security InRelease <span>[</span><span>88.7</span> kB<span>]</span>
Get:3 http://security.ubuntu.com/ubuntu bionic-security/multiverse amd64 Packages <span>[</span><span>7348</span> B<span>]</span>
Get:4 http://security.ubuntu.com/ubuntu bionic-security/universe amd64 Packages <span>[</span><span>823</span> kB<span>]</span>
Get:5 http://archive.ubuntu.com/ubuntu bionic-updates InRelease <span>[</span><span>88.7</span> kB<span>]</span>
Get:6 http://archive.ubuntu.com/ubuntu bionic-backports InRelease <span>[</span><span>74.6</span> kB<span>]</span>
Get:7 http://archive.ubuntu.com/ubuntu bionic/universe amd64 Packages <span>[</span><span>11.3</span> MB<span>]</span>
Get:8 http://security.ubuntu.com/ubuntu bionic-security/restricted amd64 Packages <span>[</span><span>31.0</span> kB<span>]</span>
Get:9 http://security.ubuntu.com/ubuntu bionic-security/main amd64 Packages <span>[</span><span>835</span> kB<span>]</span>
Get:10 http://archive.ubuntu.com/ubuntu bionic/restricted amd64 Packages <span>[</span><span>13.5</span> kB<span>]</span>
Get:11 http://archive.ubuntu.com/ubuntu bionic/main amd64 Packages <span>[</span><span>1344</span> kB<span>]</span>
Get:12 http://archive.ubuntu.com/ubuntu bionic/multiverse amd64 Packages <span>[</span><span>186</span> kB<span>]</span>
Get:13 http://archive.ubuntu.com/ubuntu bionic-updates/main amd64 Packages <span>[</span><span>1127</span> kB<span>]</span>
Get:14 http://archive.ubuntu.com/ubuntu bionic-updates/universe amd64 Packages <span>[</span><span>1350</span> kB<span>]</span>
Get:15 http://archive.ubuntu.com/ubuntu bionic-updates/multiverse amd64 Packages <span>[</span><span>11.4</span> kB<span>]</span>
Get:16 http://archive.ubuntu.com/ubuntu bionic-updates/restricted amd64 Packages <span>[</span><span>44.7</span> kB<span>]</span>
Get:17 http://archive.ubuntu.com/ubuntu bionic-backports/main amd64 Packages <span>[</span><span>2496</span> B<span>]</span>
Get:18 http://archive.ubuntu.com/ubuntu bionic-backports/universe amd64 Packages <span>[</span><span>4252</span> B<span>]</span>
Fetched <span>17.6</span> MB <span>in</span> 1min 25s <span>(</span><span>207</span> kB/s<span>)</span>
Reading package lists<span>..</span>. Done
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>首先，安装 <code>curl</code> 工具。</p>
<div><pre><code>root@7d93de07bf76:/<span># apt-get install curl</span>
Reading package lists<span>..</span>. Done
Building dependency tree
Reading state information<span>..</span>. Done
The following additional packages will be installed:
  ca-certificates krb5-locales libasn1-8-heimdal libcurl4 libgssapi-krb5-2 libgssapi3-heimdal libhcrypto4-heimdal libheimbase1-heimdal libheimntlm0-heimdal libhx509-5-heimdal
  libk5crypto3 libkeyutils1 libkrb5-26-heimdal libkrb5-3 libkrb5support0 libldap-2.4-2 libldap-common libnghttp2-14 libpsl5 libroken18-heimdal librtmp1 libsasl2-2 libsasl2-modules libsasl2-modules-db libsqlite3-0 libssl1.1 libwind0-heimdal openssl publicsuffix
<span>..</span>.
root@7d93de07bf76:/<span># curl</span>
curl: try <span>'curl --help'</span> or <span>'curl --manual'</span> <span>for</span> <span>more</span> information
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>接下来，再安装 <code>apache</code> 服务。</p>
<div><pre><code>root@7d93de07bf76:/<span># apt-get install -y apache2</span>
Reading package lists<span>..</span>. Done
Building dependency tree
Reading state information<span>..</span>. Done
The following additional packages will be installed:
  apache2-bin apache2-data apache2-utils <span>file</span> libapr1 libaprutil1 libaprutil1-dbd-sqlite3 libaprutil1-ldap libexpat1 libgdbm-compat4 libgdbm5 libicu60 liblua5.2-0 libmagic-mgc libmagic1 libperl5.26 libxml2 mime-support netbase perl perl-modules-5.26 ssl-cert xz-utils
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>启动这个 <code>apache</code> 服务，然后使用 <code>curl</code> 来测试本地访问。</p>
<div><pre><code>root@7d93de07bf76:/<span># service apache2 start</span>
 * Starting web server apache2                                                                                                                               AH00558: apache2: Could not reliably determine the server<span>'s fully qualified domain name, using 172.17.0.2. Set the '</span>ServerName' directive globally to suppress this message
 *
root@7d93de07bf76:/<span># curl 127.0.0.1</span>

<span>&lt;</span><span>!</span>DOCTYPE html PUBLIC <span>"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span>"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span><span>></span>
<span>&lt;</span>html <span>xmlns</span><span>=</span><span>"http://www.w3.org/1999/xhtml"</span><span>></span>
  <span>&lt;</span><span>!</span>--
    Modified from the Debian original <span>for</span> Ubuntu
    Last updated: <span>2016</span>-11-16
    See: https://launchpad.net/bugs/1288690
  --<span>></span>
  <span>&lt;</span>head<span>></span>
    <span>&lt;</span>meta http-equiv<span>=</span><span>"Content-Type"</span> <span>content</span><span>=</span><span>"text/html; charset=UTF-8"</span> /<span>></span>
    <span>&lt;</span>title<span>></span>Apache2 Ubuntu Default Page: It works<span>&lt;</span>/title<span>></span>
    <span>&lt;</span>style <span>type</span><span>=</span><span>"text/css"</span> <span>media</span><span>=</span><span>"screen"</span><span>></span>
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>配合使用 <code>-p</code> 参数对外映射服务端口，可以允许容器外来访问该服务。</p>
<h2 id="相关资源"> 相关资源</h2>
<ul>
<li><code>Debian</code> 官网：https://www.debian.org/</li>
<li><code>Neuro Debian</code> 官网：http://neuro.debian.net/</li>
<li><code>Debian</code> 官方仓库：https://github.com/Debian</li>
<li><code>Debian</code> 官方镜像：https://hub.docker.com/_/debian/</li>
<li><code>Debian</code> 官方镜像仓库：https://github.com/tianon/docker-brew-debian/</li>
<li><code>Ubuntu</code> 官网：https://ubuntu.com</li>
<li><code>Ubuntu</code> 官方仓库：https://github.com/ubuntu</li>
<li><code>Ubuntu</code> 官方镜像：https://hub.docker.com/_/ubuntu/</li>
<li><code>Ubuntu</code> 官方镜像仓库：https://github.com/tianon/docker-brew-ubuntu-core</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>容器与云计算</title>
      <link>https://vuepress.mirror.docker-practice.com/cloud/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cloud/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">容器与云计算</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="容器与云计算"> 容器与云计算</h1>
<i>Content not supported</i>
<p>Docker 目前已经得到了众多公有云平台的支持，并成为除虚拟机之外的核心云业务。</p>
<p>除了 AWS、Google、Azure 等，国内的各大公有云厂商，基本上都同时支持了虚拟机服务和基于 Kubernetes 的容器云业务。有的还推出了其他服务，例如 <a href="https://cloud.tencent.com/act/cps/redirect?redirect=11588&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61" target="_blank" rel="noopener noreferrer">容器镜像服务<i>Content not supported</i></a> 让用户在云上享有安全高效的镜像托管、分发等服务。</p>
]]></content:encoded>
    </item>
    <item>
      <title>阿里云</title>
      <link>https://vuepress.mirror.docker-practice.com/cloud/alicloud/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cloud/alicloud/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">阿里云</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="阿里云"> 阿里云</h1>
<i>Content not supported</i>
<p><img src="./_images/aliyun-logo.png" alt="阿里云"></p>
<p><a href="https://www.aliyun.com?source=5176.11533457&amp;userCode=8lx5zmtu&amp;type=copy" target="_blank" rel="noopener noreferrer">阿里云<i>Content not supported</i></a> 创立于 2009 年，是中国较早的云计算平台。阿里云致力于提供安全、可靠的计算和数据处理能力。</p>
<p><a href="https://www.aliyun.com?source=5176.11533457&amp;userCode=8lx5zmtu&amp;type=copy" target="_blank" rel="noopener noreferrer">阿里云<i>Content not supported</i></a> 的客户群体中，活跃着微博、虎牙、魅族、优酷等一大批明星互联网公司。在天猫双 11 全球狂欢节等极富挑战的应用场景中，阿里云保持着良好的运行纪录。</p>
<p><a href="https://www.aliyun.com/product/kubernetes?source=5176.11533457&amp;userCode=8lx5zmtu&amp;type=copy" target="_blank" rel="noopener noreferrer">阿里云容器服务 Kubernetes 版 ACK<i>Content not supported</i></a> 提供了高性能、可伸缩的容器应用管理服务，支持在一组云服务器上通过 Docker 容器来进行应用生命周期管理。容器服务极大简化了用户对容器管理集群的搭建工作，无缝整合了阿里云虚拟化、存储、网络和安全能力。容器服务提供了多种应用发布方式和流水线般的持续交付能力，原生支持微服务架构，助力用户无缝上云和跨云管理。</p>
<p><img src="https://img.alicdn.com/tps/TB10yjtPpXXXXacXXXXXXXXXXXX-1531-1140.png" alt=""></p>
]]></content:encoded>
    </item>
    <item>
      <title>亚马逊云</title>
      <link>https://vuepress.mirror.docker-practice.com/cloud/aws/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cloud/aws/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">亚马逊云</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="亚马逊云"> 亚马逊云</h1>
<i>Content not supported</i>
<p><img src="./_images/aws-logo.jpg" alt="AWS"></p>
<p><a href="https://www.amazonaws.cn" target="_blank" rel="noopener noreferrer">AWS<i>Content not supported</i></a>，即 Amazon Web Services，是亚马逊（Amazon）公司的 IaaS 和 PaaS 平台服务。AWS 提供了一整套基础设施和应用程序服务，使用户几乎能够在云中运行一切应用程序：从企业应用程序和大数据项目，到社交游戏和移动应用程序。AWS 面向用户提供包括弹性计算、存储、数据库、应用程序在内的一整套云计算服务，能够帮助企业降低 IT 投入成本和维护成本。</p>
<p>自 2006 年初起，亚马逊 AWS 开始在云中为各种规模的公司提供技术服务平台。利用亚马逊 AWS，软件开发人员可以轻松购买计算、存储、数据库和其他基于 Internet 的服务来支持其应用程序。开发人员能够灵活选择任何开发平台或编程环境，以便于其尝试解决问题。由于开发人员只需按使用量付费，无需前期资本支出，亚马逊 AWS 是向最终用户交付计算资源、保存的数据和其他应用程序的一种经济划算的方式。</p>
<p>2015 年 AWS 正式发布了 EC2 容器服务(ECS)。ECS 的目的是让 Docker 容器变的更加简单，它提供了一个集群和编排的层，用来控制主机上的容器部署，以及部署之后的集群内的容器的生命周期管理。ECS 是诸如 Docker Swarm、Kubernetes、Mesos 等工具的替代，它们工作在同一个层，除了作为一个服务来提供。这些工具和 ECS 不同的地方在于，前者需要用户自己来部署和管理，而 ECS 是“作为服务”来提供的。</p>
<p><img src="./_images/ECS.jpg" alt="AWS 容器服务"></p>
]]></content:encoded>
    </item>
    <item>
      <title>简介</title>
      <link>https://vuepress.mirror.docker-practice.com/cloud/intro/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cloud/intro/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">简介</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="简介"> 简介</h1>
<i>Content not supported</i>
<p>目前与容器相关的云计算主要分为两种类型。</p>
<p>一种是传统的 IaaS 服务商提供对容器相关的服务，包括镜像下载、容器托管等。</p>
<p>另一种是直接基于容器技术对外提供容器云服务，所谓 Container as a Service（CaaS）。</p>
]]></content:encoded>
    </item>
    <item>
      <title>本章小结</title>
      <link>https://vuepress.mirror.docker-practice.com/cloud/summary/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cloud/summary/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">本章小结</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="本章小结"> 本章小结</h1>
<i>Content not supported</i>
<p>本章介绍了公有云服务对 Docker 的积极支持，以及新出现的容器云平台。</p>
<p>事实上，Docker 技术的出现自身就极大推动了云计算行业的发展。</p>
<p>通过整合公有云的虚拟机和 Docker 方式，可能获得更多的好处，包括</p>
<ul>
<li>更快速的持续交付和部署能力；</li>
<li>利用内核级虚拟化，对公有云中服务器资源进行更加高效地利用；</li>
<li>利用公有云和 Docker 的特性更加方便的迁移和扩展应用。</li>
</ul>
<p>同时，容器将作为与虚拟机类似的业务直接提供给用户使用，极大的丰富了应用开发和部署的场景。</p>
]]></content:encoded>
    </item>
    <item>
      <title>腾讯云</title>
      <link>https://vuepress.mirror.docker-practice.com/cloud/tencentCloud/</link>
      <guid>https://vuepress.mirror.docker-practice.com/cloud/tencentCloud/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">腾讯云</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="腾讯云"> 腾讯云</h1>
<i>Content not supported</i>
<p><img src="./_images/qcloud-logo.jpg" alt="腾讯云"></p>
<p><a href="https://cloud.tencent.com/act/cps/redirect?redirect=1040&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61&amp;from=console" target="_blank" rel="noopener noreferrer">腾讯云<i>Content not supported</i></a> 在架构方面经过多年积累，并且有着多年对海量互联网服务的经验。不管是社交、游戏还是其他领域，都有多年的成熟产品来提供产品服务。腾讯在云端完成重要部署，为开发者及企业提供云服务、云数据、云运营等整体一站式服务方案。</p>
<p>具体包括 <a href="https://cloud.tencent.com/act/cps/redirect?redirect=1001&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61&amp;from=console" target="_blank" rel="noopener noreferrer">云服务器<i>Content not supported</i></a>、<a href="https://cloud.tencent.com/act/cps/redirect?redirect=1020&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61&amp;from=console" target="_blank" rel="noopener noreferrer">云存储<i>Content not supported</i></a>、<a href="https://cloud.tencent.com/act/cps/redirect?redirect=1003&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61&amp;from=console" target="_blank" rel="noopener noreferrer">云数据库<i>Content not supported</i></a>、<a href="https://cloud.tencent.com/act/cps/redirect?redirect=1019&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61&amp;from=console" target="_blank" rel="noopener noreferrer">视频与CDN<i>Content not supported</i></a> 和 <a href="https://dnspod.cloud.tencent.com" target="_blank" rel="noopener noreferrer">域名注册<i>Content not supported</i></a> 等基础云服务；腾讯云分析（MTA）、腾讯云推送（信鸽）等腾讯整体大数据能力；以及 QQ互联、QQ 空间、微云、微社区等云端链接社交体系。这些正是腾讯云可以提供给这个行业的差异化优势，造就了可支持各种互联网使用场景的高品质的腾讯云技术平台。</p>
<p><a href="https://cloud.tencent.com/act/cps/redirect?redirect=10058&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61" target="_blank" rel="noopener noreferrer">腾讯云容器服务 TKE<i>Content not supported</i></a> 是高度可扩展的高性能容器管理服务，用户可以在托管的云服务器实例集群上轻松运行应用程序。使用该服务，将无需安装、运维、扩展用户的集群管理基础设施，只需进行简单的 API 调用，便可启动和停止 Docker 应用程序，查询集群的完整状态，以及使用各种云服务。用户可以根据用户的资源需求和可用性要求在用户的集群中安排容器的置放，满足业务或应用程序的特定要求。</p>
<p><img src="https://mc.qcloudimg.com/static/img/0581dbeb97c869bbe6e62025dbc592d7/image.png" alt=""></p>
]]></content:encoded>
    </item>
    <item>
      <title>Docker Compose 项目</title>
      <link>https://vuepress.mirror.docker-practice.com/compose/</link>
      <guid>https://vuepress.mirror.docker-practice.com/compose/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Docker Compose 项目</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="docker-compose-项目"> Docker Compose 项目</h1>
<i>Content not supported</i>
<p><code>Docker Compose</code> 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。</p>
<p>本章将介绍 <code>Compose</code> 项目情况以及安装和使用。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Compose 命令说明</title>
      <link>https://vuepress.mirror.docker-practice.com/compose/commands/</link>
      <guid>https://vuepress.mirror.docker-practice.com/compose/commands/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Compose 命令说明</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="compose-命令说明"> Compose 命令说明</h1>
<i>Content not supported</i>
<h2 id="命令对象与格式"> 命令对象与格式</h2>
<p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>
<p>执行 <code>docker compose [COMMAND] --help</code> 可以查看具体某个命令的使用格式。</p>
<p><code>docker compose</code> 命令的基本的使用格式是</p>
<div><pre><code><span>docker</span> compose <span>[</span>-f<span>=</span><span>&lt;</span>arg<span>></span><span>..</span>.<span>]</span> <span>[</span>options<span>]</span> <span>[</span>COMMAND<span>]</span> <span>[</span>ARGS<span>..</span>.<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="命令选项"> 命令选项</h2>
<ul>
<li>
<p><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</p>
</li>
<li>
<p><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</p>
</li>
<li>
<p><code>--verbose</code> 输出更多调试信息。</p>
</li>
<li>
<p><code>-v, --version</code> 打印版本并退出。</p>
</li>
</ul>
<h2 id="命令使用说明"> 命令使用说明</h2>
<h3 id="build"> <code>build</code></h3>
<p>格式为 <code>docker compose build [options] [SERVICE...]</code>。</p>
<p>构建（重新构建）项目中的服务容器。</p>
<p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p>
<p>可以随时在项目目录下运行 <code>docker compose build</code> 来重新构建服务。</p>
<p>选项包括：</p>
<ul>
<li>
<p><code>--force-rm</code> 删除构建过程中的临时容器。</p>
</li>
<li>
<p><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</p>
</li>
<li>
<p><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</p>
</li>
</ul>
<h3 id="config"> <code>config</code></h3>
<p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p>
<h3 id="down"> <code>down</code></h3>
<p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p>
<h3 id="exec"> <code>exec</code></h3>
<p>进入指定的容器。</p>
<h3 id="help"> <code>help</code></h3>
<p>获得一个命令的帮助。</p>
<h3 id="images"> <code>images</code></h3>
<p>列出 Compose 文件中包含的镜像。</p>
<h3 id="kill"> <code>kill</code></h3>
<p>格式为 <code>docker compose kill [options] [SERVICE...]</code>。</p>
<p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。</p>
<p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p>
<div><pre><code>$ <span>docker</span> compose <span>kill</span> -s SIGINT
</code></pre>
<div><span>1</span><br></div></div><h3 id="logs"> <code>logs</code></h3>
<p>格式为 <code>docker compose logs [options] [SERVICE...]</code>。</p>
<p>查看服务容器的输出。默认情况下，docker compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p>
<p>该命令在调试问题的时候十分有用。</p>
<h3 id="pause"> <code>pause</code></h3>
<p>格式为 <code>docker compose pause [SERVICE...]</code>。</p>
<p>暂停一个服务容器。</p>
<h3 id="port"> <code>port</code></h3>
<p>格式为 <code>docker compose port [options] SERVICE PRIVATE_PORT</code>。</p>
<p>打印某个容器端口所映射的公共端口。</p>
<p>选项：</p>
<ul>
<li>
<p><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</p>
</li>
<li>
<p><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</p>
</li>
</ul>
<h3 id="ps"> <code>ps</code></h3>
<p>格式为 <code>docker compose ps [options] [SERVICE...]</code>。</p>
<p>列出项目中目前的所有容器。</p>
<p>选项：</p>
<ul>
<li><code>-q</code> 只打印容器的 ID 信息。</li>
</ul>
<h3 id="pull"> <code>pull</code></h3>
<p>格式为 <code>docker compose pull [options] [SERVICE...]</code>。</p>
<p>拉取服务依赖的镜像。</p>
<p>选项：</p>
<ul>
<li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li>
</ul>
<h3 id="push"> <code>push</code></h3>
<p>推送服务依赖的镜像到 Docker 镜像仓库。</p>
<h3 id="restart"> <code>restart</code></h3>
<p>格式为 <code>docker compose restart [options] [SERVICE...]</code>。</p>
<p>重启项目中的服务。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>
</ul>
<h3 id="rm"> <code>rm</code></h3>
<p>格式为 <code>docker compose rm [options] [SERVICE...]</code>。</p>
<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker compose stop</code> 命令来停止容器。</p>
<p>选项：</p>
<ul>
<li>
<p><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</p>
</li>
<li>
<p><code>-v</code> 删除容器所挂载的数据卷。</p>
</li>
</ul>
<h3 id="run"> <code>run</code></h3>
<p>格式为 <code>docker compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p>
<p>在指定服务上执行一个命令。</p>
<p>例如：</p>
<div><pre><code>$ <span>docker</span> compose run ubuntu <span>ping</span> docker.com
</code></pre>
<div><span>1</span><br></div></div><p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。</p>
<p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p>
<p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p>
<p>两个不同点：</p>
<ul>
<li>
<p>给定命令将会覆盖原有的自动运行命令；</p>
</li>
<li>
<p>不会自动创建端口，以避免冲突。</p>
</li>
</ul>
<p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p>
<div><pre><code>$ <span>docker</span> compose run --no-deps web python manage.py shell
</code></pre>
<div><span>1</span><br></div></div><p>将不会启动 web 容器所关联的其它容器。</p>
<p>选项：</p>
<ul>
<li>
<p><code>-d</code> 后台运行容器。</p>
</li>
<li>
<p><code>--name NAME</code> 为容器指定一个名字。</p>
</li>
<li>
<p><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</p>
</li>
<li>
<p><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</p>
</li>
<li>
<p><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</p>
</li>
<li>
<p><code>--no-deps</code> 不自动启动关联的服务容器。</p>
</li>
<li>
<p><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</p>
</li>
<li>
<p><code>-p, --publish=[]</code> 映射容器端口到本地主机。</p>
</li>
<li>
<p><code>--service-ports</code> 配置服务端口并映射到本地主机。</p>
</li>
<li>
<p><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</p>
</li>
</ul>
<h3 id="start"> <code>start</code></h3>
<p>格式为 <code>docker compose start [SERVICE...]</code>。</p>
<p>启动已经存在的服务容器。</p>
<h3 id="stop"> <code>stop</code></h3>
<p>格式为 <code>docker compose stop [options] [SERVICE...]</code>。</p>
<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker compose start</code> 可以再次启动这些容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<h3 id="top"> <code>top</code></h3>
<p>查看各个服务容器内运行的进程。</p>
<h3 id="unpause"> <code>unpause</code></h3>
<p>格式为 <code>docker compose unpause [SERVICE...]</code>。</p>
<p>恢复处于暂停状态中的服务。</p>
<h3 id="up"> <code>up</code></h3>
<p>格式为 <code>docker compose up [options] [SERVICE...]</code>。</p>
<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>
<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>
<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>
<p>默认情况，<code>docker compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>
<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>
<p>如果使用 <code>docker compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>
<p>默认情况，如果服务容器已经存在，<code>docker compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p>
<p>选项：</p>
<ul>
<li>
<p><code>-d</code> 在后台运行服务容器。</p>
</li>
<li>
<p><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</p>
</li>
<li>
<p><code>--no-deps</code> 不启动服务所链接的容器。</p>
</li>
<li>
<p><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</p>
</li>
<li>
<p><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</p>
</li>
<li>
<p><code>--no-build</code> 不自动构建缺失的服务镜像。</p>
</li>
<li>
<p><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</p>
</li>
</ul>
<h3 id="version"> <code>version</code></h3>
<p>格式为 <code>docker compose version</code>。</p>
<p>打印版本信息。</p>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://docs.docker.com/compose/reference/" target="_blank" rel="noopener noreferrer">官方文档<i>Content not supported</i></a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Compose 模板文件</title>
      <link>https://vuepress.mirror.docker-practice.com/compose/compose_file/</link>
      <guid>https://vuepress.mirror.docker-practice.com/compose/compose_file/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Compose 模板文件</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="compose-模板文件"> Compose 模板文件</h1>
<i>Content not supported</i>
<p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p>
<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>
<div><pre><code><span>version</span><span>:</span> <span>"3"</span>

<span>services</span><span>:</span>
  <span>webapp</span><span>:</span>
    <span>image</span><span>:</span> examples/web
    <span>ports</span><span>:</span>
      <span>-</span> <span>"80:80"</span>
    <span>volumes</span><span>:</span>
      <span>-</span> <span>"/data"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>
<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>
<p>下面分别介绍各个指令的用法。</p>
<h2 id="build"> <code>build</code></h2>
<p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>
<div><pre><code><span>version</span><span>:</span> <span>'3'</span>
<span>services</span><span>:</span>

  <span>webapp</span><span>:</span>
    <span>build</span><span>:</span> ./dir
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p>
<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p>
<p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p>
<div><pre><code><span>version</span><span>:</span> <span>'3'</span>
<span>services</span><span>:</span>

  <span>webapp</span><span>:</span>
    <span>build</span><span>:</span>
      <span>context</span><span>:</span> ./dir
      <span>dockerfile</span><span>:</span> Dockerfile<span>-</span>alternate
      <span>args</span><span>:</span>
        <span>buildno</span><span>:</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>使用 <code>cache_from</code> 指定构建镜像的缓存</p>
<div><pre><code><span>build</span><span>:</span>
  <span>context</span><span>:</span> .
  <span>cache_from</span><span>:</span>
    <span>-</span> alpine<span>:</span>latest
    <span>-</span> corp/web_app<span>:</span><span>3.14</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="cap-add-cap-drop"> <code>cap_add, cap_drop</code></h2>
<p>指定容器的内核能力（capacity）分配。</p>
<p>例如，让容器拥有所有能力可以指定为：</p>
<div><pre><code><span>cap_add</span><span>:</span>
  <span>-</span> ALL
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>去掉 NET_ADMIN 能力可以指定为：</p>
<div><pre><code><span>cap_drop</span><span>:</span>
  <span>-</span> NET_ADMIN
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="command"> <code>command</code></h2>
<p>覆盖容器启动后默认执行的命令。</p>
<div><pre><code><span>command</span><span>:</span> echo "hello world"
</code></pre>
<div><span>1</span><br></div></div><h2 id="configs"> <code>configs</code></h2>
<p>仅用于 <code>Swarm mode</code>，详细内容请查看 <a href="./../swarm_mode/"><code>Swarm mode</code></a> 一节。</p>
<h2 id="cgroup-parent"> <code>cgroup_parent</code></h2>
<p>指定父 <code>cgroup</code> 组，意味着将继承该组的资源限制。</p>
<p>例如，创建了一个 cgroup 组名称为 <code>cgroups_1</code>。</p>
<div><pre><code><span>cgroup_parent</span><span>:</span> cgroups_1
</code></pre>
<div><span>1</span><br></div></div><h2 id="container-name"> <code>container_name</code></h2>
<p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>
<div><pre><code><span>container_name</span><span>:</span> docker<span>-</span>web<span>-</span>container
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p>
</blockquote>
<h2 id="deploy"> <code>deploy</code></h2>
<p>仅用于 <code>Swarm mode</code>，详细内容请查看 <a href="./../swarm_mode/"><code>Swarm mode</code></a> 一节</p>
<h2 id="devices"> <code>devices</code></h2>
<p>指定设备映射关系。</p>
<div><pre><code><span>devices</span><span>:</span>
  <span>-</span> <span>"/dev/ttyUSB1:/dev/ttyUSB0"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="depends-on"> <code>depends_on</code></h2>
<p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p>
<div><pre><code><span>version</span><span>:</span> <span>'3'</span>

<span>services</span><span>:</span>
  <span>web</span><span>:</span>
    <span>build</span><span>:</span> .
    <span>depends_on</span><span>:</span>
      <span>-</span> db
      <span>-</span> redis

  <span>redis</span><span>:</span>
    <span>image</span><span>:</span> redis

  <span>db</span><span>:</span>
    <span>image</span><span>:</span> postgres
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><blockquote>
<p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p>
</blockquote>
<h2 id="dns"> <code>dns</code></h2>
<p>自定义 <code>DNS</code> 服务器。可以是一个值，也可以是一个列表。</p>
<div><pre><code><span>dns</span><span>:</span> 8.8.8.8

<span>dns</span><span>:</span>
  <span>-</span> 8.8.8.8
  <span>-</span> 114.114.114.114
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="dns-search"> <code>dns_search</code></h2>
<p>配置 <code>DNS</code> 搜索域。可以是一个值，也可以是一个列表。</p>
<div><pre><code><span>dns_search</span><span>:</span> example.com

<span>dns_search</span><span>:</span>
  <span>-</span> domain1.example.com
  <span>-</span> domain2.example.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="tmpfs"> <code>tmpfs</code></h2>
<p>挂载一个 tmpfs 文件系统到容器。</p>
<div><pre><code><span>tmpfs</span><span>:</span> /run
<span>tmpfs</span><span>:</span>
  <span>-</span> /run
  <span>-</span> /tmp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="env-file"> <code>env_file</code></h2>
<p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>
<p>如果通过 <code>docker compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p>
<p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p>
<div><pre><code>env_file: .env

env_file:
  - ./common.env
  - ./apps/web.env
  - /opt/secrets.env
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>
<div><pre><code><span># common.env: Set development environment</span>
<span>PROG_ENV</span><span>=</span>development
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="environment"> <code>environment</code></h2>
<p>设置环境变量。你可以使用数组或字典两种格式。</p>
<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>
<div><pre><code><span>environment</span><span>:</span>
  <span>RACK_ENV</span><span>:</span> development
  <span>SESSION_SECRET</span><span>:</span>

<span>environment</span><span>:</span>
  <span>-</span> RACK_ENV=development
  <span>-</span> SESSION_SECRET
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="https://yaml.org/type/bool.html" target="_blank" rel="noopener noreferrer">布尔<i>Content not supported</i></a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<div><pre><code>y<span>|</span>Y<span>|</span><span>yes</span><span>|</span>Yes<span>|</span>YES<span>|</span>n<span>|</span>N<span>|</span>no<span>|</span>No<span>|</span>NO<span>|</span><span>true</span><span>|</span>True<span>|</span>TRUE<span>|</span><span>false</span><span>|</span>False<span>|</span>FALSE<span>|</span>on<span>|</span>On<span>|</span>ON<span>|</span>off<span>|</span>Off<span>|</span>OFF
</code></pre>
<div><span>1</span><br></div></div><h2 id="expose"> <code>expose</code></h2>
<p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p>
<p>仅可以指定内部端口为参数</p>
<div><pre><code><span>expose</span><span>:</span>
 <span>-</span> <span>"3000"</span>
 <span>-</span> <span>"8000"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="external-links"> <code>external_links</code></h2>
<blockquote>
<p>注意：不建议使用该指令。</p>
</blockquote>
<p>链接到 <code>docker-compose.yml</code> 外部的容器，甚至并非 <code>Compose</code> 管理的外部容器。</p>
<div><pre><code><span>external_links</span><span>:</span>
 <span>-</span> redis_1
 <span>-</span> project_db_1<span>:</span>mysql
 <span>-</span> project_db_1<span>:</span>postgresql
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="extra-hosts"> <code>extra_hosts</code></h2>
<p>类似 Docker 中的 <code>--add-host</code> 参数，指定额外的 host 名称映射信息。</p>
<div><pre><code><span>extra_hosts</span><span>:</span>
 <span>-</span> <span>"googledns:8.8.8.8"</span>
 <span>-</span> <span>"dockerhub:52.1.157.61"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加如下两条条目。</p>
<div><pre><code><span>8.8</span>.8.8 googledns
<span>52.1</span>.157.61 dockerhub
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="healthcheck"> <code>healthcheck</code></h2>
<p>通过命令检查容器是否健康运行。</p>
<div><pre><code><span>healthcheck</span><span>:</span>
  <span>test</span><span>:</span> <span>[</span><span>"CMD"</span><span>,</span> <span>"curl"</span><span>,</span> <span>"-f"</span><span>,</span> <span>"http://localhost"</span><span>]</span>
  <span>interval</span><span>:</span> 1m30s
  <span>timeout</span><span>:</span> 10s
  <span>retries</span><span>:</span> <span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="image"> <code>image</code></h2>
<p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>
<div><pre><code><span>image</span><span>:</span> ubuntu
<span>image</span><span>:</span> orchardup/postgresql
<span>image</span><span>:</span> a4bc65fd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="labels"> <code>labels</code></h2>
<p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p>
<div><pre><code><span>labels</span><span>:</span>
  <span>com.startupteam.description</span><span>:</span> <span>"webapp for a startup team"</span>
  <span>com.startupteam.department</span><span>:</span> <span>"devops department"</span>
  <span>com.startupteam.release</span><span>:</span> <span>"rc3 for v1.0"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="links"> <code>links</code></h2>
<blockquote>
<p>注意：不推荐使用该指令。</p>
</blockquote>
<h2 id="logging"> <code>logging</code></h2>
<p>配置日志选项。</p>
<div><pre><code><span>logging</span><span>:</span>
  <span>driver</span><span>:</span> syslog
  <span>options</span><span>:</span>
    <span>syslog-address</span><span>:</span> <span>"tcp://192.168.0.42:123"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>目前支持三种日志驱动类型。</p>
<div><pre><code><span>driver</span><span>:</span> <span>"json-file"</span>
<span>driver</span><span>:</span> <span>"syslog"</span>
<span>driver</span><span>:</span> <span>"none"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>options</code> 配置日志驱动的相关参数。</p>
<div><pre><code><span>options</span><span>:</span>
  <span>max-size</span><span>:</span> <span>"200k"</span>
  <span>max-file</span><span>:</span> <span>"10"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="network-mode"> <code>network_mode</code></h2>
<p>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p>
<div><pre><code><span>network_mode</span><span>:</span> <span>"bridge"</span>
<span>network_mode</span><span>:</span> <span>"host"</span>
<span>network_mode</span><span>:</span> <span>"none"</span>
<span>network_mode</span><span>:</span> <span>"service:[service name]"</span>
<span>network_mode</span><span>:</span> <span>"container:[container name/id]"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="networks"> <code>networks</code></h2>
<p>配置容器连接的网络。</p>
<div><pre><code><span>version</span><span>:</span> <span>"3"</span>
<span>services</span><span>:</span>

  <span>some-service</span><span>:</span>
    <span>networks</span><span>:</span>
     <span>-</span> some<span>-</span>network
     <span>-</span> other<span>-</span>network

<span>networks</span><span>:</span>
  <span>some-network</span><span>:</span>
  <span>other-network</span><span>:</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="pid"> <code>pid</code></h2>
<p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p>
<div><pre><code><span>pid</span><span>:</span> <span>"host"</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="ports"> <code>ports</code></h2>
<p>暴露端口信息。</p>
<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<div><pre><code><span>ports</span><span>:</span>
 <span>-</span> <span>"3000"</span>
 <span>-</span> <span>"8000:8000"</span>
 <span>-</span> <span>"49100:22"</span>
 <span>-</span> <span>"127.0.0.1:8001:8001"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p>
<h2 id="secrets"> <code>secrets</code></h2>
<p>存储敏感数据，例如 <code>mysql</code> 服务密码。</p>
<div><pre><code><span>version</span><span>:</span> <span>"3.1"</span>
<span>services</span><span>:</span>

<span>mysql</span><span>:</span>
  <span>image</span><span>:</span> mysql
  <span>environment</span><span>:</span>
    <span>MYSQL_ROOT_PASSWORD_FILE</span><span>:</span> /run/secrets/db_root_password
  <span>secrets</span><span>:</span>
    <span>-</span> db_root_password
    <span>-</span> my_other_secret

<span>secrets</span><span>:</span>
  <span>my_secret</span><span>:</span>
    <span>file</span><span>:</span> ./my_secret.txt
  <span>my_other_secret</span><span>:</span>
    <span>external</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="security-opt"> <code>security_opt</code></h2>
<p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p>
<div><pre><code><span>security_opt</span><span>:</span>
    <span>-</span> label<span>:</span>user<span>:</span>USER
    <span>-</span> label<span>:</span>role<span>:</span>ROLE
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="stop-signal"> <code>stop_signal</code></h2>
<p>设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。</p>
<div><pre><code><span>stop_signal</span><span>:</span> SIGUSR1
</code></pre>
<div><span>1</span><br></div></div><h2 id="sysctls"> <code>sysctls</code></h2>
<p>配置容器内核参数。</p>
<div><pre><code><span>sysctls</span><span>:</span>
  <span>net.core.somaxconn</span><span>:</span> <span>1024</span>
  <span>net.ipv4.tcp_syncookies</span><span>:</span> <span>0</span>

<span>sysctls</span><span>:</span>
  <span>-</span> net.core.somaxconn=1024
  <span>-</span> net.ipv4.tcp_syncookies=0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="ulimits"> <code>ulimits</code></h2>
<p>指定容器的 ulimits 限制值。</p>
<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>
<div><pre><code>  <span>ulimits</span><span>:</span>
    <span>nproc</span><span>:</span> <span>65535</span>
    <span>nofile</span><span>:</span>
      <span>soft</span><span>:</span> <span>20000</span>
      <span>hard</span><span>:</span> <span>40000</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="volumes"> <code>volumes</code></h2>
<p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p>
<p>该指令中路径支持相对路径。</p>
<div><pre><code><span>volumes</span><span>:</span>
 <span>-</span> /var/lib/mysql
 <span>-</span> cache/<span>:</span>/tmp/cache
 <span>-</span> ~/configs<span>:</span>/etc/configs/<span>:</span>ro
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>
<div><pre><code><span>version</span><span>:</span> <span>"3"</span>

<span>services</span><span>:</span>
  <span>my_src</span><span>:</span>
    <span>image</span><span>:</span> mysql<span>:</span><span>8.0</span>
    <span>volumes</span><span>:</span>
      <span>-</span> mysql_data<span>:</span>/var/lib/mysql

<span>volumes</span><span>:</span>
  <span>mysql_data</span><span>:</span>  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="其它指令"> 其它指令</h2>
<p>此外，还有包括 <code>domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code> 等指令，基本跟 <code>docker run</code> 中对应参数的功能一致。</p>
<p>指定服务容器启动后执行的入口文件。</p>
<div><pre><code><span>entrypoint</span><span>:</span> /code/entrypoint.sh
</code></pre>
<div><span>1</span><br></div></div><p>指定容器中运行应用的用户名。</p>
<div><pre><code><span>user</span><span>:</span> nginx
</code></pre>
<div><span>1</span><br></div></div><p>指定容器中工作目录。</p>
<div><pre><code><span>working_dir</span><span>:</span> /code
</code></pre>
<div><span>1</span><br></div></div><p>指定容器中搜索域名、主机名、mac 地址等。</p>
<div><pre><code><span>domainname</span><span>:</span> your_website.com
<span>hostname</span><span>:</span> test
<span>mac_address</span><span>:</span> 08<span>-</span>00<span>-</span>27<span>-</span>00<span>-</span>0C<span>-</span>0A
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>允许容器中运行一些特权命令。</p>
<div><pre><code><span>privileged</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br></div></div><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p>
<div><pre><code><span>restart</span><span>:</span> always
</code></pre>
<div><span>1</span><br></div></div><p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p>
<div><pre><code><span>read_only</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br></div></div><p>打开标准输入，可以接受外部输入。</p>
<div><pre><code><span>stdin_open</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br></div></div><p>模拟一个伪终端。</p>
<div><pre><code><span>tty</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="读取变量"> 读取变量</h2>
<p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。</p>
<p>例如，下面的 Compose 文件将从运行它的环境中读取变量 <code>${MONGO_VERSION}</code> 的值，并写入执行的指令中。</p>
<div><pre><code><span>version</span><span>:</span> <span>"3"</span>
<span>services</span><span>:</span>

<span>db</span><span>:</span>
  <span>image</span><span>:</span> <span>"mongo:${MONGO_VERSION}"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果执行 <code>MONGO_VERSION=3.2 docker compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；如果执行 <code>MONGO_VERSION=2.8 docker compose up</code> 则会启动一个 <code>mongo:2.8</code> 镜像的容器。</p>
<p>若当前目录存在 <code>.env</code> 文件，执行 <code>docker compose</code> 命令时将从该文件中读取变量。</p>
<p>在当前目录新建 <code>.env</code> 文件并写入以下内容。</p>
<div><pre><code><span># 支持 # 号注释</span>
<span>MONGO_VERSION</span><span>=</span><span>3.6</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>执行 <code>docker compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener noreferrer">官方文档<i>Content not supported</i></a></li>
<li><a href="https://github.com/docker/awesome-compose" target="_blank" rel="noopener noreferrer">awesome-compose<i>Content not supported</i></a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>使用 Django</title>
      <link>https://vuepress.mirror.docker-practice.com/compose/django/</link>
      <guid>https://vuepress.mirror.docker-practice.com/compose/django/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">使用 Django</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="使用-django"> 使用 Django</h1>
<i>Content not supported</i>
<blockquote>
<p>本小节内容适合 <code>Python</code> 开发人员阅读。</p>
</blockquote>
<p>我们现在将使用 <code>Docker Compose</code> 配置并运行一个 <code>Django/PostgreSQL</code> 应用。</p>
<p>在一切工作开始前，需要先编辑好三个必要的文件。</p>
<p>第一步，因为应用将要运行在一个满足所有环境依赖的 Docker 容器里面，那么我们可以通过编辑 <code>Dockerfile</code> 文件来指定 Docker 容器要安装内容。内容如下：</p>
<div><pre><code><span><span>FROM</span> python:3</span>
<span><span>ENV</span> PYTHONUNBUFFERED 1</span>
<span><span>RUN</span> mkdir /code</span>
<span><span>WORKDIR</span> /code</span>
<span><span>COPY</span> requirements.txt /code/</span>
<span><span>RUN</span> pip install -r requirements.txt</span>
<span><span>COPY</span> . /code/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>以上内容指定应用将使用安装了 Python 以及必要依赖包的镜像。更多关于如何编写 <code>Dockerfile</code> 文件的信息可以查看 <a href="./../image/dockerfile/"> Dockerfile 使用</a>。</p>
<p>第二步，在 <code>requirements.txt</code> 文件里面写明需要安装的具体依赖包名。</p>
<div><pre><code>Django<span>>=</span><span>2.0</span>,<span>&lt;</span><span>3.0</span>
psycopg<span><span>2</span>></span><span>=</span><span>2.7</span>,<span>&lt;</span><span>3.0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>第三步，<code>docker-compose.yml</code> 文件将把所有的东西关联起来。它描述了应用的构成（一个 web 服务和一个数据库）、使用的 Docker 镜像、镜像之间的连接、挂载到容器的卷，以及服务开放的端口。</p>
<div><pre><code><span>version</span><span>:</span> <span>"3"</span>
<span>services</span><span>:</span>

  <span>db</span><span>:</span>
    <span>image</span><span>:</span> postgres
    <span>environment</span><span>:</span>
      <span>POSTGRES_PASSWORD</span><span>:</span> <span>'postgres'</span>

  <span>web</span><span>:</span>
    <span>build</span><span>:</span> .
    <span>command</span><span>:</span> python manage.py runserver 0.0.0.0<span>:</span><span>8000</span>
    <span>volumes</span><span>:</span>
      <span>-</span> .<span>:</span>/code
    <span>ports</span><span>:</span>
      <span>-</span> <span>"8000:8000"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>查看 <a href="./compose_file.html"><code>docker-compose.yml</code> 章节</a> 了解更多详细的工作机制。</p>
<p>现在我们就可以使用 <code>docker compose run</code> 命令启动一个 <code>Django</code> 应用了。</p>
<div><pre><code>$ <span>docker</span> compose run web django-admin startproject django_example <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>由于 web 服务所使用的镜像并不存在，所以 Compose 会首先使用 <code>Dockerfile</code> 为 web 服务构建一个镜像，接着使用这个镜像在容器里运行 <code>django-admin startproject django_example</code> 指令。</p>
<p>这将在当前目录生成一个 <code>Django</code> 应用。</p>
<div><pre><code>$ <span>ls</span>
Dockerfile       docker-compose.yml          django_example       manage.py       requirements.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果你的系统是 Linux,记得更改文件权限。</p>
<div><pre><code>$ <span>sudo</span> <span>chown</span> -R <span>$USER</span><span>:</span><span>$USER</span> <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>首先，我们要为应用设置好数据库的连接信息。用以下内容替换 <code>django_example/settings.py</code> 文件中 <code>DATABASES = ...</code> 定义的节点内容。</p>
<div><pre><code>DATABASES <span>=</span> <span>{</span>
    <span>'default'</span><span>:</span> <span>{</span>
        <span>'ENGINE'</span><span>:</span> <span>'django.db.backends.postgresql'</span><span>,</span>
        <span>'NAME'</span><span>:</span> <span>'postgres'</span><span>,</span>
        <span>'USER'</span><span>:</span> <span>'postgres'</span><span>,</span>
        <span>'HOST'</span><span>:</span> <span>'db'</span><span>,</span>
        <span>'PORT'</span><span>:</span> <span>5432</span><span>,</span>
        <span>'PASSWORD'</span><span>:</span> <span>'postgres'</span><span>,</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这些信息是在 <a href="https://hub.docker.com/_/postgres/" target="_blank" rel="noopener noreferrer">postgres<i>Content not supported</i></a> 镜像固定设置好的。然后，运行 <code>docker compose up</code> ：</p>
<div><pre><code>$ <span>docker</span> compose up

django_db_1 is up-to-date
Creating django_web_1 <span>..</span>.
Creating django_web_1 <span>..</span>. <span>done</span>
Attaching to django_db_1, django_web_1
db_1   <span>|</span> The files belonging to this database system will be owned by user <span>"postgres"</span><span>.</span>
db_1   <span>|</span> This user must also own the server process.
db_1   <span>|</span>
db_1   <span>|</span> The database cluster will be initialized with locale <span>"en_US.utf8"</span><span>.</span>
db_1   <span>|</span> The default database encoding has accordingly been <span>set</span> to <span>"UTF8"</span><span>.</span>
db_1   <span>|</span> The default text search configuration will be <span>set</span> to <span>"english"</span><span>.</span>

web_1  <span>|</span> Performing system checks<span>..</span>.
web_1  <span>|</span>
web_1  <span>|</span> System check identified no issues <span>(</span><span>0</span> silenced<span>)</span>.
web_1  <span>|</span>
web_1  <span>|</span> November <span>23</span>, <span>2017</span> - 06:21:19
web_1  <span>|</span> Django version <span>1.11</span>.7, using settings <span>'django_example.settings'</span>
web_1  <span>|</span> Starting development server at http://0.0.0.0:8000/
web_1  <span>|</span> Quit the server with CONTROL-C.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>这个 <code>Django</code> 应用已经开始在你的 Docker 守护进程里监听着 <code>8000</code> 端口了。打开 <code>127.0.0.1:8000</code> 即可看到 <code>Django</code> 欢迎页面。</p>
<p>你还可以在 Docker 上运行其它的管理命令，例如对于同步数据库结构这种事，在运行完 <code>docker compose up</code> 后，在另外一个终端进入文件夹运行以下命令即可：</p>
<div><pre><code>$ <span>docker</span> compose run web python manage.py syncdb
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>安装与卸载</title>
      <link>https://vuepress.mirror.docker-practice.com/compose/install/</link>
      <guid>https://vuepress.mirror.docker-practice.com/compose/install/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">安装与卸载</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="安装与卸载"> 安装与卸载</h1>
<i>Content not supported</i>
<p><code>Compose</code> 支持 Linux、macOS、Windows 三大平台。</p>
<p><code>Docker Desktop for Mac/Windows</code> 自带 <code>compose</code>，安装 Docker 之后可以直接使用。</p>
<div><pre><code>$ <span>docker</span> compose version

Docker Compose version v2.6.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Linux 系统请使用以下介绍的方法安装。</p>
<h2 id="二进制包"> 二进制包</h2>
<p>在 Linux 上的也安装十分简单，从 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener noreferrer">官方 GitHub Release<i>Content not supported</i></a> 处直接下载编译好的二进制文件即可。</p>
<p>例如，在 Linux 64 位系统上直接下载对应的二进制包。</p>
<div><pre><code>$ <span>DOCKER_CONFIG</span><span>=</span>/usr/local/lib/docker/cli-plugins
$ <span>sudo</span> <span>mkdir</span> -p <span>$DOCKER_CONFIG</span>/cli-plugins
$ <span>sudo</span> <span>curl</span> -SL https://github.com/docker/compose/releases/download/v2.6.1/docker-compose-linux-x86_64 -o <span>$DOCKER_CONFIG</span>/cli-plugins/docker-compose
$ <span>sudo</span> <span>chmod</span> +x <span>$DOCKER_CONFIG</span>/cli-plugins
$ <span>docker</span> compose version

<span># 国内用户可以使用以下方式加快下载</span>
$ <span>sudo</span> <span>curl</span> -SL https://download.fastgit.org/docker/compose/releases/download/v2.6.1/docker-compose-linux-x86_64 -o <span>$DOCKER_CONFIG</span>/cli-plugins/docker-compose
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Compose 简介</title>
      <link>https://vuepress.mirror.docker-practice.com/compose/introduction/</link>
      <guid>https://vuepress.mirror.docker-practice.com/compose/introduction/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Compose 简介</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="compose-简介"> Compose 简介</h1>
<i>Content not supported</i>
<p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p>
<p>其代码目前在 <a href="https://github.com/docker/compose" target="_blank" rel="noopener noreferrer">https://github.com/docker/compose<i>Content not supported</i></a> 上开源。</p>
<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>
<p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>
<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li>
<p>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</p>
</li>
<li>
<p>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</p>
</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>
]]></content:encoded>
    </item>
    <item>
      <title>使用 compose 搭建 LNMP 环境</title>
      <link>https://vuepress.mirror.docker-practice.com/compose/lnmp/</link>
      <guid>https://vuepress.mirror.docker-practice.com/compose/lnmp/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">使用 compose 搭建 LNMP 环境</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="使用-compose-搭建-lnmp-环境"> 使用 compose 搭建 LNMP 环境</h1>
<i>Content not supported</i>
<p>本项目的维护者 <a href="https://github.com/khs1994" target="_blank" rel="noopener noreferrer">khs1994<i>Content not supported</i></a> 的开源项目 <a href="https://github.com/khs1994-docker/lnmp" target="_blank" rel="noopener noreferrer">khs1994-docker/lnmp<i>Content not supported</i></a> 使用 Docker Compose 搭建了一套 LNMP 环境，各位开发者可以参考该项目在 Docker 或 Kubernetes 中运行 LNMP。</p>
]]></content:encoded>
    </item>
    <item>
      <title>使用 Rails</title>
      <link>https://vuepress.mirror.docker-practice.com/compose/rails/</link>
      <guid>https://vuepress.mirror.docker-practice.com/compose/rails/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">使用 Rails</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="使用-rails"> 使用 Rails</h1>
<i>Content not supported</i>
<blockquote>
<p>本小节内容适合 <code>Ruby</code> 开发人员阅读。</p>
</blockquote>
<p>我们现在将使用 <code>Compose</code> 配置并运行一个 <code>Rails/PostgreSQL</code> 应用。</p>
<p>在一切工作开始前，需要先设置好三个必要的文件。</p>
<p>首先，因为应用将要运行在一个满足所有环境依赖的 Docker 容器里面，那么我们可以通过编辑 <code>Dockerfile</code> 文件来指定 Docker 容器要安装内容。内容如下：</p>
<div><pre><code><span><span>FROM</span> ruby</span>
<span><span>RUN</span> apt-get update -qq &amp;&amp; apt-get install -y build-essential libpq-dev</span>
<span><span>RUN</span> mkdir /myapp</span>
<span><span>WORKDIR</span> /myapp</span>
<span><span>ADD</span> Gemfile /myapp/Gemfile</span>
<span><span>RUN</span> bundle install</span>
<span><span>ADD</span> . /myapp</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>以上内容指定应用将使用安装了 Ruby、Bundler 以及其依赖件的镜像。更多关于如何编写 Dockerfile 文件的信息可以查看 <a href="./../image/dockerfile/">Dockerfile 使用</a>。</p>
<p>下一步，我们需要一个引导加载 Rails 的文件 <code>Gemfile</code> 。 等一会儿它还会被 <code>rails new</code> 命令覆盖重写。</p>
<div><pre><code><span>source</span> <span>'https://rubygems.org'</span>
gem <span>'rails'</span>, <span>'4.0.2'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>最后，<code>docker-compose.yml</code> 文件才是最神奇的地方。 <code>docker-compose.yml</code> 文件将把所有的东西关联起来。它描述了应用的构成（一个 web 服务和一个数据库）、每个镜像的来源（数据库运行在使用预定义的 PostgreSQL 镜像，web 应用侧将从本地目录创建）、镜像之间的连接，以及服务开放的端口。</p>
<div><pre><code><span>version</span><span>:</span> <span>"3"</span>
<span>services</span><span>:</span>

  <span>db</span><span>:</span>
    <span>image</span><span>:</span> postgres
    <span>ports</span><span>:</span>
      <span>-</span> <span>"5432"</span>

  <span>web</span><span>:</span>
    <span>build</span><span>:</span> .
    <span>command</span><span>:</span> bundle exec rackup <span>-</span>p 3000
    <span>volumes</span><span>:</span>
      <span>-</span> .<span>:</span>/myapp
    <span>ports</span><span>:</span>
      <span>-</span> <span>"3000:3000"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>所有文件就绪后，我们就可以通过使用 <code>docker compose run</code> 命令生成应用的骨架了。</p>
<div><pre><code>$ <span>docker</span> compose run web rails new <span>.</span> --force --database<span>=</span>postgresql --skip-bundle
</code></pre>
<div><span>1</span><br></div></div><p><code>Compose</code> 会先使用 <code>Dockerfile</code> 为 web 服务创建一个镜像，接着使用这个镜像在容器里运行 <code>rails new</code> 和它之后的命令。一旦这个命令运行完后，应该就可以看一个崭新的应用已经生成了。</p>
<div><pre><code>$ <span>ls</span>
Dockerfile   app          docker-compose.yml      tmp
Gemfile      bin          lib          vendor
Gemfile.lock condocker-compose       log
README.rdoc  condocker-compose.ru    public
Rakefile     db           <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在新的 <code>Gemfile</code> 文件去掉加载 <code>therubyracer</code> 的行的注释，这样我们便可以使用 Javascript 运行环境：</p>
<div><pre><code>gem <span>'therubyracer'</span>, platforms: :ruby
</code></pre>
<div><span>1</span><br></div></div><p>现在我们已经有一个新的 <code>Gemfile</code> 文件，需要再重新创建镜像。（这个会步骤会改变 Dockerfile 文件本身，所以需要重建一次）。</p>
<div><pre><code>$ <span>docker</span> compose build
</code></pre>
<div><span>1</span><br></div></div><p>应用现在就可以启动了，但配置还未完成。Rails 默认读取的数据库目标是 <code>localhost</code> ，我们需要手动指定容器的 <code>db</code> 。同样的，还需要把用户名修改成和 postgres 镜像预定的一致。
打开最新生成的 <code>database.yml</code> 文件。用以下内容替换：</p>
<div><pre><code>development: <span>&amp;</span>default
  adapter: postgresql
  encoding: unicode
  database: postgres
  pool: <span>5</span>
  username: postgres
  password:
  host: db

test:
  <span>&lt;&lt;</span>: *default
  database: myapp_test
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>现在就可以启动应用了。</p>
<div><pre><code>$ <span>docker</span> compose up
</code></pre>
<div><span>1</span><br></div></div><p>如果一切正常，你应该可以看到 PostgreSQL 的输出，几秒后可以看到这样的重复信息：</p>
<div><pre><code>myapp_web_1 <span>|</span> <span>[</span><span>2014</span>-01-17 <span>17</span>:16:29<span>]</span> INFO  WEBrick <span>1.3</span>.1
myapp_web_1 <span>|</span> <span>[</span><span>2014</span>-01-17 <span>17</span>:16:29<span>]</span> INFO  ruby <span>2.0</span>.0 <span>(</span><span>2013</span>-11-22<span>)</span> <span>[</span>x86_64-linux-gnu<span>]</span>
myapp_web_1 <span>|</span> <span>[</span><span>2014</span>-01-17 <span>17</span>:16:29<span>]</span> INFO  WEBrick::HTTPServer<span>#start: pid=1 port=3000</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>最后， 我们需要做的是创建数据库，打开另一个终端，运行：</p>
<div><pre><code>$ <span>docker</span> compose run web rake db:create
</code></pre>
<div><span>1</span><br></div></div><p>这个 web 应用已经开始在你的 docker 守护进程里面监听着 3000 端口了。</p>
]]></content:encoded>
    </item>
    <item>
      <title>使用</title>
      <link>https://vuepress.mirror.docker-practice.com/compose/usage/</link>
      <guid>https://vuepress.mirror.docker-practice.com/compose/usage/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">使用</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="使用"> 使用</h1>
<i>Content not supported</i>
<h2 id="术语"> 术语</h2>
<p>首先介绍几个术语。</p>
<ul>
<li>
<p>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</p>
</li>
<li>
<p>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。</p>
</li>
</ul>
<p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p>
<h2 id="场景"> 场景</h2>
<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>
<p>下面我们用 <code>Python</code> 来建立一个能够记录页面访问次数的 web 网站。</p>
<h3 id="web-应用"> web 应用</h3>
<p>新建文件夹，在该目录中编写 <code>app.py</code> 文件</p>
<div><pre><code><span>from</span> flask <span>import</span> Flask
<span>from</span> redis <span>import</span> Redis

app <span>=</span> Flask<span>(</span>__name__<span>)</span>
redis <span>=</span> Redis<span>(</span>host<span>=</span><span>'redis'</span><span>,</span> port<span>=</span><span>6379</span><span>)</span>

<span>@app<span>.</span>route</span><span>(</span><span>'/'</span><span>)</span>
<span>def</span> <span>hello</span><span>(</span><span>)</span><span>:</span>
    count <span>=</span> redis<span>.</span>incr<span>(</span><span>'hits'</span><span>)</span>
    <span>return</span> <span>'Hello World! 该页面已被访问 {} 次。\n'</span><span>.</span><span>format</span><span>(</span>count<span>)</span>

<span>if</span> __name__ <span>==</span> <span>"__main__"</span><span>:</span>
    app<span>.</span>run<span>(</span>host<span>=</span><span>"0.0.0.0"</span><span>,</span> debug<span>=</span><span>True</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="dockerfile"> Dockerfile</h3>
<p>编写 <code>Dockerfile</code> 文件，内容为</p>
<div><pre><code><span><span>FROM</span> python:3.6-alpine</span>
<span><span>ADD</span> . /code</span>
<span><span>WORKDIR</span> /code</span>
<span><span>RUN</span> pip install redis flask</span>
<span><span>CMD</span> [<span>"python"</span>, <span>"app.py"</span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="docker-compose-yml"> docker-compose.yml</h3>
<p>编写 <code>docker-compose.yml</code> 文件，这个是 Compose 使用的主模板文件。</p>
<div><pre><code><span>version</span><span>:</span> <span>'3'</span>
<span>services</span><span>:</span>

  <span>web</span><span>:</span>
    <span>build</span><span>:</span> .
    <span>ports</span><span>:</span>
     <span>-</span> <span>"5000:5000"</span>

  <span>redis</span><span>:</span>
    <span>image</span><span>:</span> <span>"redis:alpine"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="运行-compose-项目"> 运行 compose 项目</h3>
<div><pre><code>$ <span>docker</span> compose up
</code></pre>
<div><span>1</span><br></div></div><p>此时访问本地 <code>5000</code> 端口，每次刷新页面，计数就会加 1。</p>
]]></content:encoded>
    </item>
    <item>
      <title>使用 WordPress</title>
      <link>https://vuepress.mirror.docker-practice.com/compose/wordpress/</link>
      <guid>https://vuepress.mirror.docker-practice.com/compose/wordpress/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">使用 WordPress</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="使用-wordpress"> 使用 WordPress</h1>
<i>Content not supported</i>
<blockquote>
<p>本小节内容适合 <code>PHP</code> 开发人员阅读。</p>
</blockquote>
<p><code>Compose</code> 可以很便捷的让 <code>Wordpress</code> 运行在一个独立的环境中。</p>
<h2 id="创建空文件夹"> 创建空文件夹</h2>
<p>假设新建一个名为 <code>wordpress</code> 的文件夹，然后进入这个文件夹。</p>
<h2 id="创建-docker-compose-yml-文件"> 创建 <code>docker-compose.yml</code> 文件</h2>
<p><a href="https://github.com/yeasy/docker_practice/blob/master/compose/demo/wordpress/docker-compose.yml" target="_blank" rel="noopener noreferrer"><code>docker-compose.yml</code><i>Content not supported</i></a> 文件将开启一个 <code>wordpress</code> 服务和一个独立的 <code>MySQL</code> 实例：</p>
<div><pre><code><span>version</span><span>:</span> <span>"3"</span>
<span>services</span><span>:</span>

   <span>db</span><span>:</span>
     <span>image</span><span>:</span> mysql<span>:</span><span>8.0</span>
     <span>command</span><span>:</span>
      <span>-</span> <span>-</span><span>-</span>default_authentication_plugin=mysql_native_password
      <span>-</span> <span>-</span><span>-</span>character<span>-</span>set<span>-</span>server=utf8mb4
      <span>-</span> <span>-</span><span>-</span>collation<span>-</span>server=utf8mb4_unicode_ci     
     <span>volumes</span><span>:</span>
       <span>-</span> db_data<span>:</span>/var/lib/mysql
     <span>restart</span><span>:</span> always
     <span>environment</span><span>:</span>
       <span>MYSQL_ROOT_PASSWORD</span><span>:</span> somewordpress
       <span>MYSQL_DATABASE</span><span>:</span> wordpress
       <span>MYSQL_USER</span><span>:</span> wordpress
       <span>MYSQL_PASSWORD</span><span>:</span> wordpress

   <span>wordpress</span><span>:</span>
     <span>depends_on</span><span>:</span>
       <span>-</span> db
     <span>image</span><span>:</span> wordpress<span>:</span>latest
     <span>ports</span><span>:</span>
       <span>-</span> <span>"8000:80"</span>
     <span>restart</span><span>:</span> always
     <span>environment</span><span>:</span>
       <span>WORDPRESS_DB_HOST</span><span>:</span> db<span>:</span><span>3306</span>
       <span>WORDPRESS_DB_USER</span><span>:</span> wordpress
       <span>WORDPRESS_DB_PASSWORD</span><span>:</span> wordpress
<span>volumes</span><span>:</span>
  <span>db_data</span><span>:</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h2 id="构建并运行项目"> 构建并运行项目</h2>
<p>运行 <code>docker compose up -d</code> Compose 就会拉取镜像再创建我们所需要的镜像，然后启动 <code>wordpress</code> 和数据库容器。 接着浏览器访问 <code>127.0.0.1:8000</code> 端口就能看到 <code>WordPress</code> 安装界面了。</p>
]]></content:encoded>
    </item>
    <item>
      <title>操作 Docker 容器</title>
      <link>https://vuepress.mirror.docker-practice.com/container/</link>
      <guid>https://vuepress.mirror.docker-practice.com/container/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">操作 Docker 容器</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="操作-docker-容器"> 操作 Docker 容器</h1>
<i>Content not supported</i>
<p>容器是 Docker 又一核心概念。</p>
<p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<p>本章将具体介绍如何来管理一个容器，包括创建、启动和停止等。</p>
]]></content:encoded>
    </item>
    <item>
      <title>进入容器</title>
      <link>https://vuepress.mirror.docker-practice.com/container/attach_exec/</link>
      <guid>https://vuepress.mirror.docker-practice.com/container/attach_exec/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">进入容器</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="进入容器"> 进入容器</h1>
<i>Content not supported</i>
<p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p>
<p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p>
<h2 id="attach-命令"> <code>attach</code> 命令</h2>
<p>下面示例如何使用 <code>docker attach</code> 命令。</p>
<div><pre><code>$ <span>docker</span> run -dit ubuntu
243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550

$ <span>docker</span> container <span>ls</span>
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
243c32535da7        ubuntu:latest       <span>"/bin/bash"</span>         <span>18</span> seconds ago      Up <span>17</span> seconds                           nostalgic_hypatia

$ <span>docker</span> attach 243c
root@243c32535da7:/<span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p>
<h2 id="exec-命令"> <code>exec</code> 命令</h2>
<h3 id="i-t-参数"> <code>-i</code> <code>-t</code> 参数</h3>
<p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
<div><pre><code>$ <span>docker</span> run -dit ubuntu
69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6

$ <span>docker</span> container <span>ls</span>
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
69d137adef7a        ubuntu:latest       <span>"/bin/bash"</span>         <span>18</span> seconds ago      Up <span>17</span> seconds                           zealous_swirles

$ <span>docker</span> <span>exec</span> -i 69d1 <span>bash</span>
<span>ls</span>
bin
boot
dev
<span>..</span>.

$ <span>docker</span> <span>exec</span> -it 69d1 <span>bash</span>
root@69d137adef7a:/<span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p>
<p>更多参数说明请使用 <code>docker exec --help</code> 查看。</p>
]]></content:encoded>
    </item>
    <item>
      <title>后台运行</title>
      <link>https://vuepress.mirror.docker-practice.com/container/daemon/</link>
      <guid>https://vuepress.mirror.docker-practice.com/container/daemon/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">后台运行</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="后台运行"> 后台运行</h1>
<i>Content not supported</i>
<p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p>
<p>下面举两个例子来说明一下。</p>
<p>如果不使用 <code>-d</code> 参数运行容器。</p>
<div><pre><code>$ <span>docker</span> run ubuntu:18.04 /bin/sh -c <span>"while true; do echo hello world; sleep 1; done"</span>
hello world
hello world
hello world
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p>
<p>如果使用了 <code>-d</code> 参数运行容器。</p>
<div><pre><code>$ <span>docker</span> run -d ubuntu:18.04 /bin/sh -c <span>"while true; do echo hello world; sleep 1; done"</span>
77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p>
<p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p>
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p>
<div><pre><code>$ docker container ls
CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES
77b2dc01fe0f  ubuntu:18.04  /bin/sh -c &#39;while tr  2 minutes ago  Up 1 minute        agitated_wright
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p>
<div><pre><code>$ <span>docker</span> container logs <span>[</span>container ID or NAMES<span>]</span>
hello world
hello world
hello world
<span>.</span> <span>.</span> <span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>导出和导入容器</title>
      <link>https://vuepress.mirror.docker-practice.com/container/import_export/</link>
      <guid>https://vuepress.mirror.docker-practice.com/container/import_export/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">导出和导入容器</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="导出和导入容器"> 导出和导入容器</h1>
<i>Content not supported</i>
<h2 id="导出容器"> 导出容器</h2>
<p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p>
<div><pre><code>$ <span>docker</span> container <span>ls</span> -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES
7691a814370e        ubuntu:18.04        <span>"/bin/bash"</span>         <span>36</span> hours ago        Exited <span>(</span><span>0</span><span>)</span> <span>21</span> hours ago                       <span>test</span>
$ <span>docker</span> <span>export</span> 7691a814370e <span>></span> ubuntu.tar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这样将导出容器快照到本地文件。</p>
<h2 id="导入容器快照"> 导入容器快照</h2>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p>
<div><pre><code>$ <span>cat</span> ubuntu.tar <span>|</span> <span>docker</span> <span>import</span> - test/ubuntu:v1.0
$ <span>docker</span> image <span>ls</span>
REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE
test/ubuntu         v1.0                9d37a6082e97        About a minute ago   <span>171.3</span> MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p>
<div><pre><code>$ <span>docker</span> <span>import</span> http://example.com/exampleimage.tgz example/imagerepo
</code></pre>
<div><span>1</span><br></div></div><p><em>注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p>
]]></content:encoded>
    </item>
    <item>
      <title>删除容器</title>
      <link>https://vuepress.mirror.docker-practice.com/container/rm/</link>
      <guid>https://vuepress.mirror.docker-practice.com/container/rm/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">删除容器</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="删除容器"> 删除容器</h1>
<i>Content not supported</i>
<p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p>
<div><pre><code>$ <span>docker</span> container <span>rm</span> trusting_newton
trusting_newton
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p>
<h1 id="清理所有处于终止状态的容器"> 清理所有处于终止状态的容器</h1>
<p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<div><pre><code>$ <span>docker</span> container prune
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>启动容器</title>
      <link>https://vuepress.mirror.docker-practice.com/container/run/</link>
      <guid>https://vuepress.mirror.docker-practice.com/container/run/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">启动容器</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="启动容器"> 启动容器</h1>
<i>Content not supported</i>
<p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h2 id="新建并启动"> 新建并启动</h2>
<p>所需要的命令主要为 <code>docker run</code>。</p>
<p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p>
<div><pre><code>$ <span>docker</span> run ubuntu:18.04 /bin/echo <span>'Hello world'</span>
Hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这跟在本地直接执行 <code>/bin/echo 'hello world'</code> 几乎感觉不出任何区别。</p>
<p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p>
<div><pre><code>$ <span>docker</span> run -t -i ubuntu:18.04 /bin/bash
root@af8bae53bdd3:/<span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p>
<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p>
<div><pre><code>root@af8bae53bdd3:/<span># pwd</span>
/
root@af8bae53bdd3:/<span># ls</span>
bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从 <a href="./../repository/">registry</a> 下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h2 id="启动已终止容器"> 启动已终止容器</h2>
<p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p>
<div><pre><code>root@ba267838cc1b:/<span># ps</span>
  PID TTY          TIME CMD
    <span>1</span> ?        00:00:00 <span>bash</span>
   <span>11</span> ?        00:00:00 <span>ps</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p>
]]></content:encoded>
    </item>
    <item>
      <title>终止容器</title>
      <link>https://vuepress.mirror.docker-practice.com/container/stop/</link>
      <guid>https://vuepress.mirror.docker-practice.com/container/stop/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">终止容器</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="终止容器"> 终止容器</h1>
<i>Content not supported</i>
<p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p>
<p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p>
<p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p>
<div><pre><code>$ <span>docker</span> container <span>ls</span> -a
CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES
ba267838cc1b        ubuntu:18.04             <span>"/bin/bash"</span>            <span>30</span> minutes ago      Exited <span>(</span><span>0</span><span>)</span> About a minute ago                       trusting_newton
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p>
<p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Fedora CoreOS</title>
      <link>https://vuepress.mirror.docker-practice.com/coreos/</link>
      <guid>https://vuepress.mirror.docker-practice.com/coreos/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Fedora CoreOS</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="fedora-coreos"> Fedora CoreOS</h1>
<i>Content not supported</i>
<p><code>CoreOS</code> 是一个专门为安全和大规模运行容器化工作负载而构建的新 Fedora 版本，它继承了 Fedora Atomic Host 和 CoreOS Container Linux 的优势。</p>
<p><code>CoreOS</code> 的安装文件和运行依赖非常小，它提供了精简的 Linux 系统。它使用 Linux 容器在更高的抽象层来管理你的服务，而不是通过常规的包管理工具 <code>yum</code> 或 <code>apt</code> 来安装包。</p>
<p>同时，<code>CoreOS</code> 几乎可以运行在任何平台：<code>VirtualBox</code> <code>Amazon EC2</code> <code>QEMU/KVM</code> <code>VMware</code> <code>Bare Metal</code> 和 <code>OpenStack</code> 等 。</p>
]]></content:encoded>
    </item>
    <item>
      <title>安装 Fedora CoreOS</title>
      <link>https://vuepress.mirror.docker-practice.com/coreos/install/</link>
      <guid>https://vuepress.mirror.docker-practice.com/coreos/install/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">安装 Fedora CoreOS</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="安装-fedora-coreos"> 安装 Fedora CoreOS</h1>
<i>Content not supported</i>
<h2 id="下载-iso"> 下载 ISO</h2>
<p>在 <a href="https://getfedora.org/coreos/download/" target="_blank" rel="noopener noreferrer">下载页面<i>Content not supported</i></a> <code>Bare Metal &amp; Virtualized</code> 标签页下载 ISO。</p>
<h2 id="编写-fcc"> 编写 FCC</h2>
<p>FCC 是 Fedora CoreOS Configuration （Fedora CoreOS 配置）的简称。</p>
<div><pre><code><span># example.fcc</span>
<span>variant</span><span>:</span> fcos
<span>version</span><span>:</span> 1.0.0
<span>passwd</span><span>:</span>
  <span>users</span><span>:</span>
    <span>-</span> <span>name</span><span>:</span> core
      <span>ssh_authorized_keys</span><span>:</span>
        <span>-</span> ssh<span>-</span>rsa AAAA<span>...</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>将 <code>ssh-rsa AAAA...</code> 替换为自己的 SSH 公钥（位于 <code>~/.ssh/id_rsa.pub</code>）。</p>
<h2 id="转换-fcc-为-ignition"> 转换 FCC 为 Ignition</h2>
<div><pre><code>$ <span>docker</span> run -i --rm quay.io/coreos/fcct:v0.5.0 --pretty --strict <span>&lt;</span> example.fcc <span>></span> example.ign
</code></pre>
<div><span>1</span><br></div></div><h2 id="挂载-iso-启动虚拟机并安装"> 挂载 ISO 启动虚拟机并安装</h2>
<blockquote>
<p>虚拟机需要分配 3GB 以上内存，否则会无法启动。</p>
</blockquote>
<p>在虚拟机终端执行以下命令安装：</p>
<div><pre><code>$ <span>sudo</span> coreos-installer <span>install</span> /dev/sda --ignition-file example.ign
</code></pre>
<div><span>1</span><br></div></div><p>安装之后重新启动即可使用。</p>
<h2 id="使用"> 使用</h2>
<div><pre><code>$ <span>ssh</span> core@虚拟机IP

$ <span>docker</span> --version
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://docs.fedoraproject.org/en-US/fedora-coreos/bare-metal/" target="_blank" rel="noopener noreferrer">官方文档<i>Content not supported</i></a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Fedora CoreOS 介绍</title>
      <link>https://vuepress.mirror.docker-practice.com/coreos/intro/</link>
      <guid>https://vuepress.mirror.docker-practice.com/coreos/intro/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Fedora CoreOS 介绍</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="fedora-coreos-介绍"> Fedora CoreOS 介绍</h1>
<i>Content not supported</i>
<p><a href="https://getfedora.org/coreos/" target="_blank" rel="noopener noreferrer">Fedora CoreOS<i>Content not supported</i></a> 是一个自动更新的，最小的，整体的，以容器为中心的操作系统，不仅适用于集群，而且可独立运行，并针对运行 Kubernetes 进行了优化。它旨在结合 CoreOS Container Linux 和 Fedora Atomic Host 的优点，将 Container Linux 中的 <a href="https://github.com/coreos/ignition" target="_blank" rel="noopener noreferrer">Ignition<i>Content not supported</i></a> 与 <a href="https://github.com/coreos/rpm-ostree" target="_blank" rel="noopener noreferrer">rpm-ostree<i>Content not supported</i></a> 和 Project Atomic 中的 SELinux 强化等技术相集成。其目标是提供最佳的容器主机，以安全，大规模地运行容器化的工作负载。</p>
<h2 id="fcos-特性"> FCOS 特性</h2>
<h3 id="一个最小化操作系统"> 一个最小化操作系统</h3>
<p>FCOS 被设计成一个基于容器的最小化的现代操作系统。它比现有的 Linux 安装平均节省 40% 的 RAM（大约 114M ）并允许从 PXE 或 iPXE 非常快速的启动。</p>
<h3 id="系统初始化"> 系统初始化</h3>
<p>Ignition 是一种配置实用程序，可读取配置文件（JSON 格式）并根据该配置配置 FCOS 系统。可配置的组件包括存储，文件系统，systemd 和用户。</p>
<p>Ignition 在系统首次启动期间（在 initramfs 中）仅运行一次。由于 Ignition 在启动过程中的早期运行，因此它可以在用户空间开始启动之前重新对磁盘分区，格式化文件系统，创建用户并写入文件。当 systemd 启动时，systemd 服务已被写入磁盘，从而加快了启动时间。</p>
<h3 id="自动更新"> 自动更新</h3>
<p>FCOS 使用 rpm-ostree 系统进行事务性升级。无需像 yum 升级那样升级单个软件包，而是 rpm-ostree 将 OS 升级作为一个原子单元进行。新的 OS 部署在升级期间进行，并在下次重新引导时生效。如果升级出现问题，则一次回滚和重新启动会使系统返回到先前的状态。确保了系统升级对群集容量的影响降到最小。</p>
<h3 id="容器工具"> 容器工具</h3>
<p>对于诸如构建，复制和其他管理容器的任务，FCOS 用一组容器工具代替了 <strong>Docker CLI</strong>。<strong>podman CLI</strong> 工具支持许多容器运行时功能，例如运行，启动，停止，列出和删除容器和镜像。<strong>skopeo CLI</strong> 工具可以复制，认证和签名镜像。您还可以使用 <strong>crictl CLI</strong> 工具来处理 CRI-O 容器引擎中的容器和镜像。</p>
<h2 id="参考文档"> 参考文档</h2>
<ul>
<li><a href="https://docs.fedoraproject.org/en-US/fedora-coreos/" target="_blank" rel="noopener noreferrer">官方文档<i>Content not supported</i></a></li>
<li><a href="https://docs.openshift.com/container-platform/4.3/architecture/architecture-rhcos.html" target="_blank" rel="noopener noreferrer">openshift 官方文档<i>Content not supported</i></a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Docker 数据管理</title>
      <link>https://vuepress.mirror.docker-practice.com/data_management/</link>
      <guid>https://vuepress.mirror.docker-practice.com/data_management/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Docker 数据管理</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="docker-数据管理"> Docker 数据管理</h1>
<i>Content not supported</i>
<p><img src="./_images/types-of-mounts.png" alt=""></p>
<p>这一章介绍如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有两种方式：</p>
<ul>
<li>
<p>数据卷（Volumes）</p>
</li>
<li>
<p>挂载主机目录 (Bind mounts)</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>挂载主机目录</title>
      <link>https://vuepress.mirror.docker-practice.com/data_management/bind-mounts/</link>
      <guid>https://vuepress.mirror.docker-practice.com/data_management/bind-mounts/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">挂载主机目录</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="挂载主机目录"> 挂载主机目录</h1>
<i>Content not supported</i>
<h2 id="挂载一个主机目录作为数据卷"> 挂载一个主机目录作为数据卷</h2>
<p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p>
<div><pre><code>$ <span>docker</span> run -d -P <span>\</span>
    --name web <span>\</span>
    <span># -v /src/webapp:/usr/share/nginx/html \</span>
    --mount <span>type</span><span>=</span>bind,source<span>=</span>/src/webapp,target<span>=</span>/usr/share/nginx/html <span>\</span>
    nginx:alpine
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/usr/share/nginx/html</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p>
<p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p>
<div><pre><code>$ <span>docker</span> run -d -P <span>\</span>
    --name web <span>\</span>
    <span># -v /src/webapp:/usr/share/nginx/html:ro \</span>
    --mount <span>type</span><span>=</span>bind,source<span>=</span>/src/webapp,target<span>=</span>/usr/share/nginx/html,readonly <span>\</span>
    nginx:alpine
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/usr/share/nginx/html</code> 目录新建文件，会显示如下错误</p>
<div><pre><code>/usr/share/nginx/html <span># touch new.txt</span>
touch: new.txt: Read-only <span>file</span> system
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="查看数据卷的具体信息"> 查看数据卷的具体信息</h2>
<p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p>
<div><pre><code>$ <span>docker</span> inspect web
</code></pre>
<div><span>1</span><br></div></div><p><code>挂载主机目录</code> 的配置信息在 &quot;Mounts&quot; Key 下面</p>
<div><pre><code><span>"Mounts"</span><span>:</span> <span>[</span>
    <span>{</span>
        <span>"Type"</span><span>:</span> <span>"bind"</span><span>,</span>
        <span>"Source"</span><span>:</span> <span>"/src/webapp"</span><span>,</span>
        <span>"Destination"</span><span>:</span> <span>"/usr/share/nginx/html"</span><span>,</span>
        <span>"Mode"</span><span>:</span> <span>""</span><span>,</span>
        <span>"RW"</span><span>:</span> <span>true</span><span>,</span>
        <span>"Propagation"</span><span>:</span> <span>"rprivate"</span>
    <span>}</span>
<span>]</span><span>,</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="挂载一个本地主机文件作为数据卷"> 挂载一个本地主机文件作为数据卷</h2>
<p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p>
<div><pre><code>$ <span>docker</span> run --rm -it <span>\</span>
   <span># -v $HOME/.bash_history:/root/.bash_history \</span>
   --mount <span>type</span><span>=</span>bind,source<span>=</span><span>$HOME</span>/.bash_history,target<span>=</span>/root/.bash_history <span>\</span>
   ubuntu:18.04 <span>\</span>
   <span>bash</span>

root@2affd44b4667:/<span># history</span>
<span>1</span>  <span>ls</span>
<span>2</span>  diskutil list
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>这样就可以记录在容器输入过的命令了。</p>
]]></content:encoded>
    </item>
    <item>
      <title>数据卷</title>
      <link>https://vuepress.mirror.docker-practice.com/data_management/volume/</link>
      <guid>https://vuepress.mirror.docker-practice.com/data_management/volume/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">数据卷</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="数据卷"> 数据卷</h1>
<i>Content not supported</i>
<p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li>
<p><code>数据卷</code> 可以在容器之间共享和重用</p>
</li>
<li>
<p>对 <code>数据卷</code> 的修改会立马生效</p>
</li>
<li>
<p>对 <code>数据卷</code> 的更新，不会影响镜像</p>
</li>
<li>
<p><code>数据卷</code> 默认会一直存在，即使容器被删除</p>
</li>
</ul>
<blockquote>
<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>
</blockquote>
<h2 id="创建一个数据卷"> 创建一个数据卷</h2>
<div><pre><code>$ <span>docker</span> volume create my-vol
</code></pre>
<div><span>1</span><br></div></div><p>查看所有的 <code>数据卷</code></p>
<div><pre><code>$ <span>docker</span> volume <span>ls</span>

DRIVER              VOLUME NAME
<span>local</span>               my-vol
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在主机里使用以下命令可以查看指定 <code>数据卷</code> 的信息</p>
<div><pre><code>$ <span>docker</span> volume inspect my-vol
<span>[</span>
    <span>{</span>
        <span>"Driver"</span><span>:</span> <span>"local"</span>,
        <span>"Labels"</span><span>:</span> <span>{</span><span>}</span>,
        <span>"Mountpoint"</span><span>:</span> <span>"/var/lib/docker/volumes/my-vol/_data"</span>,
        <span>"Name"</span><span>:</span> <span>"my-vol"</span>,
        <span>"Options"</span><span>:</span> <span>{</span><span>}</span>,
        <span>"Scope"</span><span>:</span> <span>"local"</span>
    <span>}</span>
<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="启动一个挂载数据卷的容器"> 启动一个挂载数据卷的容器</h2>
<p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p>
<div><pre><code>$ <span>docker</span> run -d -P <span>\</span>
    --name web <span>\</span>
    <span># -v my-vol:/usr/share/nginx/html \</span>
    --mount <span>source</span><span>=</span>my-vol,target<span>=</span>/usr/share/nginx/html <span>\</span>
    nginx:alpine
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="查看数据卷的具体信息"> 查看数据卷的具体信息</h2>
<p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p>
<div><pre><code>$ <span>docker</span> inspect web
</code></pre>
<div><span>1</span><br></div></div><p><code>数据卷</code> 信息在 &quot;Mounts&quot; Key 下面</p>
<div><pre><code><span>"Mounts"</span><span>:</span> <span>[</span>
    <span>{</span>
        <span>"Type"</span><span>:</span> <span>"volume"</span><span>,</span>
        <span>"Name"</span><span>:</span> <span>"my-vol"</span><span>,</span>
        <span>"Source"</span><span>:</span> <span>"/var/lib/docker/volumes/my-vol/_data"</span><span>,</span>
        <span>"Destination"</span><span>:</span> <span>"/usr/share/nginx/html"</span><span>,</span>
        <span>"Driver"</span><span>:</span> <span>"local"</span><span>,</span>
        <span>"Mode"</span><span>:</span> <span>""</span><span>,</span>
        <span>"RW"</span><span>:</span> <span>true</span><span>,</span>
        <span>"Propagation"</span><span>:</span> <span>""</span>
    <span>}</span>
<span>]</span><span>,</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="删除数据卷"> 删除数据卷</h2>
<div><pre><code>$ <span>docker</span> volume <span>rm</span> my-vol
</code></pre>
<div><span>1</span><br></div></div><p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p>
<p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p>
<div><pre><code>$ <span>docker</span> volume prune
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>etcd 集群</title>
      <link>https://vuepress.mirror.docker-practice.com/etcd/cluster/</link>
      <guid>https://vuepress.mirror.docker-practice.com/etcd/cluster/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">etcd 集群</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="etcd-集群"> etcd 集群</h1>
<i>Content not supported</i>
<p>下面我们使用 <a href="./../compose/">Docker Compose</a> 模拟启动一个 3 节点的 <code>etcd</code> 集群。</p>
<p>编辑 <code>docker-compose.yml</code> 文件</p>
<div><pre><code><span>version</span><span>:</span> <span>"3.6"</span>
<span>services</span><span>:</span>

  <span>node1</span><span>:</span>
    <span>image</span><span>:</span> quay.io/coreos/etcd<span>:</span>v3.4.0
    <span>volumes</span><span>:</span>
      <span>-</span> node1<span>-</span>data<span>:</span>/etcd<span>-</span>data
    <span>expose</span><span>:</span>
      <span>-</span> <span>2379</span>
      <span>-</span> <span>2380</span>
    <span>networks</span><span>:</span>
      <span>cluster_net</span><span>:</span>
        <span>ipv4_address</span><span>:</span> 172.16.238.100
    <span>environment</span><span>:</span>
      <span>-</span> ETCDCTL_API=3
    <span>command</span><span>:</span>
      <span>-</span> /usr/local/bin/etcd
      <span>-</span> <span>-</span><span>-</span>data<span>-</span>dir=/etcd<span>-</span>data
      <span>-</span> <span>-</span><span>-</span>name
      <span>-</span> node1
      <span>-</span> <span>-</span><span>-</span>initial<span>-</span>advertise<span>-</span>peer<span>-</span>urls
      <span>-</span> http<span>:</span>//172.16.238.100<span>:</span><span>2380</span>
      <span>-</span> <span>-</span><span>-</span>listen<span>-</span>peer<span>-</span>urls
      <span>-</span> http<span>:</span>//0.0.0.0<span>:</span><span>2380</span>
      <span>-</span> <span>-</span><span>-</span>advertise<span>-</span>client<span>-</span>urls
      <span>-</span> http<span>:</span>//172.16.238.100<span>:</span><span>2379</span>
      <span>-</span> <span>-</span><span>-</span>listen<span>-</span>client<span>-</span>urls
      <span>-</span> http<span>:</span>//0.0.0.0<span>:</span><span>2379</span>
      <span>-</span> <span>-</span><span>-</span>initial<span>-</span>cluster
      <span>-</span> node1=http<span>:</span>//172.16.238.100<span>:</span><span>2380</span><span>,</span>node2=http<span>:</span>//172.16.238.101<span>:</span><span>2380</span><span>,</span>node3=http<span>:</span>//172.16.238.102<span>:</span><span>2380</span>
      <span>-</span> <span>-</span><span>-</span>initial<span>-</span>cluster<span>-</span>state
      <span>-</span> new
      <span>-</span> <span>-</span><span>-</span>initial<span>-</span>cluster<span>-</span>token
      <span>-</span> docker<span>-</span>etcd

  <span>node2</span><span>:</span>
    <span>image</span><span>:</span> quay.io/coreos/etcd<span>:</span>v3.4.0
    <span>volumes</span><span>:</span>
      <span>-</span> node2<span>-</span>data<span>:</span>/etcd<span>-</span>data
    <span>networks</span><span>:</span>
      <span>cluster_net</span><span>:</span>
        <span>ipv4_address</span><span>:</span> 172.16.238.101
    <span>environment</span><span>:</span>
      <span>-</span> ETCDCTL_API=3
    <span>expose</span><span>:</span>
      <span>-</span> <span>2379</span>
      <span>-</span> <span>2380</span>
    <span>command</span><span>:</span>
      <span>-</span> /usr/local/bin/etcd
      <span>-</span> <span>-</span><span>-</span>data<span>-</span>dir=/etcd<span>-</span>data
      <span>-</span> <span>-</span><span>-</span>name
      <span>-</span> node2
      <span>-</span> <span>-</span><span>-</span>initial<span>-</span>advertise<span>-</span>peer<span>-</span>urls
      <span>-</span> http<span>:</span>//172.16.238.101<span>:</span><span>2380</span>
      <span>-</span> <span>-</span><span>-</span>listen<span>-</span>peer<span>-</span>urls
      <span>-</span> http<span>:</span>//0.0.0.0<span>:</span><span>2380</span>
      <span>-</span> <span>-</span><span>-</span>advertise<span>-</span>client<span>-</span>urls
      <span>-</span> http<span>:</span>//172.16.238.101<span>:</span><span>2379</span>
      <span>-</span> <span>-</span><span>-</span>listen<span>-</span>client<span>-</span>urls
      <span>-</span> http<span>:</span>//0.0.0.0<span>:</span><span>2379</span>
      <span>-</span> <span>-</span><span>-</span>initial<span>-</span>cluster
      <span>-</span> node1=http<span>:</span>//172.16.238.100<span>:</span><span>2380</span><span>,</span>node2=http<span>:</span>//172.16.238.101<span>:</span><span>2380</span><span>,</span>node3=http<span>:</span>//172.16.238.102<span>:</span><span>2380</span>
      <span>-</span> <span>-</span><span>-</span>initial<span>-</span>cluster<span>-</span>state
      <span>-</span> new
      <span>-</span> <span>-</span><span>-</span>initial<span>-</span>cluster<span>-</span>token
      <span>-</span> docker<span>-</span>etcd

  <span>node3</span><span>:</span>
    <span>image</span><span>:</span> quay.io/coreos/etcd<span>:</span>v3.4.0
    <span>volumes</span><span>:</span>
      <span>-</span> node3<span>-</span>data<span>:</span>/etcd<span>-</span>data
    <span>networks</span><span>:</span>
      <span>cluster_net</span><span>:</span>
        <span>ipv4_address</span><span>:</span> 172.16.238.102
    <span>environment</span><span>:</span>
      <span>-</span> ETCDCTL_API=3
    <span>expose</span><span>:</span>
      <span>-</span> <span>2379</span>
      <span>-</span> <span>2380</span>
    <span>command</span><span>:</span>
      <span>-</span> /usr/local/bin/etcd
      <span>-</span> <span>-</span><span>-</span>data<span>-</span>dir=/etcd<span>-</span>data
      <span>-</span> <span>-</span><span>-</span>name
      <span>-</span> node3
      <span>-</span> <span>-</span><span>-</span>initial<span>-</span>advertise<span>-</span>peer<span>-</span>urls
      <span>-</span> http<span>:</span>//172.16.238.102<span>:</span><span>2380</span>
      <span>-</span> <span>-</span><span>-</span>listen<span>-</span>peer<span>-</span>urls
      <span>-</span> http<span>:</span>//0.0.0.0<span>:</span><span>2380</span>
      <span>-</span> <span>-</span><span>-</span>advertise<span>-</span>client<span>-</span>urls
      <span>-</span> http<span>:</span>//172.16.238.102<span>:</span><span>2379</span>
      <span>-</span> <span>-</span><span>-</span>listen<span>-</span>client<span>-</span>urls
      <span>-</span> http<span>:</span>//0.0.0.0<span>:</span><span>2379</span>
      <span>-</span> <span>-</span><span>-</span>initial<span>-</span>cluster
      <span>-</span> node1=http<span>:</span>//172.16.238.100<span>:</span><span>2380</span><span>,</span>node2=http<span>:</span>//172.16.238.101<span>:</span><span>2380</span><span>,</span>node3=http<span>:</span>//172.16.238.102<span>:</span><span>2380</span>
      <span>-</span> <span>-</span><span>-</span>initial<span>-</span>cluster<span>-</span>state
      <span>-</span> new
      <span>-</span> <span>-</span><span>-</span>initial<span>-</span>cluster<span>-</span>token
      <span>-</span> docker<span>-</span>etcd

<span>volumes</span><span>:</span>
  <span>node1-data</span><span>:</span>
  <span>node2-data</span><span>:</span>
  <span>node3-data</span><span>:</span>

<span>networks</span><span>:</span>
  <span>cluster_net</span><span>:</span>
    <span>driver</span><span>:</span> bridge
    <span>ipam</span><span>:</span>
      <span>driver</span><span>:</span> default
      <span>config</span><span>:</span>
      <span>-</span>
        <span>subnet</span><span>:</span> 172.16.238.0/24
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br></div></div><p>使用 <code>docker compose up</code> 启动集群之后使用 <code>docker exec</code> 命令登录到任一节点测试 <code>etcd</code> 集群。</p>
<div><pre><code>/ <span># etcdctl member list</span>
daf3fd52e3583ff, started, node3, http://172.16.238.102:2380, http://172.16.238.102:2379
422a74f03b622fef, started, node1, http://172.16.238.100:2380, http://172.16.238.100:2379
ed635d2a2dbef43d, started, node2, http://172.16.238.101:2380, http://172.16.238.101:2379
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>etcd</title>
      <link>https://vuepress.mirror.docker-practice.com/etcd/</link>
      <guid>https://vuepress.mirror.docker-practice.com/etcd/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">etcd</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="etcd"> etcd</h1>
<i>Content not supported</i>
<p><code>etcd</code> 是 <code>CoreOS</code> 团队发起的一个管理配置信息和服务发现（<code>Service Discovery</code>）的项目，在这一章里面，我们将基于 <code>etcd 3.x</code> 版本介绍该项目的目标，安装和使用，以及实现的技术。</p>
]]></content:encoded>
    </item>
    <item>
      <title>使用 etcdctl</title>
      <link>https://vuepress.mirror.docker-practice.com/etcd/etcdctl/</link>
      <guid>https://vuepress.mirror.docker-practice.com/etcd/etcdctl/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">使用 etcdctl</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="使用-etcdctl"> 使用 etcdctl</h1>
<i>Content not supported</i>
<p><code>etcdctl</code> 是一个命令行客户端，它能提供一些简洁的命令，供用户直接跟 <code>etcd</code> 服务打交道，而无需基于 <code>HTTP API</code> 方式。这在某些情况下将很方便，例如用户对服务进行测试或者手动修改数据库内容。我们也推荐在刚接触 <code>etcd</code> 时通过 <code>etcdctl</code> 命令来熟悉相关的操作，这些操作跟 <code>HTTP API</code> 实际上是对应的。</p>
<p><code>etcd</code> 项目二进制发行包中已经包含了 <code>etcdctl</code> 工具，没有的话，可以从 <a href="https://github.com/etcd-io/etcd/releases" target="_blank" rel="noopener noreferrer">github.com/etcd-io/etcd/releases<i>Content not supported</i></a> 下载。</p>
<p><code>etcdctl</code> 支持如下的命令，大体上分为数据库操作和非数据库操作两类，后面将分别进行解释。</p>
<div><pre><code>NAME:
	etcdctl - A simple command line client for etcd3.

USAGE:
	etcdctl

VERSION:
	3.4.0

API VERSION:
	3.4


COMMANDS:
	get			Gets the key or a range of keys
	put			Puts the given key into the store
	del			Removes the specified key or range of keys [key, range_end)
	txn			Txn processes all the requests in one transaction
	compaction		Compacts the event history in etcd
	alarm disarm		Disarms all alarms
	alarm list		Lists all alarms
	defrag			Defragments the storage of the etcd members with given endpoints
	endpoint health		Checks the healthiness of endpoints specified in `--endpoints` flag
	endpoint status		Prints out the status of endpoints specified in `--endpoints` flag
	watch			Watches events stream on keys or prefixes
	version			Prints the version of etcdctl
	lease grant		Creates leases
	lease revoke		Revokes leases
	lease timetolive	Get lease information
	lease keep-alive	Keeps leases alive (renew)
	member add		Adds a member into the cluster
	member remove		Removes a member from the cluster
	member update		Updates a member in the cluster
	member list		Lists all members in the cluster
	snapshot save		Stores an etcd node backend snapshot to a given file
	snapshot restore	Restores an etcd member snapshot to an etcd directory
	snapshot status		Gets backend snapshot status of a given file
	make-mirror		Makes a mirror at the destination etcd cluster
	migrate			Migrates keys in a v2 store to a mvcc store
	lock			Acquires a named lock
	elect			Observes and participates in leader election
	auth enable		Enables authentication
	auth disable		Disables authentication
	user add		Adds a new user
	user delete		Deletes a user
	user get		Gets detailed information of a user
	user list		Lists all users
	user passwd		Changes password of user
	user grant-role		Grants a role to a user
	user revoke-role	Revokes a role from a user
	role add		Adds a new role
	role delete		Deletes a role
	role get		Gets detailed information of a role
	role list		Lists all roles
	role grant-permission	Grants a key to a role
	role revoke-permission	Revokes a key from a role
	check perf		Check the performance of the etcd cluster
	help			Help about any command

OPTIONS:
      --cacert=&quot;&quot;				verify certificates of TLS-enabled secure servers using this CA bundle
      --cert=&quot;&quot;					identify secure client using this TLS certificate file
      --command-timeout=5s			timeout for short running command (excluding dial timeout)
      --debug[=false]				enable client-side debug logging
      --dial-timeout=2s				dial timeout for client connections
      --endpoints=[127.0.0.1:2379]		gRPC endpoints
      --hex[=false]				print byte strings as hex encoded strings
      --insecure-skip-tls-verify[=false]	skip server certificate verification
      --insecure-transport[=true]		disable transport security for client connections
      --key=&quot;&quot;					identify secure client using this TLS key file
      --user=&quot;&quot;					username[:password] for authentication (prompt if password is not supplied)
  -w, --write-out=&quot;simple&quot;			set the output format (fields, json, protobuf, simple, table)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br></div></div><h2 id="数据库操作"> 数据库操作</h2>
<p>数据库操作围绕对键值和目录的 CRUD （符合 REST 风格的一套操作：Create）完整生命周期的管理。</p>
<p>etcd 在键的组织上采用了层次化的空间结构（类似于文件系统中目录的概念），用户指定的键可以为单独的名字，如 <code>testkey</code>，此时实际上放在根目录 <code>/</code> 下面，也可以为指定目录结构，如 <code>cluster1/node2/testkey</code>，则将创建相应的目录结构。</p>
<blockquote>
<p>注：CRUD 即 Create, Read, Update, Delete，是符合 REST 风格的一套 API 操作。</p>
</blockquote>
<h3 id="put"> put</h3>
<div><pre><code>$ etcdctl put /testdir/testkey <span>"Hello world"</span>
OK
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="get"> get</h3>
<p>获取指定键的值。例如</p>
<div><pre><code>$ etcdctl put testkey hello
OK
$ etcdctl get testkey
testkey
hello
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>支持的选项为</p>
<p><code>--sort</code>	对结果进行排序</p>
<p><code>--consistent</code> 将请求发给主节点，保证获取内容的一致性</p>
<h3 id="del"> del</h3>
<p>删除某个键值。例如</p>
<div><pre><code>$ etcdctl del testkey
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="非数据库操作"> 非数据库操作</h2>
<h3 id="watch"> watch</h3>
<p>监测一个键值的变化，一旦键值发生更新，就会输出最新的值。</p>
<p>例如，用户更新 <code>testkey</code> 键值为 <code>Hello world</code>。</p>
<div><pre><code>$ etcdctl <span>watch</span> testkey
PUT
testkey
<span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="member"> member</h3>
<p>通过 <code>list</code>、<code>add</code>、<code>update</code>、<code>remove</code> 命令列出、添加、更新、删除 etcd 实例到 etcd 集群中。</p>
<p>例如本地启动一个 <code>etcd</code> 服务实例后，可以用如下命令进行查看。</p>
<div><pre><code>$ etcdctl member list
422a74f03b622fef, started, node1, http://172.16.238.100:2380, http://172.16.238.100:23
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>使用 etcdctl v2</title>
      <link>https://vuepress.mirror.docker-practice.com/etcd/etcdctl-v2/</link>
      <guid>https://vuepress.mirror.docker-practice.com/etcd/etcdctl-v2/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">使用 etcdctl v2</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="使用-etcdctl-v2"> 使用 etcdctl v2</h1>
<i>Content not supported</i>
<p><code>etcdctl</code> 是一个命令行客户端，它能提供一些简洁的命令，供用户直接跟 <code>etcd</code> 服务打交道，而无需基于 <code>HTTP API</code> 方式。这在某些情况下将很方便，例如用户对服务进行测试或者手动修改数据库内容。我们也推荐在刚接触 <code>etcd</code> 时通过 <code>etcdctl</code> 命令来熟悉相关的操作，这些操作跟 <code>HTTP API</code> 实际上是对应的。</p>
<p><code>etcd</code> 项目二进制发行包中已经包含了 <code>etcdctl</code> 工具，没有的话，可以从 <a href="https://github.com/etcd-io/etcd/releases" target="_blank" rel="noopener noreferrer">github.com/etcd-io/etcd/releases<i>Content not supported</i></a> 下载。</p>
<p><code>etcdctl</code> 支持如下的命令，大体上分为数据库操作和非数据库操作两类，后面将分别进行解释。</p>
<div><pre><code>$ etcdctl -h
NAME:
   etcdctl - A simple command line client for etcd.

USAGE:
   etcdctl [global options] command [command options] [arguments...]

VERSION:
   2.0.0-rc.1

COMMANDS:
   backup	backup an etcd directory
   mk		make a new key with a given value
   mkdir	make a new directory
   rm		remove a key
   rmdir	removes the key if it is an empty directory or a key-value pair
   get		retrieve the value of a key
   ls		retrieve a directory
   set		set the value of a key
   setdir	create a new or existing directory
   update	update an existing key with a given value
   updatedir	update an existing directory
   watch	watch a key for changes
   exec-watch	watch a key for changes and exec an executable
   member	member add, remove and list subcommands
   help, h	Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --debug			output cURL commands which can be used to reproduce the request
   --no-sync			don&#39;t synchronize cluster information before sending request
   --output, -o &#39;simple&#39;	output response in the given format (`simple` or `json`)
   --peers, -C 			a comma-delimited list of machine addresses in the cluster (default: &quot;127.0.0.1:4001&quot;)
   --cert-file 			identify HTTPS client using this SSL certificate file
   --key-file 			identify HTTPS client using this SSL key file
   --ca-file 			verify certificates of HTTPS-enabled servers using this CA bundle
   --help, -h			show help
   --version, -v		print the version
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h2 id="数据库操作"> 数据库操作</h2>
<p>数据库操作围绕对键值和目录的 CRUD （符合 REST 风格的一套操作：Create）完整生命周期的管理。</p>
<p>etcd 在键的组织上采用了层次化的空间结构（类似于文件系统中目录的概念），用户指定的键可以为单独的名字，如 <code>testkey</code>，此时实际上放在根目录 <code>/</code> 下面，也可以为指定目录结构，如 <code>cluster1/node2/testkey</code>，则将创建相应的目录结构。</p>
<p><em>注：CRUD 即 Create, Read, Update, Delete，是符合 REST 风格的一套 API 操作。</em></p>
<h3 id="set"> set</h3>
<p>指定某个键的值。例如</p>
<div><pre><code>$ etcdctl <span>set</span> /testdir/testkey <span>"Hello world"</span>
Hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>支持的选项包括：</p>
<div><pre><code>--ttl <span>'0'</span>			该键值的超时时间（单位为秒），不配置（默认为 <span>0</span>）则永不超时
--swap-with-value value 若该键现在的值是 value，则进行设置操作
--swap-with-index <span>'0'</span>	若该键现在的索引值是指定索引，则进行设置操作
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="get"> get</h3>
<p>获取指定键的值。例如</p>
<div><pre><code>$ etcdctl <span>set</span> testkey hello
hello
$ etcdctl update testkey world
world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>当键不存在时，则会报错。例如</p>
<div><pre><code>$ etcdctl get testkey2
Error:  <span>100</span>: Key not found <span>(</span>/testkey2<span>)</span> <span>[</span><span>1</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>支持的选项为</p>
<div><pre><code>--sort	对结果进行排序
--consistent 将请求发给主节点，保证获取内容的一致性
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="update"> update</h3>
<p>当键存在时，更新值内容。例如</p>
<div><pre><code>$ etcdctl <span>set</span> testkey hello
hello
$ etcdctl update testkey world
world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>当键不存在时，则会报错。例如</p>
<div><pre><code>$ etcdctl update testkey2 world
Error:  <span>100</span>: Key not found <span>(</span>/testkey2<span>)</span> <span>[</span><span>1</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>支持的选项为</p>
<div><pre><code>--ttl <span>'0'</span>	超时时间（单位为秒），不配置（默认为 <span>0</span>）则永不超时
</code></pre>
<div><span>1</span><br></div></div><h3 id="rm"> rm</h3>
<p>删除某个键值。例如</p>
<div><pre><code>$ etcdctl <span>rm</span> testkey
</code></pre>
<div><span>1</span><br></div></div><p>当键不存在时，则会报错。例如</p>
<div><pre><code>$ etcdctl <span>rm</span> testkey2
Error:  <span>100</span>: Key not found <span>(</span>/testkey2<span>)</span> <span>[</span><span>8</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>支持的选项为</p>
<div><pre><code>--dir		如果键是个空目录或者键值对则删除
--recursive		删除目录和所有子键
--with-value 	检查现有的值是否匹配
--with-index <span>'0'</span>	检查现有的 index 是否匹配
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="mk"> mk</h3>
<p>如果给定的键不存在，则创建一个新的键值。例如</p>
<div><pre><code>$ etcdctl mk /testdir/testkey <span>"Hello world"</span>
Hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当键存在的时候，执行该命令会报错，例如</p>
<div><pre><code>$ etcdctl <span>set</span> testkey <span>"Hello world"</span>
Hello world
$ ./etcdctl mk testkey <span>"Hello world"</span>
Error:  <span>105</span>: Key already exists <span>(</span>/testkey<span>)</span> <span>[</span><span>2</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>支持的选项为</p>
<div><pre><code>--ttl <span>'0'</span>	超时时间（单位为秒），不配置（默认为 <span>0</span>）则永不超时
</code></pre>
<div><span>1</span><br></div></div><h3 id="mkdir"> mkdir</h3>
<p>如果给定的键目录不存在，则创建一个新的键目录。例如</p>
<div><pre><code>$ etcdctl <span>mkdir</span> testdir
</code></pre>
<div><span>1</span><br></div></div><p>当键目录存在的时候，执行该命令会报错，例如</p>
<div><pre><code>$ etcdctl <span>mkdir</span> testdir
$ etcdctl <span>mkdir</span> testdir
Error:  <span>105</span>: Key already exists <span>(</span>/testdir<span>)</span> <span>[</span><span>7</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>支持的选项为</p>
<div><pre><code>--ttl <span>'0'</span>	超时时间（单位为秒），不配置（默认为 <span>0</span>）则永不超时
</code></pre>
<div><span>1</span><br></div></div><h3 id="setdir"> setdir</h3>
<p>创建一个键目录，无论存在与否。</p>
<p>支持的选项为</p>
<div><pre><code>--ttl <span>'0'</span>	超时时间（单位为秒），不配置（默认为 <span>0</span>）则永不超时
</code></pre>
<div><span>1</span><br></div></div><h3 id="updatedir"> updatedir</h3>
<p>更新一个已经存在的目录。
支持的选项为</p>
<div><pre><code>--ttl <span>'0'</span>	超时时间（单位为秒），不配置（默认为 <span>0</span>）则永不超时
</code></pre>
<div><span>1</span><br></div></div><h3 id="rmdir"> rmdir</h3>
<p>删除一个空目录，或者键值对。</p>
<p>若目录不空，会报错</p>
<div><pre><code>$ etcdctl <span>set</span> /dir/testkey hi
hi
$ etcdctl <span>rmdir</span> /dir
Error:  <span>108</span>: Directory not empty <span>(</span>/dir<span>)</span> <span>[</span><span>13</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="ls"> ls</h3>
<p>列出目录（默认为根目录）下的键或者子目录，默认不显示子目录中内容。</p>
<p>例如</p>
<div><pre><code>$ ./etcdctl <span>set</span> testkey <span>'hi'</span>
hi
$ ./etcdctl <span>set</span> dir/test <span>'hello'</span>
hello
$ ./etcdctl <span>ls</span>
/testkey
/dir
$ ./etcdctl <span>ls</span> <span>dir</span>
/dir/test
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>支持的选项包括</p>
<div><pre><code>--sort	将输出结果排序
--recursive	如果目录下有子目录，则递归输出其中的内容
-p		对于输出为目录，在最后添加 <span><span>`</span>/<span>`</span></span> 进行区分
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="非数据库操作"> 非数据库操作</h2>
<h3 id="backup"> backup</h3>
<p>备份 etcd 的数据。</p>
<p>支持的选项包括</p>
<div><pre><code>--data-dir 		etcd 的数据目录
--backup-dir 	备份到指定路径
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="watch"> watch</h3>
<p>监测一个键值的变化，一旦键值发生更新，就会输出最新的值并退出。</p>
<p>例如，用户更新 testkey 键值为 Hello world。</p>
<div><pre><code>$ etcdctl <span>watch</span> testkey
Hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>支持的选项包括</p>
<div><pre><code>--forever		一直监测，直到用户按 <span><span>`</span>CTRL+C<span>`</span></span> 退出
--after-index <span>'0'</span>	在指定 index 之前一直监测
--recursive		返回所有的键值和子键值
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="exec-watch"> exec-watch</h3>
<p>监测一个键值的变化，一旦键值发生更新，就执行给定命令。</p>
<p>例如，用户更新 testkey 键值。</p>
<div><pre><code>$ etcdctl exec-watch testkey -- <span>sh</span> -c <span>'ls'</span>
default.etcd
Documentation
etcd
etcdctl
etcd-migrate
README-etcdctl.md
README.md
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>支持的选项包括</p>
<div><pre><code>--after-index <span>'0'</span>	在指定 index 之前一直监测
--recursive		返回所有的键值和子键值
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="member"> member</h3>
<p>通过 list、add、remove 命令列出、添加、删除 etcd 实例到 etcd 集群中。</p>
<p>例如本地启动一个 etcd 服务实例后，可以用如下命令进行查看。</p>
<div><pre><code>$ etcdctl member list
ce2a822cea30bfca: <span>name</span><span>=</span>default <span>peerURLs</span><span>=</span>http://localhost:2380,http://localhost:7001 <span>clientURLs</span><span>=</span>http://localhost:2379,http://localhost:4001
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="命令选项"> 命令选项</h2>
<ul>
<li><code>--debug</code>			输出 cURL 命令，显示执行命令的时候发起的请求</li>
<li><code>--no-sync</code>			发出请求之前不同步集群信息</li>
<li><code>--output, -o 'simple'</code>	输出内容的格式 (<code>simple</code> 为原始信息，<code>json</code> 为进行json格式解码，易读性好一些)</li>
<li><code>--peers, -C</code>			指定集群中的同伴信息，用逗号隔开 (默认为: &quot;127.0.0.1:4001&quot;)</li>
<li><code>--cert-file</code> 			HTTPS 下客户端使用的 SSL 证书文件</li>
<li><code>--key-file</code>			HTTPS 下客户端使用的 SSL 密钥文件</li>
<li><code>--ca-file</code> 			服务端使用 HTTPS 时，使用 CA 文件进行验证</li>
<li><code>--help, -h</code>			显示帮助命令信息</li>
<li><code>--version, -v</code>		打印版本信息</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>安装</title>
      <link>https://vuepress.mirror.docker-practice.com/etcd/install/</link>
      <guid>https://vuepress.mirror.docker-practice.com/etcd/install/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">安装</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="安装"> 安装</h1>
<i>Content not supported</i>
<p><code>etcd</code> 基于 <code>Go</code> 语言实现，因此，用户可以从 <a href="https://github.com/etcd-io/etcd" target="_blank" rel="noopener noreferrer">项目主页<i>Content not supported</i></a> 下载源代码自行编译，也可以下载编译好的二进制文件，甚至直接使用制作好的 <code>Docker</code> 镜像文件来体验。</p>
<blockquote>
<p>注意：本章节内容基于 etcd <code>3.4.x</code> 版本</p>
</blockquote>
<h2 id="二进制文件方式下载"> 二进制文件方式下载</h2>
<p>编译好的二进制文件都在 <a href="https://github.com/etcd-io/etcd/releases/" target="_blank" rel="noopener noreferrer">github.com/etcd-io/etcd/releases<i>Content not supported</i></a> 页面，用户可以选择需要的版本，或通过下载工具下载。</p>
<p>例如，使用 <code>curl</code> 工具下载压缩包，并解压。</p>
<div><pre><code>$ <span>curl</span> -L https://github.com/etcd-io/etcd/releases/download/v3.4.0/etcd-v3.4.0-linux-amd64.tar.gz -o etcd-v3.4.0-linux-amd64.tar.gz

<span># 国内用户可以使用以下方式加快下载</span>
$ <span>curl</span> -L https://download.fastgit.org/etcd-io/etcd/releases/download/v3.4.0/etcd-v3.4.0-linux-amd64.tar.gz -o etcd-v3.4.0-linux-amd64.tar.gz

$ <span>tar</span> xzvf etcd-v3.4.0-linux-amd64.tar.gz
$ <span>cd</span> etcd-v3.4.0-linux-amd64
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>解压后，可以看到文件包括</p>
<div><pre><code>$ <span>ls</span>
Documentation README-etcdctl.md README.md READMEv2-etcdctl.md etcd etcdctl
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>其中 <code>etcd</code> 是服务主文件，<code>etcdctl</code> 是提供给用户的命令客户端，其他文件是支持文档。</p>
<p>下面将 <code>etcd</code> <code>etcdctl</code> 文件放到系统可执行目录（例如 <code>/usr/local/bin/</code>）。</p>
<div><pre><code>$ <span>sudo</span> <span>cp</span> etcd* /usr/local/bin/
</code></pre>
<div><span>1</span><br></div></div><p>默认 <code>2379</code> 端口处理客户端的请求，<code>2380</code> 端口用于集群各成员间的通信。启动 <code>etcd</code> 显示类似如下的信息：</p>
<div><pre><code>$ etcd
<span>..</span>.
<span>2017</span>-12-03 <span>11</span>:18:34.411579 I <span>|</span> embed: listening <span>for</span> peers on http://localhost:2380
<span>2017</span>-12-03 <span>11</span>:18:34.411938 I <span>|</span> embed: listening <span>for</span> client requests on localhost:2379
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>此时，可以使用 <code>etcdctl</code> 命令进行测试，设置和获取键值 <code>testkey: &quot;hello world&quot;</code>，检查 <code>etcd</code> 服务是否启动成功：</p>
<div><pre><code>$ <span>ETCDCTL_API</span><span>=</span><span>3</span> etcdctl member list
8e9e05c52164694d, started, default, http://localhost:2380, http://localhost:2379

$ <span>ETCDCTL_API</span><span>=</span><span>3</span> etcdctl put testkey <span>"hello world"</span>
OK

$ etcdctl get testkey
testkey
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>说明 etcd 服务已经成功启动了。</p>
<h2 id="docker-镜像方式运行"> Docker 镜像方式运行</h2>
<p>镜像名称为 <code>quay.io/coreos/etcd</code>，可以通过下面的命令启动 <code>etcd</code> 服务监听到 <code>2379</code> 和 <code>2380</code> 端口。</p>
<div><pre><code>$ <span>docker</span> run <span>\</span>
-p <span>2379</span>:2379 <span>\</span>
-p <span>2380</span>:2380 <span>\</span>
--mount <span>type</span><span>=</span>bind,source<span>=</span>/tmp/etcd-data.tmp,destination<span>=</span>/etcd-data <span>\</span>
--name etcd-gcr-v3.4.0 <span>\</span>
quay.io/coreos/etcd:v3.4.0 <span>\</span>
/usr/local/bin/etcd <span>\</span>
--name s1 <span>\</span>
--data-dir /etcd-data <span>\</span>
--listen-client-urls http://0.0.0.0:2379 <span>\</span>
--advertise-client-urls http://0.0.0.0:2379 <span>\</span>
--listen-peer-urls http://0.0.0.0:2380 <span>\</span>
--initial-advertise-peer-urls http://0.0.0.0:2380 <span>\</span>
--initial-cluster <span>s1</span><span>=</span>http://0.0.0.0:2380 <span>\</span>
--initial-cluster-token tkn <span>\</span>
--initial-cluster-state new <span>\</span>
--log-level info <span>\</span>
--logger zap <span>\</span>
--log-outputs stderr
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>打开新的终端按照上一步的方法测试 <code>etcd</code> 是否成功启动。</p>
<h2 id="macos-中运行"> macOS 中运行</h2>
<div><pre><code>$ brew <span>install</span> etcd

$ etcd

$ etcdctl member list
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>什么是 etcd</title>
      <link>https://vuepress.mirror.docker-practice.com/etcd/intro/</link>
      <guid>https://vuepress.mirror.docker-practice.com/etcd/intro/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">什么是 etcd</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="什么是-etcd"> 什么是 etcd</h1>
<i>Content not supported</i>
<p><img src="./_images/etcd_logo.png" alt=""></p>
<p><code>etcd</code> 是 <code>CoreOS</code> 团队于 2013 年 6 月发起的开源项目，它的目标是构建一个高可用的分布式键值（<code>key-value</code>）数据库，基于 <code>Go</code> 语言实现。我们知道，在分布式系统中，各种服务的配置信息的管理分享，服务的发现是一个很基本同时也是很重要的问题。<code>CoreOS</code> 项目就希望基于 <code>etcd</code> 来解决这一问题。</p>
<p><code>etcd</code> 目前在 <a href="https://github.com/etcd-io/etcd" target="_blank" rel="noopener noreferrer">github.com/etcd-io/etcd<i>Content not supported</i></a> 进行维护。</p>
<p>受到 <a href="https://zookeeper.apache.org/" target="_blank" rel="noopener noreferrer">Apache ZooKeeper<i>Content not supported</i></a> 项目和 <a href="https://github.com/ha/doozerd" target="_blank" rel="noopener noreferrer">doozer<i>Content not supported</i></a> 项目的启发，<code>etcd</code> 在设计的时候重点考虑了下面四个要素：</p>
<ul>
<li>
<p>简单：具有定义良好、面向用户的 <code>API</code> (<a href="https://github.com/grpc/grpc" target="_blank" rel="noopener noreferrer">gRPC<i>Content not supported</i></a>)</p>
</li>
<li>
<p>安全：支持 <code>HTTPS</code> 方式的访问</p>
</li>
<li>
<p>快速：支持并发 <code>10 k/s</code> 的写操作</p>
</li>
<li>
<p>可靠：支持分布式结构，基于 <code>Raft</code> 的一致性算法</p>
</li>
</ul>
<p><em>Apache ZooKeeper 是一套知名的分布式系统中进行同步和一致性管理的工具。</em></p>
<p><em>doozer 是一个一致性分布式数据库。</em></p>
<p><em><a href="https://raft.github.io/" target="_blank" rel="noopener noreferrer">Raft<i>Content not supported</i></a> 是一套通过选举主节点来实现分布式系统一致性的算法，相比于大名鼎鼎的 Paxos 算法，它的过程更容易被人理解，由 Stanford 大学的 Diego Ongaro 和 John Ousterhout 提出。更多细节可以参考 <a href="http://raftconsensus.github.io" target="_blank" rel="noopener noreferrer">raftconsensus.github.io<i>Content not supported</i></a>。</em></p>
<p>一般情况下，用户使用 <code>etcd</code> 可以在多个节点上启动多个实例，并添加它们为一个集群。同一个集群中的 <code>etcd</code> 实例将会保持彼此信息的一致性。</p>
]]></content:encoded>
    </item>
    <item>
      <title>在 IDE 中使用 Docker</title>
      <link>https://vuepress.mirror.docker-practice.com/ide/</link>
      <guid>https://vuepress.mirror.docker-practice.com/ide/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">在 IDE 中使用 Docker</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="在-ide-中使用-docker"> 在 IDE 中使用 Docker</h1>
<i>Content not supported</i>
<p>使用 IDE 进行开发，往往要求本地安装好工具链。一些 IDE 支持 Docker 容器中的工具链，这样充分利用了 Docker 的优点，而无需在本地安装。</p>
]]></content:encoded>
    </item>
    <item>
      <title>VS Code 中使用 Docker</title>
      <link>https://vuepress.mirror.docker-practice.com/ide/vsCode/</link>
      <guid>https://vuepress.mirror.docker-practice.com/ide/vsCode/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">VS Code 中使用 Docker</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="vs-code-中使用-docker"> VS Code 中使用 Docker</h1>
<i>Content not supported</i>
<h2 id="将-docker-容器作为远程开发环境"> 将 Docker 容器作为远程开发环境</h2>
<p>无需本地安装开发工具，直接将 Docker 容器作为开发环境，具体参考 <a href="https://code.visualstudio.com/docs/remote/containers" target="_blank" rel="noopener noreferrer">官方文档<i>Content not supported</i></a>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>使用 Dockerfile 定制镜像</title>
      <link>https://vuepress.mirror.docker-practice.com/image/build/</link>
      <guid>https://vuepress.mirror.docker-practice.com/image/build/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">使用 Dockerfile 定制镜像</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="使用-dockerfile-定制镜像"> 使用 Dockerfile 定制镜像</h1>
<i>Content not supported</i>
<p>从刚才的 <code>docker commit</code> 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p>
<p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p>
<div><pre><code>$ <span>mkdir</span> mynginx
$ <span>cd</span> mynginx
$ <span>touch</span> Dockerfile
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>其内容为：</p>
<div><pre><code><span><span>FROM</span> nginx</span>
<span><span>RUN</span> echo <span>'&lt;h1>Hello, Docker!&lt;/h1>'</span> > /usr/share/nginx/html/index.html</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p>
<h2 id="from-指定基础镜像"> FROM 指定基础镜像</h2>
<p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p>
<p>在 <a href="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=official" target="_blank" rel="noopener noreferrer">Docker Hub<i>Content not supported</i></a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener noreferrer"><code>nginx</code><i>Content not supported</i></a>、<a href="https://hub.docker.com/_/redis/" target="_blank" rel="noopener noreferrer"><code>redis</code><i>Content not supported</i></a>、<a href="https://hub.docker.com/_/mongo/" target="_blank" rel="noopener noreferrer"><code>mongo</code><i>Content not supported</i></a>、<a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener noreferrer"><code>mysql</code><i>Content not supported</i></a>、<a href="https://hub.docker.com/_/httpd/" target="_blank" rel="noopener noreferrer"><code>httpd</code><i>Content not supported</i></a>、<a href="https://hub.docker.com/_/php/" target="_blank" rel="noopener noreferrer"><code>php</code><i>Content not supported</i></a>、<a href="https://hub.docker.com/_/tomcat/" target="_blank" rel="noopener noreferrer"><code>tomcat</code><i>Content not supported</i></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node" target="_blank" rel="noopener noreferrer"><code>node</code><i>Content not supported</i></a>、<a href="https://hub.docker.com/_/openjdk/" target="_blank" rel="noopener noreferrer"><code>openjdk</code><i>Content not supported</i></a>、<a href="https://hub.docker.com/_/python/" target="_blank" rel="noopener noreferrer"><code>python</code><i>Content not supported</i></a>、<a href="https://hub.docker.com/_/ruby/" target="_blank" rel="noopener noreferrer"><code>ruby</code><i>Content not supported</i></a>、<a href="https://hub.docker.com/_/golang/" target="_blank" rel="noopener noreferrer"><code>golang</code><i>Content not supported</i></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p>
<p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="noopener noreferrer"><code>ubuntu</code><i>Content not supported</i></a>、<a href="https://hub.docker.com/_/debian/" target="_blank" rel="noopener noreferrer"><code>debian</code><i>Content not supported</i></a>、<a href="https://hub.docker.com/_/centos/" target="_blank" rel="noopener noreferrer"><code>centos</code><i>Content not supported</i></a>、<a href="https://hub.docker.com/_/fedora/" target="_blank" rel="noopener noreferrer"><code>fedora</code><i>Content not supported</i></a>、<a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener noreferrer"><code>alpine</code><i>Content not supported</i></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<div><pre><code><span><span>FROM</span> scratch</span>
...
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.google.cn/" target="_blank" rel="noopener noreferrer">Go 语言<i>Content not supported</i></a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p>
<h2 id="run-执行命令"> RUN 执行命令</h2>
<p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li>
</ul>
<div><pre><code><span><span>RUN</span> echo <span>'&lt;h1>Hello, Docker!&lt;/h1>'</span> > /usr/share/nginx/html/index.html</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li>
</ul>
<p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p>
<div><pre><code><span><span>FROM</span> debian:stretch</span>

<span><span>RUN</span> apt-get update</span>
<span><span>RUN</span> apt-get install -y gcc libc6-dev make wget</span>
<span><span>RUN</span> wget -O redis.tar.gz <span>"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span></span>
<span><span>RUN</span> mkdir -p /usr/src/redis</span>
<span><span>RUN</span> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span>
<span><span>RUN</span> make -C /usr/src/redis</span>
<span><span>RUN</span> make -C /usr/src/redis install</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p>
<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。
这是很多初学 Docker 的人常犯的一个错误。</p>
<p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p>
<p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p>
<div><pre><code><span><span>FROM</span> debian:stretch</span>

<span><span>RUN</span> set -x; buildDeps=<span>'gcc libc6-dev make wget'</span> <span>\</span>
    &amp;&amp; apt-get update <span>\</span>
    &amp;&amp; apt-get install -y <span>$buildDeps</span> <span>\</span>
    &amp;&amp; wget -O redis.tar.gz <span>"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> <span>\</span>
    &amp;&amp; mkdir -p /usr/src/redis <span>\</span>
    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 <span>\</span>
    &amp;&amp; make -C /usr/src/redis <span>\</span>
    &amp;&amp; make -C /usr/src/redis install <span>\</span>
    &amp;&amp; rm -rf /var/lib/apt/lists/* <span>\</span>
    &amp;&amp; rm redis.tar.gz <span>\</span>
    &amp;&amp; rm -r /usr/src/redis <span>\</span>
    &amp;&amp; apt-get purge -y --auto-remove <span>$buildDeps</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p>
<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p>
<h2 id="构建镜像"> 构建镜像</h2>
<p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p>
<p>在 <code>Dockerfile</code> 文件所在目录执行：</p>
<div><pre><code>$ <span>docker</span> build -t nginx:v3 <span>.</span>
Sending build context to Docker daemon <span>2.048</span> kB
Step <span>1</span> <span>:</span> FROM nginx
 ---<span>></span> e43d811ce2f4
Step <span>2</span> <span>:</span> RUN <span>echo</span> <span>'&lt;h1>Hello, Docker!&lt;/h1>'</span> <span>></span> /usr/share/nginx/html/index.html
 ---<span>></span> Running <span>in</span> 9cdc27646c7b
 ---<span>></span> 44aa4490ce2c
Removing intermediate container 9cdc27646c7b
Successfully built 44aa4490ce2c
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p>
<p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p>
<div><pre><code><span>docker</span> build <span>[</span>选项<span>]</span> <span>&lt;</span>上下文路径/URL/-<span>></span>
</code></pre>
<div><span>1</span><br></div></div><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p>
<h2 id="镜像构建上下文-context"> 镜像构建上下文（Context）</h2>
<p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p>
<p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener noreferrer">Docker Remote API<i>Content not supported</i></a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在 <code>Dockerfile</code> 中这么写：</p>
<div><pre><code><span><span>COPY</span> ./package.json /app/</span>
</code></pre>
<div><span>1</span><br></div></div><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p>
<p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>
<p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p>
<p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p>
<div><pre><code>$ <span>docker</span> build -t nginx:v3 <span>.</span>
Sending build context to Docker daemon <span>2.048</span> kB
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p>
<p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p>
<p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p>
<p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p>
<h2 id="其它-docker-build-的用法"> 其它 <code>docker build</code> 的用法</h2>
<h3 id="直接用-git-repo-进行构建"> 直接用 Git repo 进行构建</h3>
<p>或许你已经注意到了，<code>docker build</code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p>
<div><pre><code><span># $env:DOCKER_BUILDKIT=0</span>
<span># export DOCKER_BUILDKIT=0</span>

$ <span>docker</span> build -t hello-world https://github.com/docker-library/hello-world.git<span>#master:amd64/hello-world</span>

Step <span>1</span>/3 <span>:</span> FROM scratch
 ---<span>></span>
Step <span>2</span>/3 <span>:</span> COPY hello /
 ---<span>></span> ac779757d46e
Step <span>3</span>/3 <span>:</span> CMD <span>[</span><span>"/hello"</span><span>]</span>
 ---<span>></span> Running <span>in</span> d2a513a760ed
Removing intermediate container d2a513a760ed
 ---<span>></span> 038ad4142d2b
Successfully built 038ad4142d2b
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这行命令指定了构建所需的 Git repo，并且指定分支为 <code>master</code>，构建目录为 <code>/amd64/hello-world/</code>，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
<h3 id="用给定的-tar-压缩包构建"> 用给定的 tar 压缩包构建</h3>
<div><pre><code>$ <span>docker</span> build http://server/context.tar.gz
</code></pre>
<div><span>1</span><br></div></div><p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p>
<h3 id="从标准输入中读取-dockerfile-进行构建"> 从标准输入中读取 Dockerfile 进行构建</h3>
<div><pre><code><span>docker</span> build - <span>&lt;</span> Dockerfile
</code></pre>
<div><span>1</span><br></div></div><p>或</p>
<div><pre><code><span>cat</span> Dockerfile <span>|</span> <span>docker</span> build -
</code></pre>
<div><span>1</span><br></div></div><p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</p>
<h3 id="从标准输入中读取上下文压缩包进行构建"> 从标准输入中读取上下文压缩包进行构建</h3>
<div><pre><code>$ <span>docker</span> build - <span>&lt;</span> context.tar.gz
</code></pre>
<div><span>1</span><br></div></div><p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>
]]></content:encoded>
    </item>
    <item>
      <title>使用 Docker 镜像</title>
      <link>https://vuepress.mirror.docker-practice.com/image/</link>
      <guid>https://vuepress.mirror.docker-practice.com/image/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">使用 Docker 镜像</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="使用-docker-镜像"> 使用 Docker 镜像</h1>
<i>Content not supported</i>
<p>在之前的介绍中，我们知道镜像是 Docker 的三大组件之一。</p>
<p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p>
<p>本章将介绍更多关于镜像的内容，包括：</p>
<ul>
<li>
<p>从仓库获取镜像；</p>
</li>
<li>
<p>管理本地主机上的镜像；</p>
</li>
<li>
<p>介绍镜像实现的基本原理。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>利用 commit 理解镜像构成</title>
      <link>https://vuepress.mirror.docker-practice.com/image/commit/</link>
      <guid>https://vuepress.mirror.docker-practice.com/image/commit/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">利用 commit 理解镜像构成</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="利用-commit-理解镜像构成"> 利用 commit 理解镜像构成</h1>
<i>Content not supported</i>
<blockquote>
<p>注意：如果您是初学者，您可以暂时跳过后面的内容，直接学习 <a href="../container">容器</a> 一节。</p>
</blockquote>
<p>注意： <code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，定制镜像应该使用 <code>Dockerfile</code> 来完成。如果你想要定制镜像请查看下一小节。</p>
<p>镜像是容器的基础，每次执行 <code>docker run</code> 的时候都会指定哪个镜像作为容器运行的基础。在之前的例子中，我们所使用的都是来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求，而当这些镜像无法直接满足需求时，我们就需要定制这些镜像。接下来的几节就将讲解如何定制镜像。</p>
<p>回顾一下之前我们学到的知识，镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p>
<p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p>
<div><pre><code>$ <span>docker</span> run --name webserver -d -p <span>80</span>:80 nginx
</code></pre>
<div><span>1</span><br></div></div><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p>
<p>如果是在本机运行的 Docker，那么可以直接访问：<code>http://localhost</code> ，如果是在虚拟机、云服务器上安装的 Docker，则需要将 <code>localhost</code> 换为虚拟机地址或者实际云服务器地址。</p>
<p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。</p>
<p><img src="./_images/images-mac-example-nginx.png" alt=""></p>
<p>现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p>
<div><pre><code>$ <span>docker</span> <span>exec</span> -it webserver <span>bash</span>
root@3729b97e8226:/<span># echo '&lt;h1>Hello, Docker!&lt;/h1>' > /usr/share/nginx/html/index.html</span>
root@3729b97e8226:/<span># exit</span>
<span>exit</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p>
<p>然后，我们用 <code>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</code> 覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p>
<p>现在我们再刷新浏览器的话，会发现内容被改变了。</p>
<p><img src="./_images/images-create-nginx-docker.png" alt=""></p>
<p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</p>
<div><pre><code>$ <span>docker</span> <span>diff</span> webserver
C /root
A /root/.bash_history
C /run
C /usr
C /usr/share
C /usr/share/nginx
C /usr/share/nginx/html
C /usr/share/nginx/html/index.html
C /var
C /var/cache
C /var/cache/nginx
A /var/cache/nginx/client_temp
A /var/cache/nginx/fastcgi_temp
A /var/cache/nginx/proxy_temp
A /var/cache/nginx/scgi_temp
A /var/cache/nginx/uwsgi_temp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。</p>
<p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p>
<p><code>docker commit</code> 的语法格式为：</p>
<div><pre><code><span>docker</span> commit <span>[</span>选项<span>]</span> <span>&lt;</span>容器ID或容器名<span>></span> <span>[</span><span>&lt;</span>仓库名<span>></span><span>[</span>:<span>&lt;</span>标签<span>></span><span>]</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>我们可以用下面的命令将容器保存为镜像：</p>
<div><pre><code>$ <span>docker</span> commit <span>\</span>
    --author <span>"Tao Wang &lt;twang2218@gmail.com>"</span> <span>\</span>
    --message <span>"修改了默认网页"</span> <span>\</span>
    webserver <span>\</span>
    nginx:v2
sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。这点和 <code>git</code> 版本控制相似，不过这里这些信息可以省略留空。</p>
<p>我们可以在 <code>docker image ls</code> 中看到这个新定制的镜像：</p>
<div><pre><code>$ <span>docker</span> image <span>ls</span> nginx
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
nginx               v2                  07e334659748        <span>9</span> seconds ago       <span>181.5</span> MB
nginx               <span>1.11</span>                05a60462f8ba        <span>12</span> days ago         <span>181.5</span> MB
nginx               latest              e43d811ce2f4        <span>4</span> weeks ago         <span>181.5</span> MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p>
<div><pre><code>$ <span>docker</span> <span>history</span> nginx:v2
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
07e334659748        <span>54</span> seconds ago      nginx -g daemon off<span>;</span>                            <span>95</span> B                修改了默认网页
e43d811ce2f4        <span>4</span> weeks ago         /bin/sh -c <span>#(nop)  CMD ["nginx" "-g" "daemon    0 B</span>
<span>&lt;</span>missing<span>></span>           <span>4</span> weeks ago         /bin/sh -c <span>#(nop)  EXPOSE 443/tcp 80/tcp        0 B</span>
<span>&lt;</span>missing<span>></span>           <span>4</span> weeks ago         /bin/sh -c <span>ln</span> -sf /dev/stdout /var/log/nginx/   <span>22</span> B
<span>&lt;</span>missing<span>></span>           <span>4</span> weeks ago         /bin/sh -c apt-key adv --keyserver hkp://pgp.   <span>58.46</span> MB
<span>&lt;</span>missing<span>></span>           <span>4</span> weeks ago         /bin/sh -c <span>#(nop)  ENV NGINX_VERSION=1.11.5-1   0 B</span>
<span>&lt;</span>missing<span>></span>           <span>4</span> weeks ago         /bin/sh -c <span>#(nop)  MAINTAINER NGINX Docker Ma   0 B</span>
<span>&lt;</span>missing<span>></span>           <span>4</span> weeks ago         /bin/sh -c <span>#(nop)  CMD ["/bin/bash"]            0 B</span>
<span>&lt;</span>missing<span>></span>           <span>4</span> weeks ago         /bin/sh -c <span>#(nop) ADD file:23aa4f893e3288698c   123 MB</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>新的镜像定制好后，我们可以来运行这个镜像。</p>
<div><pre><code><span>docker</span> run --name web2 -d -p <span>81</span>:80 nginx:v2
</code></pre>
<div><span>1</span><br></div></div><p>这里我们命名为新的服务为 <code>web2</code>，并且映射到 <code>81</code> 端口。访问 <code>http://localhost:81</code> 看到结果，其内容应该和之前修改后的 <code>webserver</code> 一样。</p>
<p>至此，我们第一次完成了定制镜像，使用的是 <code>docker commit</code> 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p>
<h2 id="慎用-docker-commit"> 慎用 <code>docker commit</code></h2>
<p>使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p>
<p>首先，如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，将会导致镜像极为臃肿。</p>
<p>此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 <strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。</p>
<p>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Dockerfile 指令详解</title>
      <link>https://vuepress.mirror.docker-practice.com/image/dockerfile/</link>
      <guid>https://vuepress.mirror.docker-practice.com/image/dockerfile/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">Dockerfile 指令详解</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="dockerfile-指令详解"> Dockerfile 指令详解</h1>
<i>Content not supported</i>
<p>我们已经介绍了 <code>FROM</code>，<code>RUN</code>，还提及了 <code>COPY</code>, <code>ADD</code>，其实 <code>Dockerfile</code> 功能很强大，它提供了十多个指令。下面我们继续讲解其他的指令。</p>
]]></content:encoded>
    </item>
    <item>
      <title>ADD 更高级的复制文件</title>
      <link>https://vuepress.mirror.docker-practice.com/image/dockerfile/add/</link>
      <guid>https://vuepress.mirror.docker-practice.com/image/dockerfile/add/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">ADD 更高级的复制文件</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="add-更高级的复制文件"> ADD 更高级的复制文件</h1>
<i>Content not supported</i>
<p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p>
<p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p>
<p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p>
<p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p>
<div><pre><code><span><span>FROM</span> scratch</span>
<span><span>ADD</span> ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span>
...
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p>
<p>在 Docker 官方的 <a href="./../../appendix/best_practices.html">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p>
<p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<div><pre><code><span><span>ADD</span> <span><span>--chown</span><span>=</span><span>55:mygroup</span></span> files* /mydir/</span>
<span><span>ADD</span> <span><span>--chown</span><span>=</span><span>bin</span></span> files* /mydir/</span>
<span><span>ADD</span> <span><span>--chown</span><span>=</span><span>1</span></span> files* /mydir/</span>
<span><span>ADD</span> <span><span>--chown</span><span>=</span><span>10:11</span></span> files* /mydir/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>ARG 构建参数</title>
      <link>https://vuepress.mirror.docker-practice.com/image/dockerfile/arg/</link>
      <guid>https://vuepress.mirror.docker-practice.com/image/dockerfile/arg/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">ARG 构建参数</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="arg-构建参数"> ARG 构建参数</h1>
<i>Content not supported</i>
<p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p>
<p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p>灵活的使用 <code>ARG</code> 指令，能够在不修改 Dockerfile 的情况下，构建出不同的镜像。</p>
<p>ARG 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。</p>
<div><pre><code><span><span>ARG</span> DOCKER_USERNAME=library</span>

<span><span>FROM</span> <span>${DOCKER_USERNAME}</span>/alpine</span>

<span><span>RUN</span> set -x ; echo <span>${DOCKER_USERNAME}</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>使用上述 Dockerfile 会发现无法输出 <code>${DOCKER_USERNAME}</code> 变量的值，要想正常输出，你必须在 <code>FROM</code> 之后再次指定 <code>ARG</code></p>
<div><pre><code><span># 只在 FROM 中生效</span>
<span><span>ARG</span> DOCKER_USERNAME=library</span>

<span><span>FROM</span> <span>${DOCKER_USERNAME}</span>/alpine</span>

<span># 要想在 FROM 之后使用，必须再次指定</span>
<span><span>ARG</span> DOCKER_USERNAME=library</span>

<span><span>RUN</span> set -x ; echo <span>${DOCKER_USERNAME}</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>对于多阶段构建，尤其要注意这个问题</p>
<div><pre><code><span># 这个变量在每个 FROM 中都生效</span>
<span><span>ARG</span> DOCKER_USERNAME=library</span>

<span><span>FROM</span> <span>${DOCKER_USERNAME}</span>/alpine</span>

<span><span>RUN</span> set -x ; echo 1</span>

<span><span>FROM</span> <span>${DOCKER_USERNAME}</span>/alpine</span>

<span><span>RUN</span> set -x ; echo 2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>对于上述 Dockerfile 两个 <code>FROM</code> 指令都可以使用 <code>${DOCKER_USERNAME}</code>，对于在各个阶段中使用的变量都必须在每个阶段分别指定：</p>
<div><pre><code><span><span>ARG</span> DOCKER_USERNAME=library</span>

<span><span>FROM</span> <span>${DOCKER_USERNAME}</span>/alpine</span>

<span># 在FROM 之后使用变量，必须在每个阶段分别指定</span>
<span><span>ARG</span> DOCKER_USERNAME=library</span>

<span><span>RUN</span> set -x ; echo <span>${DOCKER_USERNAME}</span></span>

<span><span>FROM</span> <span>${DOCKER_USERNAME}</span>/alpine</span>

<span># 在FROM 之后使用变量，必须在每个阶段分别指定</span>
<span><span>ARG</span> DOCKER_USERNAME=library</span>

<span><span>RUN</span> set -x ; echo <span>${DOCKER_USERNAME}</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>CMD 容器启动命令</title>
      <link>https://vuepress.mirror.docker-practice.com/image/dockerfile/cmd/</link>
      <guid>https://vuepress.mirror.docker-practice.com/image/dockerfile/cmd/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">CMD 容器启动命令</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="cmd-容器启动命令"> CMD 容器启动命令</h1>
<i>Content not supported</i>
<p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p>
<ul>
<li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p>
<p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>
<div><pre><code><span><span>CMD</span> echo <span>$HOME</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>在实际执行中，会将其变更为：</p>
<div><pre><code><span><span>CMD</span> [ <span>"sh"</span>, <span>"-c"</span>, <span>"echo $HOME"</span> ]</span>
</code></pre>
<div><span>1</span><br></div></div><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</p>
<p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p>
<p>一些初学者将 <code>CMD</code> 写为：</p>
<div><pre><code><span><span>CMD</span> service nginx start</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p>
<div><pre><code><span><span>CMD</span> [<span>"nginx"</span>, <span>"-g"</span>, <span>"daemon off;"</span>]</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>COPY 复制文件</title>
      <link>https://vuepress.mirror.docker-practice.com/image/dockerfile/copy/</link>
      <guid>https://vuepress.mirror.docker-practice.com/image/dockerfile/copy/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">COPY 复制文件</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="copy-复制文件"> COPY 复制文件</h1>
<i>Content not supported</i>
<p>格式：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p>
<p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p>
<div><pre><code><span><span>COPY</span> package.json /usr/src/app/</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match" target="_blank" rel="noopener noreferrer"><code>filepath.Match</code><i>Content not supported</i></a> 规则，如：</p>
<div><pre><code><span><span>COPY</span> hom* /mydir/</span>
<span><span>COPY</span> hom?.txt /mydir/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<div><pre><code><span><span>COPY</span> <span><span>--chown</span><span>=</span><span>55:mygroup</span></span> files* /mydir/</span>
<span><span>COPY</span> <span><span>--chown</span><span>=</span><span>bin</span></span> files* /mydir/</span>
<span><span>COPY</span> <span><span>--chown</span><span>=</span><span>1</span></span> files* /mydir/</span>
<span><span>COPY</span> <span><span>--chown</span><span>=</span><span>10:11</span></span> files* /mydir/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p>
]]></content:encoded>
    </item>
    <item>
      <title>ENTRYPOINT 入口点</title>
      <link>https://vuepress.mirror.docker-practice.com/image/dockerfile/entrypoint/</link>
      <guid>https://vuepress.mirror.docker-practice.com/image/dockerfile/entrypoint/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">ENTRYPOINT 入口点</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="entrypoint-入口点"> ENTRYPOINT 入口点</h1>
<i>Content not supported</i>
<p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p>
<p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p>
<p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p>
<div><pre><code><span>&lt;</span>ENTRYPOINT<span>></span> <span>"&lt;CMD>"</span>
</code></pre>
<div><span>1</span><br></div></div><p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处么？让我们来看几个场景。</p>
<h4 id="场景一-让镜像变成像命令一样使用"> 场景一：让镜像变成像命令一样使用</h4>
<p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p>
<div><pre><code><span><span>FROM</span> ubuntu:18.04</span>
<span><span>RUN</span> apt-get update <span>\</span>
    &amp;&amp; apt-get install -y curl <span>\</span>
    &amp;&amp; rm -rf /var/lib/apt/lists/*</span>
<span><span>CMD</span> [ <span>"curl"</span>, <span>"-s"</span>, <span>"http://myip.ipip.net"</span> ]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p>
<div><pre><code>$ <span>docker</span> run myip
当前 IP：61.148.226.66 来自：北京市 联通
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p>
<div><pre><code>$ <span>docker</span> run myip -i
docker: Error response from daemon: invalid header field value <span>"oci runtime error: container_linux.go:247: starting container process caused <span title="\&quot;">\"</span>exec: <span title="\\">\\</span><span title="\&quot;">\"</span>-i<span title="\\">\\</span><span title="\&quot;">\"</span>: executable file not found in <span>$PATH</span><span title="\&quot;">\"</span><span title="\n">\n</span>"</span><span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://myip.ipip.net</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p>
<p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p>
<div><pre><code>$ <span>docker</span> run myip <span>curl</span> -s http://myip.ipip.net -i
</code></pre>
<div><span>1</span><br></div></div><p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p>
<div><pre><code><span><span>FROM</span> ubuntu:18.04</span>
<span><span>RUN</span> apt-get update <span>\</span>
    &amp;&amp; apt-get install -y curl <span>\</span>
    &amp;&amp; rm -rf /var/lib/apt/lists/*</span>
<span><span>ENTRYPOINT</span> [ <span>"curl"</span>, <span>"-s"</span>, <span>"http://myip.ipip.net"</span> ]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p>
<div><pre><code>$ <span>docker</span> run myip
当前 IP：61.148.226.66 来自：北京市 联通

$ <span>docker</span> run myip -i
HTTP/1.1 <span>200</span> OK
Server: nginx/1.8.0
Date: Tue, <span>22</span> Nov <span>2016</span> 05:12:40 GMT
Content-Type: text/html<span>;</span> <span>charset</span><span>=</span>UTF-8
Vary: Accept-Encoding
X-Powered-By: PHP/5.6.24-1~dotdeb+7.1
X-Cache: MISS from cache-2
X-Cache-Lookup: MISS from cache-2:80
X-Cache: MISS from proxy-2_6
Transfer-Encoding: chunked
Via: <span>1.1</span> cache-2:80, <span>1.1</span> proxy-2_6:8006
Connection: keep-alive

当前 IP：61.148.226.66 来自：北京市 联通
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p>
<h4 id="场景二-应用运行前的准备工作"> 场景二：应用运行前的准备工作</h4>
<p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p>
<p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p>
<p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p>
<p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p>
<div><pre><code><span><span>FROM</span> alpine:3.4</span>
...
<span><span>RUN</span> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span>
...
<span><span>ENTRYPOINT</span> [<span>"docker-entrypoint.sh"</span>]</span>

<span><span>EXPOSE</span> 6379</span>
<span><span>CMD</span> [ <span>"redis-server"</span> ]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p>
<div><pre><code><span>#!/bin/sh</span>
<span>..</span>.
<span># allow the container to be started with `--user`</span>
<span>if</span> <span>[</span> <span>"<span>$1</span>"</span> <span>=</span> <span>'redis-server'</span> -a <span>"<span><span>$(</span><span>id</span> -u<span>)</span></span>"</span> <span>=</span> <span>'0'</span> <span>]</span><span>;</span> <span>then</span>
	<span>find</span> <span>.</span> <span>\</span><span>!</span> -user redis -exec <span>chown</span> redis <span>'{}'</span> +
	<span>exec</span> gosu redis <span>"<span>$0</span>"</span> <span>"<span>$@</span>"</span>
<span>fi</span>

<span>exec</span> <span>"<span>$@</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p>
<div><pre><code>$ <span>docker</span> run -it redis <span>id</span>
<span>uid</span><span>=</span><span>0</span><span>(</span>root<span>)</span> <span>gid</span><span>=</span><span>0</span><span>(</span>root<span>)</span> <span>groups</span><span>=</span><span>0</span><span>(</span>root<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>EXPOSE 声明端口</title>
      <link>https://vuepress.mirror.docker-practice.com/image/dockerfile/expose/</link>
      <guid>https://vuepress.mirror.docker-practice.com/image/dockerfile/expose/</guid>
      <source url="https://vuepress.mirror.docker-practice.com/rss.xml">EXPOSE 声明端口</source>
      <pubDate>Thu, 12 May 2022 21:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="expose-声明端口"> EXPOSE 声明端口</h1>
<i>Content not supported</i>
<p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>