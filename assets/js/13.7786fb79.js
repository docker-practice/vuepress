(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{332:function(a,s,t){"use strict";t.r(s);var e=t(33),v=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"容器访问控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容器访问控制"}},[a._v("#")]),a._v(" 容器访问控制")]),a._v(" "),t("p",[a._v("容器的访问控制，主要通过 Linux 上的 "),t("code",[a._v("iptables")]),a._v(" 防火墙来进行管理和实现。"),t("code",[a._v("iptables")]),a._v(" 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。")]),a._v(" "),t("h2",{attrs:{id:"容器访问外部网络"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容器访问外部网络"}},[a._v("#")]),a._v(" 容器访问外部网络")]),a._v(" "),t("p",[a._v("容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$sysctl")]),a._v(" net.ipv4.ip_forward\nnet.ipv4.ip_forward "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v("\n")])])]),t("p",[a._v("如果为 0，说明没有开启转发，则需要手动打开。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$sysctl")]),a._v(" -w net.ipv4.ip_forward"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v("\n")])])]),t("p",[a._v("如果在启动 Docker 服务的时候设定 "),t("code",[a._v("--ip-forward=true")]),a._v(", Docker 就会自动设定系统的 "),t("code",[a._v("ip_forward")]),a._v(" 参数为 1。")]),a._v(" "),t("h2",{attrs:{id:"容器之间访问"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容器之间访问"}},[a._v("#")]),a._v(" 容器之间访问")]),a._v(" "),t("p",[a._v("容器之间相互访问，需要两方面的支持。")]),a._v(" "),t("ul",[t("li",[a._v("容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 "),t("code",[a._v("docker0")]),a._v(" 网桥上。")]),a._v(" "),t("li",[a._v("本地系统的防火墙软件 -- "),t("code",[a._v("iptables")]),a._v(" 是否允许通过。")])]),a._v(" "),t("h3",{attrs:{id:"访问所有端口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#访问所有端口"}},[a._v("#")]),a._v(" 访问所有端口")]),a._v(" "),t("p",[a._v("当启动 Docker 服务（即 dockerd）的时候，默认会添加一条转发策略到本地主机 iptables 的 FORWARD 链上。策略为通过（"),t("code",[a._v("ACCEPT")]),a._v("）还是禁止（"),t("code",[a._v("DROP")]),a._v("）取决于配置"),t("code",[a._v("--icc=true")]),a._v("（缺省值）还是 "),t("code",[a._v("--icc=false")]),a._v("。当然，如果手动指定 "),t("code",[a._v("--iptables=false")]),a._v(" 则不会添加 "),t("code",[a._v("iptables")]),a._v(" 规则。")]),a._v(" "),t("p",[a._v("可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 "),t("code",[a._v("/etc/docker/daemon.json")]),a._v(" 文件中配置 "),t("code",[a._v('{"icc": false}')]),a._v(" 来禁止它。")]),a._v(" "),t("h3",{attrs:{id:"访问指定端口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#访问指定端口"}},[a._v("#")]),a._v(" 访问指定端口")]),a._v(" "),t("p",[a._v("在通过 "),t("code",[a._v("-icc=false")]),a._v(" 关闭网络访问后，还可以通过 "),t("code",[a._v("--link=CONTAINER_NAME:ALIAS")]),a._v(" 选项来访问容器的开放端口。")]),a._v(" "),t("p",[a._v("例如，在启动 Docker 服务时，可以同时使用 "),t("code",[a._v("icc=false --iptables=true")]),a._v(" 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 "),t("code",[a._v("iptables")]),a._v(" 规则。")]),a._v(" "),t("p",[a._v("此时，系统中的 "),t("code",[a._v("iptables")]),a._v(" 规则可能是类似")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("$ "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("sudo")]),a._v(" iptables -nL\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v(".\nChain FORWARD "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("policy ACCEPT"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\ntarget     prot opt "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("source")]),a._v("               destination\nDROP       all  --  "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.0")]),a._v(".0.0/0            "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.0")]),a._v(".0.0/0\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v(".\n")])])]),t("p",[a._v("之后，启动容器（"),t("code",[a._v("docker run")]),a._v("）时使用 "),t("code",[a._v("--link=CONTAINER_NAME:ALIAS")]),a._v(" 选项。Docker 会在 "),t("code",[a._v("iptable")]),a._v(" 中为 两个容器分别添加一条 "),t("code",[a._v("ACCEPT")]),a._v(" 规则，允许相互访问开放的端口（取决于 "),t("code",[a._v("Dockerfile")]),a._v(" 中的 "),t("code",[a._v("EXPOSE")]),a._v(" 指令）。")]),a._v(" "),t("p",[a._v("当添加了 "),t("code",[a._v("--link=CONTAINER_NAME:ALIAS")]),a._v(" 选项后，添加了 "),t("code",[a._v("iptables")]),a._v(" 规则。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("$ "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("sudo")]),a._v(" iptables -nL\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v(".\nChain FORWARD "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("policy ACCEPT"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\ntarget     prot opt "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("source")]),a._v("               destination\nACCEPT     tcp  --  "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("172.17")]),a._v(".0.2           "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("172.17")]),a._v(".0.3           tcp spt:80\nACCEPT     tcp  --  "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("172.17")]),a._v(".0.3           "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("172.17")]),a._v(".0.2           tcp dpt:80\nDROP       all  --  "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.0")]),a._v(".0.0/0            "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.0")]),a._v(".0.0/0\n")])])]),t("p",[a._v("注意："),t("code",[a._v("--link=CONTAINER_NAME:ALIAS")]),a._v(" 中的 "),t("code",[a._v("CONTAINER_NAME")]),a._v(" 目前必须是 Docker 分配的名字，或使用 "),t("code",[a._v("--name")]),a._v(" 参数指定的名字。主机名则不会被识别。")])])}),[],!1,null,null,null);s.default=v.exports}}]);